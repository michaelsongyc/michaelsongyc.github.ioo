[{"categories":["生活"],"content":"视角 ","date":"2021-01-03","objectID":"/posts/life/sentence/:1:0","tags":["励志"],"title":"心灵鸡汤","uri":"/posts/life/sentence/"},{"categories":["生活"],"content":"邓宁-克鲁格心理效应 能力欠缺的人在自己欠考虑的决定的基础上得出错误结论，但是无法正确认识到自身的不足，辨别错误行为，是一种认知偏差现象。这些能力欠缺者们沉浸在自我营造的虚幻的优势之中，常常高估自己的能力水平，却无法客观评价他人的能力。 邓宁-克鲁格心理效应 ","date":"2021-01-03","objectID":"/posts/life/sentence/:1:1","tags":["励志"],"title":"心灵鸡汤","uri":"/posts/life/sentence/"},{"categories":["生活"],"content":"相对论 视角 ","date":"2021-01-03","objectID":"/posts/life/sentence/:1:2","tags":["励志"],"title":"心灵鸡汤","uri":"/posts/life/sentence/"},{"categories":["生活"],"content":"随笔 不要沉迷框架，修炼内功 提高英语阅读能力【google translate】 职场从来不缺普通的程序员 工作之外有自己感兴趣的东西 学会规划自己的时间，时间管理【be foucused、番茄todo】 学会安排自己的任务【Trello】 学会使用工具提升工作效率 学会休息，注意健康 对业务和产品比较敏感。 提升技术的深度、技术的广度、对业务和产品敏感的个人。 用最快的方式，提高自己的核心竞争力。 ","date":"2021-01-03","objectID":"/posts/life/sentence/:2:0","tags":["励志"],"title":"心灵鸡汤","uri":"/posts/life/sentence/"},{"categories":["生活"],"content":"大道至简 加油，把刷题变成打游戏一样的兴趣。 天道酬勤，凡事感激. 编程能力就像任何其他技能一样，也是一个可以通过刻意练习大大提高。 大多数经典面试题目都有多种解决方案。 为了达到最佳的练习效果，我们强烈建议您至少将此清单里的题目练习两遍，如果可以的话，三遍会更好。 在第二遍练习时，你可能会发现一些新的技巧或新的方法。 到第三遍的时候，你会发现你的代码要比第一次提交时更加简洁。 如果你达到了这样的效果，那么恭喜你，你已经掌握了正确的练习方法！ 记住：刻意练习并不意味着寻找答案并记住它，这种练习方法不是长久之计。 在没有参考答案情况下，越能自主解决问题，才越能提高自身能力。 ","date":"2021-01-03","objectID":"/posts/life/sentence/:3:0","tags":["励志"],"title":"心灵鸡汤","uri":"/posts/life/sentence/"},{"categories":["生活"],"content":"北大通知书 假如北大在你高一的时候就给你发了一张录取通知书，但是要想得到它的话，你需要在高中三年满足以下六个条件，你答应还是不答应？ 第一，每天早晨05:40起床，唤醒大脑，坚持晨读。 第二，每天坚持背50个单词。 第三，每天坚持复习昨天学过的内容。 第四，每周末坚持整理本周的数理化错题。 第五，经常思考学过的知识点，它背后的逻辑没有掌握好，就去重新学习。 第六，每天抽时间做体育锻炼。 等到三年以后，你只要满足以上条件，那这张录取通知书就生效，你愿意答应吗？ 我想你心中已经有了答案，但其实如果你三年能够坚持做到这六点事儿，完全可以自己考上北大。 ","date":"2021-01-03","objectID":"/posts/life/sentence/:4:0","tags":["励志"],"title":"心灵鸡汤","uri":"/posts/life/sentence/"},{"categories":null,"content":"天行健，君子以自强不息 SYC出生在河南的一个普通农村，小学初中在乡里，高中在一个五线的小县城，高考那年全省考生近100万，当年本、专科录取率30%， 意味着有近70w的学生不能再继续学习深造，想想都是泪水；🙁 知识改变命运，大学毕业后，先后在上海、杭州工作过，机缘巧合，经历过创业公司、中厂和互联网大厂，横跨供应链、金融、互联网电商等行业。 18年加入AL，作为一名技术同学，在国际化电商板块搬砖，为国际化业务贡献自己的一份力量! 😀 ","date":"2022-08-15","objectID":"/aboutme/:0:0","tags":null,"title":"关于","uri":"/aboutme/"},{"categories":["生活"],"content":" 今年年初就计划着去新疆旅行，刚好六月份看到朋友发的帖子，大家一拍即合，开团成行；刚好借此计划给自己放一个长假， 把自己从持续多年的忙碌状态中抽离出来，利用这几天时间，来一场心灵的放松、灵魂的洗礼和体力的马拉松。来阿里四年，给自己休的第一次长假。 ","date":"2022-07-22","objectID":"/posts/travel/xinjiang/:0:0","tags":["新疆"],"title":"新疆旅行-北疆","uri":"/posts/travel/xinjiang/"},{"categories":["生活"],"content":"行程计划 2022.7.8 - 2022.7.17 7.8： 杭州出发； 7.9： 尹宁 伊力特酒厂、六星街、伊犁河；（美食） 7.10：尹宁7点发车（1.5小时车程）、紫仙镇薰衣草庄园（1小时）、（1小时车程）果子沟（1.5小时）、午餐、赛里木湖（落日）（9小时左右）、（1.5小时车程）住清水河镇（预计12点多了）； 7.11：清水河镇8点出发附近看免费薰衣草（1小时），（6.5小时车程）前往夏塔旅游风景区，进景区入住，有时间可以游玩下（星空）； 7.12：6点早起，早餐后徒步夏塔古道（20公里左右，原路往返，也许还有日出）、17点左右出景区晚饭、（3小时）驱车住特克斯、八卦城； 7.13：早起，（8点前）喀拉峻（8小时）、阔克苏大峡谷（4h）、（4小时车程）住那拉提； 7.14：（8点）那拉提风景区（一整天），住那拉提； 7.15：坐车到巴音（2.5小时），巴音天鹅湖、九曲十八弯（落日）、住巴音；（大巴车返回伊宁） 7.16：换5座或7座车，完整独库公路+s101国防公路（百里丹霞，走一段，不然吃不消），到乌鲁木齐； 7.17：返杭； ","date":"2022-07-22","objectID":"/posts/travel/xinjiang/:1:0","tags":["新疆"],"title":"新疆旅行-北疆","uri":"/posts/travel/xinjiang/"},{"categories":["生活"],"content":"DAY1 [周五] 2022.7.8, 头天晚上和同事一起吃夜宵到凌晨一点，聊得很嗨，晚上回家后又解决几个工作问题，本打算熬下夜直接去机场，谁知凌晨两点多，收到航空公司航班延迟起飞的信息， 果断睡觉； 早上起床后，收拾行李，刚好赶上早高峰，预估打车的话会堵车，测算地铁到机场的站总数后（地铁时间相对能准确预测），果断选择做地铁去机场； 最终一个半小时准时到达机场，和小伙伴汇合，完美; 11:55起飞，14:55到达兰州中川机场，机场吃了碗拉州拉面，本以为到达兰州本土，味道会有些不一样，结果证明期望过高，味道可能还不如个别面馆； 航班原计划19:35起飞，上飞机后，因为天气原因，硬生生拖到20:45才起飞（小插曲，上飞机后，有些累，就立马闭眼补觉，后来醒了看了下外面，哇塞，落地了，这么快，爽！； 然后在停顿了几秒，懵懵的看了下周围，脑袋瞬间清晰，瓦特… 这都一觉睡醒了，飞机还没起飞！！！），最终23:35到达伊宁。 目前还属于疫情管控时期，到新疆前需要提前申报行程，不然有可能落地后被原地劝返； 今天的时间基本全花在路途中。 凌晨两点吃晚饭； ","date":"2022-07-22","objectID":"/posts/travel/xinjiang/:2:0","tags":["新疆"],"title":"新疆旅行-北疆","uri":"/posts/travel/xinjiang/"},{"categories":["生活"],"content":"DAY2[周六] 今日安排：伊力特酒厂、六星街、伊犁河、喀赞其民宿旅游区。 早餐七点起床，吃早餐； 借助花姐独特的人脉关系，有幸拜访伊力特酒厂，了解到酒厂的历史发展轨迹，由几代人共同的心血才铸就而成，心中五味杂陈。品尝了红冰、白冰葡萄酒，酸甜可口，让人垂涎三尺。 了解到了北纬45°生命线，独特的地理气候，最终生长出优质的瓜果粮食。品尝了内部迎宾特供伊力特45°白酒，味道纯正，不辛辣，后劲也不大，超出预期；午饭吃了羊肉包、羊肉，没有疝气，味道鲜美，怒赞！ 在六星街，看到新疆本土大叔悠闲的用手风琴演奏本土轻音乐，音调轻缓优美，让人瞬间放松，忘记一切凡尘琐事，享受生活。 六星街-公路咖啡 自东向西流的伊犁河，以及晚上九点悬挂半空的大太阳. （以东部地区同学对东八区的时间理解，在这里有些颠覆认知） 伊犁河 ","date":"2022-07-22","objectID":"/posts/travel/xinjiang/:3:0","tags":["新疆"],"title":"新疆旅行-北疆","uri":"/posts/travel/xinjiang/"},{"categories":["生活"],"content":"DAY3 [周日] 今日安排：紫仙镇薰衣草庄园、果子沟、赛里木湖。 凌晨2点睡觉，早晨7点吃早餐； 7月中薰衣草已经花谢，薰衣草庄园里并没有看到成片的花海，听当地人说，最好6月中旬来。 果子沟全长4.4千米，大桥长700米。 塔里木湖【强烈推荐去！】 大西洋的最后一滴眼泪，让人沉醉； 围着赛里木湖转了一圈，感受到它的独特，海天一色的蓝，一望无际的湖面，让人内心平静； 坐在长廊中间，眺望眼前的赛里木湖，心无杂念，凡尘种种，皆为过往；远处挺拔的雪山和蓝天白云，造就出了当地人民心中的“净海”。 ","date":"2022-07-22","objectID":"/posts/travel/xinjiang/:4:0","tags":["新疆"],"title":"新疆旅行-北疆","uri":"/posts/travel/xinjiang/"},{"categories":["生活"],"content":"DAY4[周一] 今日安排：油菜花田、入住夏塔旅游风景区； 早7点起床，“温州包子\"早餐店吃早点； 去夏塔旅游风景区途中，遇到油菜花田，犹豫天气不太好，不好出片，如果天气不错，效果会很棒； 入住夏塔小木屋，晚上是真的冷，好在有电热毯，相对舒服的睡了半宿。 ","date":"2022-07-22","objectID":"/posts/travel/xinjiang/:5:0","tags":["新疆"],"title":"新疆旅行-北疆","uri":"/posts/travel/xinjiang/"},{"categories":["生活"],"content":"DAY5[周二] 今日安排：徒步夏塔古道（20公里左右）、特克斯、八卦城； 早上五点半起床，六点出发徒步，目的地雪山； ","date":"2022-07-22","objectID":"/posts/travel/xinjiang/:6:0","tags":["新疆"],"title":"新疆旅行-北疆","uri":"/posts/travel/xinjiang/"},{"categories":["生活"],"content":"DAY6[周三] 今日安排：喀拉峻草原、阔克苏大峡谷（4h） 喀拉峻草原\u0026\u0026阔克苏大峡谷，高山草原(7月这里的草，有些泛黄)，视野辽阔，山风吹过很冷，不过可以抱只小羊，相当暖和。 ","date":"2022-07-22","objectID":"/posts/travel/xinjiang/:7:0","tags":["新疆"],"title":"新疆旅行-北疆","uri":"/posts/travel/xinjiang/"},{"categories":["生活"],"content":"DAY7[周四] 今日安排：那拉提风景区 ","date":"2022-07-22","objectID":"/posts/travel/xinjiang/:8:0","tags":["新疆"],"title":"新疆旅行-北疆","uri":"/posts/travel/xinjiang/"},{"categories":["生活"],"content":"DAY8[周五] 今日安排：巴音天鹅湖、九曲十八弯（落日） 天鹅湖里有几只天鹅，但湖水味道呛人，过敏者慎入； 九曲十八弯，如果遇到落日，会更美；这里的山风吹得让人由内而外的发冷，山上有个小超市，买了包泡面，店主赠送开水，价钱合理，吃饱取暖，完美； ","date":"2022-07-22","objectID":"/posts/travel/xinjiang/:9:0","tags":["新疆"],"title":"新疆旅行-北疆","uri":"/posts/travel/xinjiang/"},{"categories":["生活"],"content":"DAY9[周六] 今日安排：独库公路+s101国防公路，到乌鲁木齐 路上偶遇彩虹，有点超出预期； 一路上听说会经历春夏秋冬，途中遇到的几个小雪山，和预期中的差距蛮大，不过能近距离看到，也算不错。整条独库路是有些绕，不建议新手自驾； 独库公路-雪山 独库公路 ","date":"2022-07-22","objectID":"/posts/travel/xinjiang/:10:0","tags":["新疆"],"title":"新疆旅行-北疆","uri":"/posts/travel/xinjiang/"},{"categories":["生活"],"content":"DAY10[周日] 因为预定酒店比较找，酒店有赠送整点接送服务，所以早晨6点半起床，7点出门，7点一刻到机场，机场吃了点八宝粥，8:25乌鲁木齐起飞，中途郑州中转1小时，然后14：55到达杭州萧山。 ","date":"2022-07-22","objectID":"/posts/travel/xinjiang/:11:0","tags":["新疆"],"title":"新疆旅行-北疆","uri":"/posts/travel/xinjiang/"},{"categories":["生活"],"content":"费用 去新机票：2217 返杭机票：2225 酒店+交通：3500 部分景点门票: 132+145+132+115+150+135 其他开销另算 上述小计：8751； ","date":"2022-07-22","objectID":"/posts/travel/xinjiang/:12:0","tags":["新疆"],"title":"新疆旅行-北疆","uri":"/posts/travel/xinjiang/"},{"categories":["Tech"],"content":"Mac ","date":"2022-05-01","objectID":"/posts/tech/setup/install-software-collection/:0:0","tags":["install"],"title":"Mac下开发工具安装","uri":"/posts/tech/setup/install-software-collection/"},{"categories":["Tech"],"content":"Tool Charles ","date":"2022-05-01","objectID":"/posts/tech/setup/install-software-collection/:1:0","tags":["install"],"title":"Mac下开发工具安装","uri":"/posts/tech/setup/install-software-collection/"},{"categories":["Tech"],"content":"DB mac-mysql安装-参考-1 mac-mysql安装-参考-2 mac-python3 安装-参考 mac-Homebrew 安装-参考 ","date":"2022-05-01","objectID":"/posts/tech/setup/install-software-collection/:2:0","tags":["install"],"title":"Mac下开发工具安装","uri":"/posts/tech/setup/install-software-collection/"},{"categories":["生活"],"content":"攀爬 晶莹剔透 群山环绕 ","date":"2021-12-17","objectID":"/posts/life/sport/longwangshan/:1:0","tags":["龙王山","雾凇","户外"],"title":"[户外]龙王山-雾凇","uri":"/posts/life/sport/longwangshan/"},{"categories":["生活"],"content":"雾凇 对于没在山上长大的同学，能看到雾凇的机会不是太多； 近距离看雾凇 ","date":"2021-12-17","objectID":"/posts/life/sport/longwangshan/:2:0","tags":["龙王山","雾凇","户外"],"title":"[户外]龙王山-雾凇","uri":"/posts/life/sport/longwangshan/"},{"categories":["生活"],"content":"龙王山·雾凇（1587m） 到达山顶 ","date":"2021-12-17","objectID":"/posts/life/sport/longwangshan/:3:0","tags":["龙王山","雾凇","户外"],"title":"[户外]龙王山-雾凇","uri":"/posts/life/sport/longwangshan/"},{"categories":["生活"],"content":"记录 记录 ","date":"2021-12-17","objectID":"/posts/life/sport/longwangshan/:4:0","tags":["龙王山","雾凇","户外"],"title":"[户外]龙王山-雾凇","uri":"/posts/life/sport/longwangshan/"},{"categories":[""],"content":"古语 子曰：“学而时习之，不亦说乎?有朋自远方来，不亦乐乎?人不知而不愠，不亦君子乎?”（《学而》） 曾子曰：“吾日三省吾身：为人谋而不忠乎？与朋友交而不信乎？传不习乎？”（《学而》） 子曰：“温故而知新，可以为师矣。”（《为政》） 子曰：“学而不思则罔,思而不学则殆。”（《为政》） 子曰：“由，诲女知之乎！知之为知之，不知为不知，是知也。”（《为政》） 子曰：“见贤思齐焉，见不贤而内自省也。”（《里仁》） 子曰：“三人行，必有我师焉。择其善者而从之，其不善者而改之。”（《述而》） 曾子曰：“士不可以不弘毅，任重而道远。仁以为己任，不亦重乎？死而后已，不亦远乎？”（《泰伯》） 子曰：“岁寒，然后知松柏之后凋也。”（《子罕》） 子贡问曰：“有一言而可以终身行之者乎？”子曰：“其恕乎！己所不欲，勿施于人。”（《卫灵公》） ","date":"2021-10-03","objectID":"/posts/book/famoussentence/:1:0","tags":["读书笔记"],"title":"[读书笔记] 吾日三省吾身","uri":"/posts/book/famoussentence/"},{"categories":[""],"content":"今语 你永远都不会知道自己到底有多坚强，直到有一天你除了坚强别无选择！ ","date":"2021-10-03","objectID":"/posts/book/famoussentence/:2:0","tags":["读书笔记"],"title":"[读书笔记] 吾日三省吾身","uri":"/posts/book/famoussentence/"},{"categories":["读书笔记"],"content":"案例背景 中国正处在一个至关重要的十字路口上。制造廉价产品已使中国有了很大的发展，但上升的劳动力成本、环境问题、收入不平等以及对创新的需求都意味着重要的不是制造更廉价的产品，而是更好地进行产品营销。只有这样，中国才能赚更多的钱，才能在员工收入、环境保护和其他方面进行更大的投入。这意味着中国需要更好地掌握如何在顾客和潜在顾客的心智中建立品牌和认知，如何应对国内及国际上无处不在的竞争. 这也正是我的许多书能够发挥作用的地方。它们都是关于如何通过在众多竞争者中实现差昇化来定位自己的品牌；它们都是关于如何保持简单、如何运用常识以及如何寻求显而易见又强有力的概念。总的来讲，无论你想要销售什么，它们都会告诉你如何成为一个更好的营销者。 我的中国合伙人邓德隆先生正将其中的很多理论在中国加以运用，他甚至为企业家开设了 “定位”培训课程。但是，中国如果要建立自己的品牌，正如你们在日本、韩国和世界其他地方所看到的那些品牌，你们依然有很长的路要走。 但有一件事很明了：继续“制造更廉价的产品”只会死路一条，因为其他国家会想办法把价格压得更低。 ","date":"2021-08-21","objectID":"/posts/book/life_orientation/:1:0","tags":["规划"],"title":"[读书笔记] 《人生定位》","uri":"/posts/book/life_orientation/"},{"categories":["读书笔记"],"content":"新生产工具：定位 在此背景下，为组织准确定义成果的新生产工具一定位(positioning），在1969年被杰克•特芳特发明出来，掀起了第三次生产力革命。在谈到为何选择“定位”一词来命名这一新工具时，特劳特曾说：“《韦氏词典》对战略的定义是针对敌人（竞争对手），确立最具优势的位置 （position)。这正好是定位要做的工作。” 在顾客心智中针对竞争对手确定最具优势的位置，从而使品牌胜出竟争赢得优先选择，这就是企业需全力以赴抵达的成果，也是企业赖以存在的唯一理由。正如德鲁克在评价泰勒“四步工作法”时说：“泰勒的方法听起来没什么了不起有效的方法常常如此。其实这套方法花了泰勒整整20年的时间去试验，才整理发展出来。”这段话用来描述特劳特与定位同样适用。 ","date":"2021-08-21","objectID":"/posts/book/life_orientation/:2:0","tags":["规划"],"title":"[读书笔记] 《人生定位》","uri":"/posts/book/life_orientation/"},{"categories":["读书笔记"],"content":"定位四步工作法 第一步，分析整个外部环境，确定“我们的竞年对手是谁，竞争对手的价值是什么”（这与德鲁克在回答管理第一问“我们的业务是什么，应该是什么”时问的 “我们的顾客是谁，顾客的价值是什么”相反，因过多的选择、 有限的心智，决定了经营方式已从顾客导向转向了竞年导向）。 第二步，避开竞年对手在顾客心智中的强势，或是利用其强势中蕴含的弱点，确立品牌的优势位置-定位。 第三步，为这一定位寻求一个可靠的证明——信任状。 第四步，将这一定位整合进企业内部运营的方方面面，特别是传播上要有足够多的资源，以将这一定位植入顾客的心智 ","date":"2021-08-21","objectID":"/posts/book/life_orientation/:3:0","tags":["规划"],"title":"[读书笔记] 《人生定位》","uri":"/posts/book/life_orientation/"},{"categories":["leetcode"],"content":"一、数据结构的存储方式 数据结构的存储方式只有两种：数组（顺序存储）和链表（链式存储） 这句话怎么理解，不是还有散列表、栈、队列、堆、树、图等等各种数据结构吗？ 我们分析问题，一定要有递归的思想，自顶向下，从抽象到具体。你上来就列出这么多，那些都属于「上层建筑」，而数组和链表才是「结构基础」。因为那些多样化的数据结构，究其源头，都是在链表或者数组上的特殊操作，API 不同而已。 比如说「队列」、「栈」这两种数据结构既可以使用链表也可以使用数组实现。用数组实现，就要处理扩容缩容的问题；用链表实现，没有这个问题，但需要更多的内存空间存储节点指针。 「图」的两种表示方法，邻接表就是链表，邻接矩阵就是二维数组。邻接矩阵判断连通性迅速，并可以进行矩阵运算解决一些问题，但是如果图比较稀疏的话很耗费空间。邻接表比较节省空间，但是很多操作的效率上肯定比不过邻接矩阵。 「散列表」就是通过散列函数把键映射到一个大数组里。而且对于解决散列冲突的方法，拉链法需要链表特性，操作简单，但需要额外的空间存储指针；线性探查法就需要数组特性，以便连续寻址，不需要指针的存储空间，但操作稍微复杂些。 「树」，用数组实现就是「堆」，因为「堆」是一个完全二叉树，用数组存储不需要节点指针，操作也比较简单；用链表实现就是很常见的那种「树」，因为不一定是完全二叉树，所以不适合用数组存储。为此，在这种链表「树」结构之上，又衍生出各种巧妙的设计，比如二叉搜索树、AVL 树、红黑树、区间树、B 树等等，以应对不同的问题。 了解 Redis 数据库的朋友可能也知道，Redis 提供列表、字符串、集合等等几种常用数据结构，但是对于每种数据结构，底层的存储方式都至少有两种，以便于根据存储数据的实际情况使用合适的存储方式。 综上，数据结构种类很多，甚至你也可以发明自己的数据结构，但是底层存储无非数组或者链表，二者的优缺点如下： 数组由于是紧凑连续存储,可以随机访问，通过索引快速找到对应元素，而且相对节约存储空间。但正因为连续存储，内存空间必须一次性分配够，所以说数组如果要扩容，需要重新分配一块更大的空间，再把数据全部复制过去，时间复杂度 O(N)；而且你如果想在数组中间进行插入和删除，每次必须搬移后面的所有数据以保持连续，时间复杂度 O(N)。 链表因为元素不连续，而是靠指针指向下一个元素的位置，所以不存在数组的扩容问题；如果知道某一元素的前驱和后驱，操作指针即可删除该元素或者插入新元素，时间复杂度 O(1)。但是正因为存储空间不连续，你无法根据一个索引算出对应元素的地址，所以不能随机访问；而且由于每个元素必须存储指向前后元素位置的指针，会消耗相对更多的储存空间。 ","date":"2021-08-18","objectID":"/posts/tech/leetcode/algorithm/:1:0","tags":["算法","leetcode"],"title":"算法概述","uri":"/posts/tech/leetcode/algorithm/"},{"categories":["leetcode"],"content":"二、数据结构的基本操作 对于任何数据结构，其基本操作无非遍历 + 访问，再具体一点就是：增删查改。 数据结构种类很多，但它们存在的目的都是在不同的应用场景，尽可能高效地增删查改。话说这不就是数据结构的使命么？ 如何遍历 + 访问？我们仍然从最高层来看，各种数据结构的遍历 + 访问无非两种形式：线性的和非线性的。 线性就是 for/while 迭代为代表，非线性就是递归为代表。再具体一步，无非以下几种框架： 数组遍历框架，典型的线性迭代结构： void traverse(int[] arr) { for (int i = 0; i \u003c arr.length; i++) { // 迭代访问 arr[i] } } 链表遍历框架，兼具迭代和递归结构： /* 基本的单链表节点 */ class ListNode { int val; ListNode next; } void traverse(ListNode head) { for (ListNode p = head; p != null; p = p.next) { // 迭代访问 p.val } } void traverse(ListNode head) { // 递归访问 head.val traverse(head.next); } 二叉树遍历框架，典型的非线性递归遍历结构： /* 基本的二叉树节点 */ class TreeNode { int val; TreeNode left, right; } void traverse(TreeNode root) { traverse(root.left); traverse(root.right); } 你看二叉树的递归遍历方式和链表的递归遍历方式，相似不？再看看二叉树结构和单链表结构，相似不？如果再多几条叉，N 叉树你会不会遍历？ 二叉树框架可以扩展为 N 叉树的遍历框架： /* 基本的 N 叉树节点 */ class TreeNode { int val; TreeNode[] children; } void traverse(TreeNode root) { for (TreeNode child : root.children) traverse(child); } N 叉树的遍历又可以扩展为图的遍历，因为图就是好几 N 叉棵树的结合体。你说图是可能出现环的？这个很好办，用个布尔数组 visited 做标记就行了，这里就不写代码了。 所谓框架，就是套路。不管增删查改，这些代码都是永远无法脱离的结构，你可以把这个结构作为大纲，根据具体问题在框架上添加代码就行了，下面会具体举例。 ","date":"2021-08-18","objectID":"/posts/tech/leetcode/algorithm/:2:0","tags":["算法","leetcode"],"title":"算法概述","uri":"/posts/tech/leetcode/algorithm/"},{"categories":["leetcode"],"content":"三、算法刷题指南 首先要明确的是，数据结构是工具，算法是通过合适的工具解决特定问题的方法。也就是说，学习算法之前，最起码得了解那些常用的数据结构，了解它们的特性和缺陷。 所以我建议的刷题顺序是： 1、先学习像数组、链表这种基本数据结构的常用算法，比如单链表翻转，前缀和数组，二分搜索等。 因为这些算法属于会者不难难者不会的类型，难度不大，学习它们不会花费太多时间。而且这些小而美的算法经常让你大呼精妙，能够有效培养你对算法的兴趣。 2、学会基础算法之后，不要急着上来就刷回溯算法、动态规划这类笔试常考题，而应该先刷二叉树，先刷二叉树，先刷二叉树，重要的事情说三遍。 为什么要先刷二叉树呢，因为二叉树是最容易培养框架思维的，而且大部分算法技巧，本质上都是树的遍历问题。 刷二叉树看到题目没思路？根据很多读者的问题，其实大家不是没思路，只是没有理解我们说的「框架」是什么。 不要小看这几行破代码，几乎所有二叉树的题目都是一套这个框架就出来了： void traverse(TreeNode root) { // 前序位置 traverse(root.left); // 中序位置 traverse(root.right); // 后序位置 } 比如说我随便拿几道题的解法出来，不用管具体的代码逻辑，只要看看框架在其中是如何发挥作用的就行。 力扣第 124 题，难度困难，让你求二叉树中最大路径和，主要代码如下： 比如说我随便拿几道题的解法出来，不用管具体的代码逻辑，只要看看框架在其中是如何发挥作用的就行。 力扣第 124 题，难度困难，让你求二叉树中最大路径和，主要代码如下： int res = Integer.MIN_VALUE; int oneSideMax(TreeNode root) { if (root == null) return 0; int left = max(0, oneSideMax(root.left)); int right = max(0, oneSideMax(root.right)); // 后序位置 res = Math.max(res, left + right + root.val); return Math.max(left, right) + root.val; } 注意递归函数的位置，这就是个后序遍历嘛，无非就是把 traverse 函数名字改成 oneSideMax 了。 力扣第 105 题，难度中等，让你根据前序遍历和中序遍历的结果还原一棵二叉树，很经典的问题吧，主要代码如下： TreeNode build(int[] preorder, int preStart, int preEnd, int[] inorder, int inStart, int inEnd) { // 前序位置，寻找左右子树的索引 if (preStart \u003e preEnd) { return null; } int rootVal = preorder[preStart]; int index = 0; for (int i = inStart; i \u003c= inEnd; i++) { if (inorder[i] == rootVal) { index = i; break; } } int leftSize = index - inStart; TreeNode root = new TreeNode(rootVal); // 递归构造左右子树 root.left = build(preorder, preStart + 1, preStart + leftSize, inorder, inStart, index - 1); root.right = build(preorder, preStart + leftSize + 1, preEnd, inorder, index + 1, inEnd); return root; } 不要看这个函数的参数很多，只是为了控制数组索引而已。注意找递归函数 build 的位置，本质上该算法也就是一个前序遍历，因为它在前序遍历的位置加了一坨代码逻辑。 力扣第 230 题，难度中等，寻找二叉搜索树中的第 k 小的元素，主要代码如下： int res = 0; int rank = 0; void traverse(TreeNode root, int k) { if (root == null) { return; } traverse(root.left, k); /* 中序遍历代码位置 */ rank++; if (k == rank) { res = root.val; return; } /*****************/ traverse(root.right, k); } 这不就是个中序遍历嘛，对于一棵 BST 中序遍历意味着什么，应该不需要解释了吧。 你看，二叉树的题目不过如此，只要把框架写出来，然后往相应的位置加代码就行了，这不就是思路吗。 对于一个理解二叉树的人来说，刷一道二叉树的题目花不了多长时间。那么如果你对刷题无从下手或者有畏惧心理，不妨从二叉树下手，前 10 道也许有点难受；结合框架再做 20 道，也许你就有点自己的理解了；刷完整个专题，再去做什么回溯动规分治专题，你就会发现只要涉及递归的问题，都是树的问题。 综上，对于畏惧算法的同学来说，可以先刷树的相关题目，试着从框架上看问题，而不要纠结于细节问题。 纠结细节问题，就比如纠结 i 到底应该加到 n 还是加到 n - 1，这个数组的大小到底应该开 n 还是 n + 1？ 从框架上看问题，就是像我们这样基于框架进行抽取和扩展，既可以在看别人解法时快速理解核心逻辑，也有助于找到我们自己写解法时的思路方向。 当然，如果细节出错，你得不到正确的答案，但是只要有框架，你再错也错不到哪去，因为你的方向是对的。 但是，你要是心中没有框架，那么你根本无法解题，给了你答案，你也不会发现这就是个树的遍历问题。 这种思维是很重要的， 动态规划详解 中总结的找状态转移方程的几步流程，有时候按照流程写出解法，可能自己都不知道为啥是对的，反正它就是对了。。。 这就是框架的力量，能够保证你在快睡着的时候，依然能写出正确的程序；就算你啥都不会，都能比别人高一个级别。 本文最后，总结一下吧： 数据结构的基本存储方式就是链式和顺序两种，基本操作就是增删查改，遍历方式无非迭代和递归。 学完基本算法之后，建议从「二叉树」系列问题开始刷，结合框架思维，把树结构理解到位，然后再去看回溯、动规、分治等算法专题，对思路的理解就会更加深刻。 ","date":"2021-08-18","objectID":"/posts/tech/leetcode/algorithm/:3:0","tags":["算法","leetcode"],"title":"算法概述","uri":"/posts/tech/leetcode/algorithm/"},{"categories":["leetcode"],"content":"四、算法的本质 如果要让我一句话总结，我想说算法的本质就是「穷举」。 但是，你千万不要觉得穷举这个事儿很简单，穷举有两个关键难点：无遗漏、无冗余。 遗漏，会直接导致答案出错；冗余，会拖慢算法的运行速度。所以，当你看到一道算法题，可以从这两个维度去思考： 1、如何穷举？即无遗漏地穷举所有可能解。 2、如何聪明地穷举？即避免所有冗余的计算，消耗尽可能少的资源求出答案。 不同类型的题目，难点是不同的，有的题目难在「如何穷举」，有的题目难在「如何聪明地穷举」。 什么算法的难点在「如何穷举」呢？一般是递归类问题，最典型的就是动态规划系列问题。 ","date":"2021-08-18","objectID":"/posts/tech/leetcode/algorithm/:4:0","tags":["算法","leetcode"],"title":"算法概述","uri":"/posts/tech/leetcode/algorithm/"},{"categories":["leetcode"],"content":"Refer Refer to : https://labuladong.gitee.io/algo/2/ ","date":"2021-08-18","objectID":"/posts/tech/leetcode/algorithm/:5:0","tags":["算法","leetcode"],"title":"算法概述","uri":"/posts/tech/leetcode/algorithm/"},{"categories":["生活"],"content":" 2021.07.02-2021.07.05 ","date":"2021-07-13","objectID":"/posts/travel/wanning/:0:0","tags":["海南","万宁","三亚"],"title":"万宁Outing","uri":"/posts/travel/wanning/"},{"categories":["生活"],"content":"Day1 【周五】 周五下坐飞机飞海口，原计划14点的飞机，晚点到17点起飞； 20点左右到达海口，乘坐旅游大巴赶往万宁； 23点左右入到达万宁，入住神州半岛福朋喜来登酒店； 酒店在海边一个小岛的景区中，晚上人烟稀少，在周边找吃的有些费劲； ","date":"2021-07-13","objectID":"/posts/travel/wanning/:1:0","tags":["海南","万宁","三亚"],"title":"万宁Outing","uri":"/posts/travel/wanning/"},{"categories":["生活"],"content":"Day2【周六】 早起，自助餐早点，伙食还不错的； 酒店一日躺，下午海边泳池玩水； 酒店泳池 晚上附近找了个沙滩，玩篝火、吃烧烤、海边踩水； 万宁沙滩 万宁沙滩篝火 ","date":"2021-07-13","objectID":"/posts/travel/wanning/:2:0","tags":["海南","万宁","三亚"],"title":"万宁Outing","uri":"/posts/travel/wanning/"},{"categories":["生活"],"content":"Day3【周日】 坐高铁到三亚，开启三亚一日游模式； 三亚凤凰岛 鸿洲国际游艇码头 浪里个浪，耗资几百大元，体验了把人工潜水+水下拍照，体验效果：近海区水太脏了，照片效果令人堪忧，完美踩坑； 晚上搜了家大众点评top3的海鲜店，吃海鲜，口味很棒；吃完返程回万宁； ","date":"2021-07-13","objectID":"/posts/travel/wanning/:3:0","tags":["海南","万宁","三亚"],"title":"万宁Outing","uri":"/posts/travel/wanning/"},{"categories":["生活"],"content":"Day4【周一】 早起，先坐大巴到海口，然后回杭； ","date":"2021-07-13","objectID":"/posts/travel/wanning/:4:0","tags":["海南","万宁","三亚"],"title":"万宁Outing","uri":"/posts/travel/wanning/"},{"categories":["生活"],"content":"吴越古道➕浙西天池 吴越古道 队伍 生命的力量 微视角 ","date":"2021-05-03","objectID":"/posts/life/sport/zhexidaxiagu/:1:0","tags":["户外"],"title":"[户外]吴越古道➕浙西天池","uri":"/posts/life/sport/zhexidaxiagu/"},{"categories":["生活"],"content":"刷新徒步新记录 20.76km，刷新单日徒步记录； ","date":"2021-05-03","objectID":"/posts/life/sport/zhexidaxiagu/:2:0","tags":["户外"],"title":"[户外]吴越古道➕浙西天池","uri":"/posts/life/sport/zhexidaxiagu/"},{"categories":["生活"],"content":"开跑 第一次报名参加越野跑，也就是传说中的跑山、跑土路，听上去就蛮刺激的； 起点-开跑 ","date":"2021-04-24","objectID":"/posts/life/sport/westlake2021/:1:0","tags":["马拉松","户外"],"title":"[户外]西湖群山-10km越野赛","uri":"/posts/life/sport/westlake2021/"},{"categories":["生活"],"content":"一路风景 真的跑山哈，没路的话，就硬踩出路。 山里找路 左右边都是茶田，空气蛮好； 总行程10.3km，总耗时98分钟，两步路记录比较准确。 记录 ","date":"2021-04-24","objectID":"/posts/life/sport/westlake2021/:2:0","tags":["马拉松","户外"],"title":"[户外]西湖群山-10km越野赛","uri":"/posts/life/sport/westlake2021/"},{"categories":["生活"],"content":"获奖 首次参加越野跑，在崎岖的山路上，做到团队领头羊，冲在最前面，同时鼓励team成员，咬紧牙关，向前冲😀😀！ 最终5人小组赛10km越野跑，取得团队组第一的好成绩！🏆 奖品是人手500g 西湖明前龙井茶叶，不错不错； 战绩 ","date":"2021-04-24","objectID":"/posts/life/sport/westlake2021/:3:0","tags":["马拉松","户外"],"title":"[户外]西湖群山-10km越野赛","uri":"/posts/life/sport/westlake2021/"},{"categories":["Tech"],"content":"常用三个框架 Caffeine, GuavaCache, EhCache ","date":"2020-11-01","objectID":"/posts/tech/java/cache/:0:0","tags":["cache"],"title":"缓存框架总结","uri":"/posts/tech/java/cache/"},{"categories":["Tech"],"content":"前言 在大部分互联网架构中 Cache 己经成为了必可不少的一环- 常用的方案有大家熟知的 NoSQL数据库 (Redis、Memcached) 等,也有大量的进程内缓存 Caffeine、EhCache、Guava Cache等. ","date":"2020-11-01","objectID":"/posts/tech/java/cache/:1:0","tags":["cache"],"title":"缓存框架总结","uri":"/posts/tech/java/cache/"},{"categories":["Tech"],"content":"缓存框架介绍 ","date":"2020-11-01","objectID":"/posts/tech/java/cache/:2:0","tags":["cache"],"title":"缓存框架总结","uri":"/posts/tech/java/cache/"},{"categories":["Tech"],"content":"1.Caffeine Caffeine是一个基于Java8开发的提供了近乎最佳命中率的高性能的缓存库， 缓存和ConcurrentMap有点相似，但还是有所区别- 最根本的区别是ConcurrentMap将会持有所有加入到缓存当中的元素， 直到它们被从缓存当中手动移除- 但是，Caffeine的缓存Cache 通常会被配置成自动驱逐缓存中元素，以限制其内存占用- 在某些场景下，LoadingCache 和AsyncLoadingCache 因为其自动加载缓存的能力将会变得非常实用，Spring5 开始不再支持 Guava Cache, 改用Caffeine. ","date":"2020-11-01","objectID":"/posts/tech/java/cache/:2:1","tags":["cache"],"title":"缓存框架总结","uri":"/posts/tech/java/cache/"},{"categories":["Tech"],"content":"2.EhCache EhCache 是一个用Java实现的使用简单，高速，实现线程安全的缓存管理类库，而且从12之后就支持了集群 ehcache提供 了用内存，磁盘文件存储，以及分布式存储方式等多种灵活的cache管理方案- 同时ehcache作为开放源代码项目，采用限 制比较宽松的Apache License V2.0作为授权方式，被广泛地用于Hibernate, Spring， Cocoon等其他开源系统- ","date":"2020-11-01","objectID":"/posts/tech/java/cache/:2:2","tags":["cache"],"title":"缓存框架总结","uri":"/posts/tech/java/cache/"},{"categories":["Tech"],"content":"3.GuavaCache guava cache是google开源的一款本地缓存工具库，它的设计灵感来源于ConcurrentHashMap， 使用多个segments方式的 细粒度锁，在保证线程安全的同时，支持高并发场景需求，同时支持多种类型的緩存清理策略，包括基于容量的清理、基于 时间的清理、基于引用的清理等- ","date":"2020-11-01","objectID":"/posts/tech/java/cache/:2:3","tags":["cache"],"title":"缓存框架总结","uri":"/posts/tech/java/cache/"},{"categories":["Tech"],"content":"缓存框架主要特性 ","date":"2020-11-01","objectID":"/posts/tech/java/cache/:3:0","tags":["cache"],"title":"缓存框架总结","uri":"/posts/tech/java/cache/"},{"categories":["Tech"],"content":"1.Caffeine Caffeine提供了灵活的构造器去创建一个拥有下列特性的缓存： 自动加载元素到缓存当中，异步加载的方式也可供选择 当达到最大容量的时候可以使用基于就近度和频率的算法进行基于容量的驱逐 将根据缓存中的元素上一次访问或者被修改的时间进行基于过期时间的驱逐 当向缓存中一个已经过时的元素进行访问的时候将会进行异步刷新 key将自动被弱引用所封装 value将自动被弱引用或者软引用所封装 驱逐(或移除)缓存中的元素时将会进行通知 写入传播到一个外部数据源当中 持续计算缓存的访问统计指标 为了提高集成度，扩展模块提供了JSR-107 JCache 和Guava适配器- JSR-107规范了基于Java 6的API，在牺牲了功 能和性能的代价下使代码更加规范- Guava的Cache是Caffeine的原型库并且Caffeine提供了适配器以供简单的迁移策略 ","date":"2020-11-01","objectID":"/posts/tech/java/cache/:3:1","tags":["cache"],"title":"缓存框架总结","uri":"/posts/tech/java/cache/"},{"categories":["Tech"],"content":"2.EhCache 快速，针对大型高并发系统场景，Ehcache的多线程机制有相应的优化改善 简单，很小的jar包，简单配置就可直接使用，单机场景下无需过多的其他服务依赖 支持多种的缓存策略，灵活 缓存数据有两级：内存和磁盘，与一般的本地内存缓存相比，有了磁盘的存储空间，将可以支持更大量的数据缓存需求 具有缓存和缓存管理器的监听接口，能更简单方便的进行缓存实例的监控管理 支持多缓存管理器实例，以及一个实例的多个缓存区域 Ehcache的超时设置主要是针对整个cache实例设置整体的超时策略，而没有较好的处理针对单独的key的个性的超时设置 因此，在使用中要注意过期失效的缓存元素无法被GC回收，时间越长缓存越多，内存占用也就越大，内存泄露的概率也越大 ","date":"2020-11-01","objectID":"/posts/tech/java/cache/:3:2","tags":["cache"],"title":"缓存框架总结","uri":"/posts/tech/java/cache/"},{"categories":["Tech"],"content":"3.GuavaCache Guava Cache的架构设计灵感ConcurrentHashMap，在简单场景中可以通过HashMap实现简单数据缓存，但如果要 实现缓存随时间改变、存储的数据空间可控则缓存工具还是很有必要的- cache存储的是键值对的集合，不同时是还 需要处理缓存过期、动态加载等算法逻辑，需要额外信息实现这些操作，对此根据面向对象的思想，还需要做方法与 数据的关联性封装，主要实现的缓存功能有：自动将节点加载至缓存结构中，当緩存的数据超过最大值时，使用LRU 算法替换；它具备根据节点上一次被访问或写入时间计算缓存过期机制，缓存的key被封装在WeakReference引用 中，缓存的value被封装在 WeakReference 或 SoftReference 引用中; 还可以统计缓存使用过程中的命中率、异常率和命中率等统计数据. ","date":"2020-11-01","objectID":"/posts/tech/java/cache/:3:3","tags":["cache"],"title":"缓存框架总结","uri":"/posts/tech/java/cache/"},{"categories":["Tech"],"content":"缓存框架原理 ","date":"2020-11-01","objectID":"/posts/tech/java/cache/:4:0","tags":["cache"],"title":"缓存框架总结","uri":"/posts/tech/java/cache/"},{"categories":["Tech"],"content":"1.Caffeine 主要原理 1.1淘汰算法 1.1.1常见算法 对于 Java 进程内缓存我们可以通过 HashMap 来实现。不过，Java 进程内存是有限的，不可能无限地往里面放缓存对象。 这就需要有合适的算法辅助我们淘汰掉使用价值相对不高的对象，为新进的对象留有空间。常见的缓存淘汰算法有 FIFO、LRU、LFU. FIFO(First In First Out): 先进先出 它是优先淘汰掉最先缓存的数据、是最简单的淘汰算法。缺点是如果先缓存的数据使用频率比较高的话，那么该数据就不停 地进进出出，因此它的缓存命中率比较低。 LRU(Least Recently Used): RRA. 它是优先淘汰掉最久未访问到的数据。缺点是不能很好地应对偶然的突发流量。比如一个数据在一分钟内的前59秒访问很多 次，而在最后1秒没有访问，但是有一批冷门数据在最后一秒进入缓存，那么热点数据就会被冲刷掉。 LFU(Least Frequently Used) : 最近最少频率使用。它是优先淘汰掉最不经常使用的数据，需要维护一个表示使用频率的字段。 主要有两个缺点： 如果访问频率比较高的话，频率宇段会占据一定的空间； 无法合理更新新上的热点数据，比如某个歌手的老歌播放历史较三，新出的歌如果和老歌一起排序的话，就永无出头之日; 1.1.2 W-TinyLFU 算法 Caffeine 使用了 W-TinyLFU 算法，解决了 LRU 和 LFU 上述的缺点，它主要干了两件事： 采用 Count-Min Sketch 算法降低频率信息带来的内存消耗； 维护一个PK机制保障新上的热点数据能够缓存。 如下图所示，Count-Min Sketch 算法类似布隆过滤器(Bloom fiter)思想，对子频率统计我们其实不需要一个精确值。存储 数据时，对key进行多次 hash 函数运算后，二维数组不同位置存储频率（Caffeine 实际实现的时候是用一维long 型数组， 每个long 型数字切分成16份，每份4bit，默认15次为最高访问频率，每个key实际 hash 了四次，落在不同 long 型数宇的16 份中某个位置）。读取某个key的访问次数时，会比较所有位置上的频率值，取最小值返口。对于所有key的访问频率之和有 个最大值，当达到最大值时，会进行reset即对各个缓存key的场率除以2。 Count-Min Sketch 如下图缓存访问频率存储主要分为两大部分，即 LRU 和 Segmented LRU。 新访问的数据会进入第一个 LRU，在 Caffeine 里叫 WindowDeque. 当WindowDeque满时, 会进入Segmented LRU 中的 ProbationDeque, 在后续被访问到时，它会 被提升到 ProtectedDeque。当 ProtectedDeque 满时，会有数据降级到 ProbationDeque。数据需要淘汰的时候，对 probationDeque 中的数据进行淘汰。具体淘汰机制：取ProbationDeque 中的队首和队尾进行 PK，队首数据是最先进入队 列的，称为受害者，队尾的数据称为攻击者，比较两者 频率大小，大胜小汰 ","date":"2020-11-01","objectID":"/posts/tech/java/cache/:4:1","tags":["cache"],"title":"缓存框架总结","uri":"/posts/tech/java/cache/"},{"categories":["Tech"],"content":"2.EnCache 主要原理 略 ","date":"2020-11-01","objectID":"/posts/tech/java/cache/:4:2","tags":["cache"],"title":"缓存框架总结","uri":"/posts/tech/java/cache/"},{"categories":["Tech"],"content":"3.GuavaCache主要原理 Guava Cache实质是一个在本地缓存KV数据的LocalCache。而LocalCache的数据结构和ConcurrentHashMap一样， 都采用分 segment 来细化管理HashMap中的节点Entry。不同的是LocalCache 中的 ReferenceEntry节点更为复杂。 数据结构简图大致如下： 图? 另外视缓存是否需要使用特别的引用策略(非Strong引用).以及设置的超时过期策路不同 (expireAfterAccess, expire AfterWrite）每个Segment中会维护最多以下5个队列： keyReferenceQueue： 存储了即将被GC回收的缓存数据K引1用列表 （当缓存设置了非强引用策略时该队列生效) valueReferenceQueue：存储了即将被GC回收的缓存数据Value弓1用列表（当缓存设置了非强引用策略时该队列生效） recencyQueue ： 存储最近访问的Entry列表，为了提升访问性能使用的辅助队列。 accessQueue：存储了基于最近访问时间排序的segment中所有ReferenceEntry的一个双向链表(当选择基于访问时间失效策略的时候用到该队列) WriteQueve： 存储了基于最近写入时间排序的segment中所有Entry的一个双向链表(当选择基于写入时问失效策略的时候用到该队列） 此外segment中还维护了2个变量count(记录当前segment中节点数量)，modcount (记录当 前segment变更次数） ","date":"2020-11-01","objectID":"/posts/tech/java/cache/:4:3","tags":["cache"],"title":"缓存框架总结","uri":"/posts/tech/java/cache/"},{"categories":["Tech"],"content":"缓存基本用法 code 某他高级用法用法汇总: 通过异步自动加载实体到缓存中 基于大小的回收策略 基于时间的回收策略 自动刷新 key自动封装虚引用 value自动封装弱引用或软引1用 实体过期或被删除的通知 写入外部资源 统计累计访问缓存 加载策略 手动加载 同步加载 异步加载 回收策略 Caffeine提供了 3种回收策略：基于大小回收，基于时间回收，基手号用回收 统计缓存使用情况 通过使用Caffeine.recordStats… ","date":"2020-11-01","objectID":"/posts/tech/java/cache/:5:0","tags":["cache"],"title":"缓存框架总结","uri":"/posts/tech/java/cache/"},{"categories":["Tech"],"content":"总结 个人推荐使用 Caffeine 算法W-TinyLFU算法它的命中率非常高，内存小，异步化，不阻塞。 无论是读写,Caffeine性能都比 Guava要好。 Caffeine基于java8的高性能，接近最优的缓存库。 Caffeine提供的内存缓存使用参考 Google guava的API。 Caffeine 是基于 Google guava 和 ConcurrentLinkedHashMap的设计经验上改进的成果。 • Caffeine 是Spring 5 默认支持的cache，可见Spring对它的看中，Spring抛弃Guava 转向了 Caffeine. ","date":"2020-11-01","objectID":"/posts/tech/java/cache/:6:0","tags":["cache"],"title":"缓存框架总结","uri":"/posts/tech/java/cache/"},{"categories":["Tech"],"content":"思维导图 ","date":"2020-05-29","objectID":"/posts/tech/tools/tools-paint/:0:0","tags":["作图（paint）"],"title":"常用作图工具(工作\u0026\u0026生活)","uri":"/posts/tech/tools/tools-paint/"},{"categories":["Tech"],"content":"xmind UML ","date":"2020-05-29","objectID":"/posts/tech/tools/tools-paint/:1:0","tags":["作图（paint）"],"title":"常用作图工具(工作\u0026\u0026生活)","uri":"/posts/tech/tools/tools-paint/"},{"categories":["Tech"],"content":"plantUML Official website demo ","date":"2020-05-29","objectID":"/posts/tech/tools/tools-paint/:2:0","tags":["作图（paint）"],"title":"常用作图工具(工作\u0026\u0026生活)","uri":"/posts/tech/tools/tools-paint/"},{"categories":["Tech"],"content":"IDEA plant plugins idea plugin 流程图 ","date":"2020-05-29","objectID":"/posts/tech/tools/tools-paint/:3:0","tags":["作图（paint）"],"title":"常用作图工具(工作\u0026\u0026生活)","uri":"/posts/tech/tools/tools-paint/"},{"categories":["Tech"],"content":"Omni全家桶 OmniGraffle Mac平台的流程图绘制软件，相当于windows平台的visio OmniPlan 工期规划甘特图的工具 ","date":"2020-05-29","objectID":"/posts/tech/tools/tools-paint/:4:0","tags":["作图（paint）"],"title":"常用作图工具(工作\u0026\u0026生活)","uri":"/posts/tech/tools/tools-paint/"},{"categories":["Tech"],"content":"Gliffy diagrams ","date":"2020-05-29","objectID":"/posts/tech/tools/tools-paint/:5:0","tags":["作图（paint）"],"title":"常用作图工具(工作\u0026\u0026生活)","uri":"/posts/tech/tools/tools-paint/"},{"categories":["读书笔记"],"content":"整本书用口语在和读者交流，没有太多理论抽象，案例非常多，读起来相对轻松，如果有丰富的管理经验，甚至看目录即可。 ","date":"2020-05-02","objectID":"/posts/book/duplicateleader/:0:0","tags":["读书笔记"],"title":"[读书笔记]可复制的领导力：樊登的9堂上商业课程","uri":"/posts/book/duplicateleader/"},{"categories":["读书笔记"],"content":"第1章 80%的管理者能达到 80分 作者通过孔子和柏拉因教学方式的差异，总结了一个很有意思的观点：西方更强调逻得思维，讨论事物给出的答案非常的具象，而且习惯标准化；东方更强调综合思维，关注宏观问题，讨论内容非常抽象，很难标准化 在解决问题思维上，东方人依赖个人能力，而西方注重标准化，按照标准操作，一切任务都可 以完成。在管理学习上也应该标准化，普通人通过训练可以轻松拥有领导力 建立信任 建立团队 建工体系 建立文化 四个步骤很通俗易懂，在建立体系环节作者用麦当劳举例，麦当劳最核心 竞争力是其标准化，全世界麦当劳都可以高效、口味一致的提供服务给客户 ","date":"2020-05-02","objectID":"/posts/book/duplicateleader/:1:0","tags":["读书笔记"],"title":"[读书笔记]可复制的领导力：樊登的9堂上商业课程","uri":"/posts/book/duplicateleader/"},{"categories":["读书笔记"],"content":"第2章 明确角色定位，避免亲力亲为 这个道理很简单，但却是大部分新管理者角色未转换前最容易出现的问题 用球队来打个比方：就好比你是前锋，觉得后防不力，就老帮后卫防守，觉得中场组织很差．就老帮中场组织拿 球。当球队需要破门得分、往前传球的时候，却找不到你这个正印前锋的影子，那球队还能赢得了球吗？ 想要让团队获得持续健康的发展，必须激发团队各成员的潜能。在这个过程中不可避免会犯错，不犯错就不会发现自己各方面存在的缺陷。如果无法获得成长的空间和机会，也就没有意愿去承担厲开自己的责任、独当一面 团队管理者在培养人才的过程中，最大的挑战就是要眼睁睁地看着员工去犯错，要给员工试错的空间，培养属于员工的责任感，让他感觉这件事跟他自己是有关的，是需要他自己想办法解决的。 ","date":"2020-05-02","objectID":"/posts/book/duplicateleader/:2:0","tags":["读书笔记"],"title":"[读书笔记]可复制的领导力：樊登的9堂上商业课程","uri":"/posts/book/duplicateleader/"},{"categories":["读书笔记"],"content":"第3章 构建游戏化组织，让工作变的更有趣 这章的标题其实有些容易让人误解，作者想表达的是团队愿景的重要性，书中拿游戏举了例子：超级玛丽最终是为了营救公主、魔兽世界是为了带领阵营成长，甚至在线下欢呼庆祝全球同时在线人数突破4000万，共杀死20亿外星人- 团队所有同学要明白这个团队的终极目标是什么，我们为什么而努力 《硅谷钢铁侠 埃隆•马斯克的冒险人生》也提到过类似的观点，Spacex Tesla. solarCity 的所有员工都清楚公司的终极梦想是让人类变成跨行星物种，而且大概率在这一代人手中无法实现。但这不影响所有员工务实的在新能源、宇宙探索领域积极进取，更不影响公司盈利，顺便让马斯克做了 首富 ","date":"2020-05-02","objectID":"/posts/book/duplicateleader/:3:0","tags":["读书笔记"],"title":"[读书笔记]可复制的领导力：樊登的9堂上商业课程","uri":"/posts/book/duplicateleader/"},{"categories":["读书笔记"],"content":"第4章 理清关系，打造团队一致性 不要把团队比喻成家，因为家庭成员永远不会互相放弃，团队做不到这一点 团队就是球队，目标是赢球 通过建立共同目标、适当授权，让团队的事情成为员工自己想做的事情 ","date":"2020-05-02","objectID":"/posts/book/duplicateleader/:4:0","tags":["读书笔记"],"title":"[读书笔记]可复制的领导力：樊登的9堂上商业课程","uri":"/posts/book/duplicateleader/"},{"categories":["读书笔记"],"content":"第5章 用目标管人，而不是人管人 目标管理有四大难题，作者没有很理论性的给出答案，但识别到问题后，去找方案总归是个相对简单的事情 成员参与度不够，执行积极性不高：让每个成员都参与进来 资源匮乏：我们身边到处都有资源，只要有足够的创意，就可以收获意想不到的惊喜 目标拆分不合理：管理者需要根据实际情况进行具体评估，再做出合理的规划 目标总在变化：理解企业决定、提前准备预案 目标管理领域有一个非常著名的SMART法则 S Specific（明确具体） M Measurable（可量化） A Attainable（可接受、可实现） R Realistic（相关性、符合实际） T Time-limited（有时间限制） 为团队成员设置了合理的目标，并不意味着目标管理的完成，作者给了—个工具 利用目标书写公式、写出目标 列出阻碍目标实现的因素 列出可以帮助目标实现的条件 写下个人特征 列出要做的事情 ","date":"2020-05-02","objectID":"/posts/book/duplicateleader/:5:0","tags":["读书笔记"],"title":"[读书笔记]可复制的领导力：樊登的9堂上商业课程","uri":"/posts/book/duplicateleader/"},{"categories":["读书笔记"],"content":"第6章 利用沟通视窗，改善人际沟通 沟通视窗，也称乔哈里视窗，是一种关于沟通的技巧和理论，也被称为“自我意识的发现一反馈模型”。有效沟通就是这四个象限的有机融合。 隐私象限：正面沟通，避免误解 盲点象限：利用反馈看到自身局限 潜能象限：不要轻视每一名员工的潜能 公开象限：让员工尊重你，而不是怕你 ","date":"2020-05-02","objectID":"/posts/book/duplicateleader/:6:0","tags":["读书笔记"],"title":"[读书笔记]可复制的领导力：樊登的9堂上商业课程","uri":"/posts/book/duplicateleader/"},{"categories":["读书笔记"],"content":"第7章 学会倾听，创建良性的交流通道 倾听并不是不打断别人说话就可以，要点是吸收对方的信息，通过三个步骤可以做到 深呼吸：保证自己情绪稳定 提问：通过实时反馈，让对方感受到你的投入度 复述：确保信息有效性 书里面关于提问讲了两种问题模式：封闭性问题、开放性问题 开放性问题需要对方针对有关事情做进一步的描述，并把回答者的注意力转向所描述事情中比较具体的某个方面，开放性问题没有标准答案。管理者在团队沟通是应该尽量使用这种方式提问 封闭性问题是指那些只能用“是”或“不是”等具体答案来进行解答的问题，这种提问方式在销售层面有着较为广泛的应用，为的是不给客户考虑的空间，只要回答“是”或“不是”就好，造成一种心理催眠效果，“， YES成交法”是其典型代表。在和团队交流时候如果这么搞，出的问题就可想而知了 很有意思的是传销很爱用这种套路，比如一个标价3000元的洗脸盆，正常人大多不会购买，但这在传销组织中很 容易成交，话术大概这样进行 传销者：“朋友们，在外打拼这么多年，大家觉不觉得健康是一件非常重要的事情？是不是？” 观众：“是” 传销者：“那父母的健康是不是很重要？” 观众：“是” 传销者：“大家是不是感觉我们每天忙子事业，对父母的关心不够？” 观众：“是.” 传销者：“如果我们可以花一顿饭的钱，给父母带来健康和快乐．是不是一籍很划算的投资？” 观众：“是” 传销者：“如果我们可以花一顿饭的钱，给父母带来健康和快乐，是不是一笔很划算的投资？” 观众： “是” 传销者：“人老脚先老，洗脚可以使父母身体更加健康，更加长寿，是不是只要一顿饭的钱就可以实现，帮你完成孝心？” 观众 “是” 接下来，传销者还会设置很多需要观众回答“是”的问题，不光要回答“是”，还要观众点头表示认同。这是一种群体性的催眠方式，只要周围有两千人不断地点头说是，在连着说6次yes 后，传销者的第7个问题将会是“你是否 愿意购买？“此时肯定有人习惯性地说“yes”，3000元一个的脸盆就这样成交了。 〝7YES成交法”带来的销售额非常惊人。量然这种做法有违社会道德，但其中蕴含的原理却耐人寻味。 管理者在倾听时，经常会碰到对方情绪失控的情况，这时候简单安慰作用甚微，要学会用认同化解对方的失控情绪 如果我们面对对方的失控，只是重复地说“令静点”“理智点〞，而根本不照顾对方的情绪，那么对方的情绪就会越来越坏。更有效的处理方式应该是“反映情绪”，反映情绪是指在对方情绪出现波动的时候，通过一系列的询问让对方认识到自身的情绪状态 比如，管理者可以问员工“这件事让你很心烦，对吗？，这件事让你很难过，对吗？”“这件事让你很悲伤，对吗？“等类似的问题，实际上就是前文所说的封闭性问题，只需要让对方回答“是”或者“否”。管理者在面对情绪失 控的人时，最好的办法就是千方百计让对方说“是”。只要他说了“是”，情绪就会缓和，因为他从这个回答中找到了认同。 所以.一切所谓“艰难”的谈话，最难过的往往是第一关，即认同对方的情绪。过不了这一关，其他的沟通技巧都没办法起作用。核心是处理好情绪问题。 ","date":"2020-05-02","objectID":"/posts/book/duplicateleader/:7:0","tags":["读书笔记"],"title":"[读书笔记]可复制的领导力：樊登的9堂上商业课程","uri":"/posts/book/duplicateleader/"},{"categories":["读书笔记"],"content":"第8章 及时反馈，让员工敬重你、信任你 别用绩效考核代替反馈 警惕“推理阶梯”（想当然），避免误解和伤害 正面反馈要及时、准确 负面反馈对事不对人 觉得负面反馈很棘手时候，可以用三明治反馈 表扬员工平时、工作做得不错 指出员工现阶段、工作中存在的问题 告诉员工改进之、后会达到的成就 但也要警惕三明治反馈的陷阱，员工会有选择地接受那些表扬性的词汇，而将真正需要反思的问题拋诸脑后。更有甚者，由于管理者批评的语言婉转晦涩，员工甚至都不知道这是负面反馈。 当然更要避免另类的三明治反馈，前段时间看脱口秀，李雪琴也提到了领导拙劣的技巧 老板： 雪琴你今天挺好看的； 你看你那稿子写的什么破玩意，一天天寻思啥呢，带没带脑子来； 你这衣服也挺好看的 李雪琴：也说不上来老板这个三明治有什么不同，但就感觉薄皮大馅的呢？ 人在自信时才会勇于承担属于自己的责任，不自信时，就会觉得周围的人都在针对他，从而不愿意承认自己的过失，拒绝承担相关责任。 在大量工作中优先看到别人的缺点，是很多管理者的通病。这是我们的本能。优秀的企业管理者，必须尽力压制这 种本能，善于发现员工身上闪光的地方，表扬和强化它，员工会在不断的积极反馈中，明确自己的工作方向，更有勇气和力量承担责任。 ","date":"2020-05-02","objectID":"/posts/book/duplicateleader/:8:0","tags":["读书笔记"],"title":"[读书笔记]可复制的领导力：樊登的9堂上商业课程","uri":"/posts/book/duplicateleader/"},{"categories":["读书笔记"],"content":"第9章 有效利用时间，拒绝无效努力 这章作者主要介绍了如何做好一次头脑风暴和六顶思考帽的使用 头脑风暴最重要的就是对于意见不批评、不否定、不深入讨论 团队中有人提出了一个意见，另一个人开始针锋相对，探讨这个意见为什么不合适，然后这两人就开始顺着这个 意见的方向走下去了。这样整个会议的方向就开始出现偏差，整个会场只能听见二人的声音，火药味越来越浓。 其他的与会者心里会想，在这种场合提出白己的意见要冒着被批评、被指责的风险，不如将意见埋在心里。如果 反驳的人是管理者，其他人则更不敢发表不同意见，生怕被管理者当场驳斥。如此一来，自然无法收集到足够的 意见和信息，也会极大地降低团队的会议效率。 白帽 （中立、客观） 绿帽 （创意、巧思） 黄帽 （积极、正面) 红帽 （直觉、情感） 黑帽 （谨慎、负面） 蓝帽 （中立、客观） 六顶思考帽在很多场合听说过，作者举了个很贴切的例子，开高端牛肉拉面馆的几个合伙人，想出了一个营销创意：在一个月内，每天送出100份牛肉面给那些吃不起面的人。这种方案为拉面馆增添了慈善的噱头，通过微信转 发、媒体报道，很快就会吸引很多顾客。 我戴上蓝色思考帽，然后让他们依次戴上了红色思考帽和白色思考帽。一些事实．数据以及直觉思维都在友好的气氛中交流着。 会议很快就进入了黑色思考帽的环节，在戴上黑色思考帽之后，大家一开始都不发言。 于是我就规定所有与会成员每个人一定要想到至少一条负面因素。 过了一会儿，有个人说：“100碗面对后厨的压力可不小，如果赶上高峰期，很有可能影响其他顾客的就餐时间。 有一自然有二，第二个人很快也站了起来，说;“要是来了一群乞丐怎么办？这会严重影响门店的形象。 \"第三个声音响起：“如果每天来的都是同样的100个人该如何是好？这样根本起不到宣传的效果。 还有一个人说：“不要小看100碗面，这个成本也不少，店铺前期送面肯定是赔本赚吆喝，不知道能坚持多久。 如果我们每天给大家发面，突然有一天不发了，会不会引起大家的不满？这对店铺的名誉也不利。 听到大家提出的种种问题，出主意的人说自己确实没有思考周全，打算放弃。我笑着对他摇摇手，让所有人都带 上绿色思考帽，想一下这些问题的解决办法。 第一个人说：“我们可以在早上10点到11点之间发放这100碗面，这样就不会跟中午的高峰期冲突。 第二个人说：“我们可以不在店里宣传，改在互联网和微信上宣传，这样乞丐就不会来了。 第三个人说：“我们还可以学习国外的“墙上咖啡，做墙上拉面”。” （“墙上咖啡*的流程是： 一个人可以买两杯咖啡，其中一杯自己喝，另一杯挂在墙上。如果店里进来一个想喝咖啡却没带钱的人，就可以喝到别人买的咖啡 了。“墙上拉面”的方式与之类似，就是将其他人买好的拉面挂在墙上，供没钱的人享用，减少店里的经营成本。） 在群策群力下，团队拿出了最终的决策方案：慈善拉面的发放时间定为上午10点到11点，发放渠道是互联网和微 信，发送方式为“墙上拉面” ","date":"2020-05-02","objectID":"/posts/book/duplicateleader/:9:0","tags":["读书笔记"],"title":"[读书笔记]可复制的领导力：樊登的9堂上商业课程","uri":"/posts/book/duplicateleader/"},{"categories":["Tech"],"content":" Chart github: Python3 chart ","date":"2019-12-05","objectID":"/posts/tech/python/python3/:0:0","tags":["python"],"title":"python3","uri":"/posts/tech/python/python3/"},{"categories":["tech"],"content":"概要 Arthas 是一款线上(运行时)监控诊断产品，通过全局视角实时查看应用 load、内存、gc、线程的状态信息，并能在不修改应用代码的情况下，对业务问题进行诊断，包括查看方法调用的出入参、异常，监测方法执行耗时，类加载信息等，大大提升线上问题排查效率。 arthas官网 ","date":"2019-10-05","objectID":"/posts/tech/tools/arthas/:1:0","tags":["arthas"],"title":"Arthas(阿尔萨斯)","uri":"/posts/tech/tools/arthas/"},{"categories":["tech"],"content":"Arthas（阿尔萨斯）能为你做什么？ Arthas 是 Alibaba 开源的 Java 诊断工具，深受开发者喜爱。 当你遇到以下类似问题而束手无策时，Arthas可以帮助你解决： 这个类从哪个 jar 包加载的？为什么会报各种类相关的 Exception？ 我改的代码为什么没有执行到？难道是我没 commit？分支搞错了？ 遇到问题无法在线上 debug，难道只能通过加日志再重新发布吗？ 线上遇到某个用户的数据处理有问题，但线上同样无法 debug，线下无法重现！ 是否有一个全局视角来查看系统的运行状况？ 有什么办法可以监控到 JVM 的实时运行状态？ 怎么快速定位应用的热点，生成火焰图？ 怎样直接从 JVM 内查找某个类的实例？ Arthas 支持 JDK 6+，支持 Linux/Mac/Windows，采用命令行交互模式，同时提供丰富的 Tab 自动补全功能，进一步方便进行问题的定位和诊断。 ","date":"2019-10-05","objectID":"/posts/tech/tools/arthas/:1:1","tags":["arthas"],"title":"Arthas(阿尔萨斯)","uri":"/posts/tech/tools/arthas/"},{"categories":["tech"],"content":"一键安装 curl -L https://arthas.aliyun.com/install.sh | sh ","date":"2019-10-05","objectID":"/posts/tech/tools/arthas/:1:2","tags":["arthas"],"title":"Arthas(阿尔萨斯)","uri":"/posts/tech/tools/arthas/"},{"categories":["tech"],"content":"Arthas原理 如此强大的工具，究竟是如何做到的呢? 它通过 Instrument 机制和ASM字节码框架，干涉类的加载过程，动态注入字节码，搜集接口调用信息并反馈。 在JDK5之后提供的新特性JavaAgent(Java代理）, java.lang.instrument包支持以Java代理的形式监控或重新定义运行中的服务．可以让我们在不修改程序代码的前提下通过 Instrumentation API改变运行中的java程序. Instrumentation 是一个JVM接口，该接口提供了一组查看和操作Java类的方法，如修改类的字节码、向 classLoader 的classpath下加入jar文件等。开发者可以通过Java语言来操作和监控JVM内部的状态，进而实现Java程序的监控分析。 如Arthas的watch命令就是使用了 java.lang.instrument.Instrumentation#addTransformer(java.lang.instrument.ClassFileTransformer)来 动态增加字节码文件。 public interface Instrumentation{ } 在动态修改字节码文件中，用到了ASM框架，ASM是一个通用的Java字节码操作和分析框架。一般用来动态生成类或者增强既有类的功能。也就是既可以创建class文件，也可以修改class文件。 Arthas增强功能的核心是Enhancer和AdviceWeaver这两个类，对方法进行AOP织入，达到watch，trace等效果。 ","date":"2019-10-05","objectID":"/posts/tech/tools/arthas/:2:0","tags":["arthas"],"title":"Arthas(阿尔萨斯)","uri":"/posts/tech/tools/arthas/"},{"categories":["tech"],"content":"特性 ","date":"2019-10-05","objectID":"/posts/tech/tools/arthas/:3:0","tags":["arthas"],"title":"Arthas(阿尔萨斯)","uri":"/posts/tech/tools/arthas/"},{"categories":["tech"],"content":"后台异步任务，任务输出重定向 可通过 \u003e 或者 \u003e\u003e 将任务输出结果输出到指定的文件中，可以和\u0026一起使用，实现 arthas 命令的后台异步任务。 trace Test t » /Users/michael/tmp_del/test.out \u0026 ","date":"2019-10-05","objectID":"/posts/tech/tools/arthas/:3:1","tags":["arthas"],"title":"Arthas(阿尔萨斯)","uri":"/posts/tech/tools/arthas/"},{"categories":["tech"],"content":"批处理功能 通过批处理功能，arthas 支持一次性批量运行多个命令，并取得命令执行的结果。 ","date":"2019-10-05","objectID":"/posts/tech/tools/arthas/:3:2","tags":["arthas"],"title":"Arthas(阿尔萨斯)","uri":"/posts/tech/tools/arthas/"},{"categories":["tech"],"content":"常用命令 命令列表 ","date":"2019-10-05","objectID":"/posts/tech/tools/arthas/:4:0","tags":["arthas"],"title":"Arthas(阿尔萨斯)","uri":"/posts/tech/tools/arthas/"},{"categories":["tech"],"content":"线程查看 当没有参数时，显示第一页线程的信息 thread 支持一键展示当前最忙的前 N 个线程并打印堆栈： thread -n 3 thread id，显示指定线程的运行堆栈 thread 1 找出当前阻塞其他线程的线程 有时候我们发现应用卡住了，通常是由于某个线程拿佳了某个锁， 并且其他线程都在等待这把锁造成的。 为了排查这类问题，arthas 提供 thread -b 一键找出那个 罪魁祸首。 thread -b 查看指定状态的线程 thread –state WAITING ","date":"2019-10-05","objectID":"/posts/tech/tools/arthas/:4:1","tags":["arthas"],"title":"Arthas(阿尔萨斯)","uri":"/posts/tech/tools/arthas/"},{"categories":["tech"],"content":"watch（函数执行数据观测） 查看日志 $ watch demo.MathGame primeFactors -x 2 Press Q or Ctrl+C to abort. Affect(class count: 1 , method count: 1) cost in 32 ms, listenerId: 5 method=demo.MathGame.primeFactors location=AtExceptionExit ts=2021-08-31 15:22:57; [cost=0.220625ms] result=@ArrayList[ @Object[][ @Integer[-179173], ], @MathGame[ random=@Random[java.util.Random@31cefde0], illegalArgumentCount=@Integer[44], ], null, ] ","date":"2019-10-05","objectID":"/posts/tech/tools/arthas/:4:2","tags":["arthas"],"title":"Arthas(阿尔萨斯)","uri":"/posts/tech/tools/arthas/"},{"categories":["tech"],"content":"monitor（监控） monitor 方法执行监控 monitor com.xx.global.campaign.facade.impl.MerchantsSellerQueryFacadeImpl queryActivityListData -n 10 –cycle 10 $ monitor -c 5 demo.MathGame primeFactors Press Ctrl+C to abort. Affect(class-cnt:1 , method-cnt:1) cost in 94 ms. timestamp class method total success fail avg-rt(ms) fail-rate ----------------------------------------------------------------------------------------------- 2018-12-03 19:06:38 demo.MathGame primeFactors 5 1 4 1.15 80.00% timestamp class method total success fail avg-rt(ms) fail-rate ----------------------------------------------------------------------------------------------- 2018-12-03 19:06:43 demo.MathGame primeFactors 5 3 2 42.29 40.00% ","date":"2019-10-05","objectID":"/posts/tech/tools/arthas/:4:3","tags":["arthas"],"title":"Arthas(阿尔萨斯)","uri":"/posts/tech/tools/arthas/"},{"categories":["tech"],"content":"trace（耗时） trace 方法内部调用路径，并输出方法路径上的每个节点上耗时 trace com.xx.global.campaign.service.business.service.core.impl.ActivitySearchService queryAllCampaignList -n 5 –skipJDKMethod false $ trace demo.MathGame run -n 1 Press Q or Ctrl+C to abort. Affect(class-cnt:1 , method-cnt:1) cost in 20 ms. `---ts=2019-12-04 00:45:53;thread_name=main;id=1;is_daemon=false;priority=5;TCCL=sun.misc.Launcher$AppClassLoader@3d4eac69 `---[0.549379ms] demo.MathGame:run() +---[0.059839ms] demo.MathGame:primeFactors() #24 `---[0.232887ms] demo.MathGame:print() #25 ","date":"2019-10-05","objectID":"/posts/tech/tools/arthas/:4:4","tags":["arthas"],"title":"Arthas(阿尔萨斯)","uri":"/posts/tech/tools/arthas/"},{"categories":["tech"],"content":"指定 classloader 更新 logger level logger logger -c 2a139a55 –name ROOT –level debug ","date":"2019-10-05","objectID":"/posts/tech/tools/arthas/:4:5","tags":["arthas"],"title":"Arthas(阿尔萨斯)","uri":"/posts/tech/tools/arthas/"},{"categories":["tech"],"content":"查看所有的 option vmoption ","date":"2019-10-05","objectID":"/posts/tech/tools/arthas/:4:6","tags":["arthas"],"title":"Arthas(阿尔萨斯)","uri":"/posts/tech/tools/arthas/"},{"categories":["tech"],"content":"其他 Arthas Tunnel?? ","date":"2019-10-05","objectID":"/posts/tech/tools/arthas/:5:0","tags":["arthas"],"title":"Arthas(阿尔萨斯)","uri":"/posts/tech/tools/arthas/"},{"categories":["tech"],"content":"案例 实际案例 ","date":"2019-10-05","objectID":"/posts/tech/tools/arthas/:6:0","tags":["arthas"],"title":"Arthas(阿尔萨斯)","uri":"/posts/tech/tools/arthas/"},{"categories":["tech"],"content":"FAO ","date":"2019-10-05","objectID":"/posts/tech/tools/arthas/:7:0","tags":["arthas"],"title":"Arthas(阿尔萨斯)","uri":"/posts/tech/tools/arthas/"},{"categories":["tech"],"content":"怎么以json格式查看结果？ options json-format true ","date":"2019-10-05","objectID":"/posts/tech/tools/arthas/:7:1","tags":["arthas"],"title":"Arthas(阿尔萨斯)","uri":"/posts/tech/tools/arthas/"},{"categories":["Java","多线程"],"content":"Callable 和 Runnable的区别 ","date":"2019-09-18","objectID":"/posts/tech/java/callable/:1:0","tags":["多线程","并行处理"],"title":"Java 多线程并行处理","uri":"/posts/tech/java/callable/"},{"categories":["Java","多线程"],"content":"相同点 都是接口 都可以编写多线程程序 都采用Thread.start()启动线程 ","date":"2019-09-18","objectID":"/posts/tech/java/callable/:1:1","tags":["多线程","并行处理"],"title":"Java 多线程并行处理","uri":"/posts/tech/java/callable/"},{"categories":["Java","多线程"],"content":"不同点 Runnable没有返回值；Callable可以返回执行结果，是个泛型，和Future、FutureTask配合可以用来获取异步执行的结果; callable接口实现类中的run方法允许异常向上抛出，可以在内部处理，try catch，但是runnable接口实现类中run方法的异常必须在内部处理，不能抛出; 注：Callalble接口支持返回执行结果，需要调用FutureTask.get()得到，此方法会阻塞主进程的继续往下执行，如果不调用不会阻塞。 ","date":"2019-09-18","objectID":"/posts/tech/java/callable/:1:2","tags":["多线程","并行处理"],"title":"Java 多线程并行处理","uri":"/posts/tech/java/callable/"},{"categories":["Java","多线程"],"content":"Callable 样例 声明线程池； 创建任务； 任务执行； 等待任务执行完成； 解析任务执行结构； 关闭线程池； public class ExecutorPool { /*声明线程池*/ public static final ExecutorService EXECUTOR = new ThreadPoolExecutor( 4, 100, 0L, TimeUnit.SECONDS, new LinkedBlockingQueue\u003c\u003e(100), new ThreadFactoryBuilder().setNameFormat(\"customize-pool-%d\").build(), new ThreadPoolExecutor.CallerRunsPolicy()); } @Data @Builder public class ResultDTO { Integer id; boolean processResult; } @Data @Slf4j public class CampaignDemoTask implements Callable\u003cResultDTO\u003e { private Integer id; private CountDownLatch countDownLatch; public CampaignDemoTask(Integer id, CountDownLatch countDownLatch) { this.id = id; this.countDownLatch = countDownLatch; } @Override public ResultDTO call() throws Exception { try { log.info(\"CampaignTaskDemoThread process id={}\", this.id); //process... if (NumberUtils.INTEGER_ONE.equals(this.id)) { TimeUnit.SECONDS.sleep(5L); } else { TimeUnit.SECONDS.sleep(2L); } log.info(\"CampaignTaskDemoThread finish id={}\", this.id); } catch (InterruptedException e) { e.printStackTrace(); } finally { this.countDownLatch.countDown(); } return ResultDTO.builder().id(this.id).processResult(Boolean.TRUE).build(); } } @Slf4j public class CallableTest { public static void main(String[] args) { CallableTest callTest = new CallableTest(); callTest.run(); } public void run() { //总任务数 int total = 3; //线程任务结果集 List\u003cFuture\u003cResultDTO\u003e\u003e futureList = Lists.newArrayList(); //1. 组装线程任务 CountDownLatch countDownLatch = new CountDownLatch(total); for (int i = 0; i \u003c total; i++) { CampaignDemoTask campaignTaskDemoThread = new CampaignDemoTask(i, countDownLatch); //2. 线程池执行 Future\u003cResultDTO\u003e result = ExecutorPool.EXECUTOR.submit(campaignTaskDemoThread); futureList.add(result); } log.info(\"futureList={}\", JSON.toJSONString(futureList)); //3. 等待线程池任务执行完成 try { countDownLatch.await(); // 个别线程执行时间会很长，如果线程执行时间超过某段时间，自动结束该线程; 可使用下面方式 // countDownLatch.await(3L, TimeUnit.SECONDS); } catch (InterruptedException e) { e.printStackTrace(); } log.info(\"futureList={}\", JSON.toJSONString(futureList)); //3. 解析处理结果 futureList.forEach(t -\u003e { try { ResultDTO result = t.get(); log.info(\"result={}\", JSON.toJSONString(result)); } catch (InterruptedException e) { e.printStackTrace(); } catch (ExecutionException e) { e.printStackTrace(); } }); //4.线程池关闭 ExecutorPool.EXECUTOR.shutdown(); log.info(\"done!\"); } } ","date":"2019-09-18","objectID":"/posts/tech/java/callable/:1:3","tags":["多线程","并行处理"],"title":"Java 多线程并行处理","uri":"/posts/tech/java/callable/"},{"categories":["读书笔记"],"content":" 查理就是如此独特的人，他的独特性既表现在他的思想上，也表现在他的人格上。 比如说，查理思考问题总是从逆向开始。如果要明白人生如何得到幸福，查理首先是研究人生如何才能变得痛苦；要研究企业如何做强做大，查理首先研究企业是如何衰败的；大部分人更关心如何在股市投资上成功，查理最关心的是为什么在股市投资上大部分人都失败了。 他的这种思考方法来源于下面这句农夫谚语中所蕴含的哲理：我只想知道将来我会死在什么地方，这样我就就=不去那儿了。”这也是逆向思维的典型例子。 查理对理性有更苛刻的定义。正是这样的“理性”，让查理具有敏說独到的眼光和洞察力，即使对于完全陌生的领域，他也能一眼看到事物的本质。巴菲特就把查理的这个特点称作“两分钟效应”- 他说查理比世界上任何人更能在最短时间之内把一个复杂商业的本质说清楚。 芒格推崇的几个重要的投资原则： ● 逆向思维，凡事总是反过来想； ● 拥有良好的性格，毫不焦躁地持有看好的股票，并保持浓厚的兴趣去提高自己的能力； ● 在自己的“能力圈”中做投资，并不断拓展自己的能力圈； ● 等待好的投资机会出现，一旦出现，倾全力集中投资。 〝我这辈子遇到的聪明人（来自各行各业的聪明人）没有不每天阅读的没有，一个都没有。沃伦读书之多，我读书之多，可能会让你感到吃惊。我的孩子们都笑话我。他们觉得我是一本长了两条腿的书。” 查理论吸引客户：“关健是把手头的事情做好……把手头的事情做好。把已经拥有的客户照顾好，其他的自然会来找你。 查理有把事情彻底弄清楚的欲望。他遇事喜欢穷根究底，无论该事跟他有密切关系与否。任何引起他注意的事情，他都想对其有更多的认识，更多的了解，弄清楚那到底是怎么回事。 “多元思维模型” – “你必须知道重要学科的重要理论，并经常使用它们—-要全部都用上，而不是只用几种。大多数人都只使用学过的一个学科的思维模型，比如说经济学，试图用一种方法来解决所有问题。你知道谚语是怎么说的：“在手里拿着铁锤的人看来，世界就像一颗钉子。”这是处理问题的一种笨办法。 我们看很多书。我认识的聪明人没有不看很多书的。但光看书还不够：你必须拥有一种能够掌握思想和做合理事情的性格。大多数人无法掌握正确的思想，或者不知道该怎么应用它们。 求学之道无坦途，问艺之路无捷径。 -安东尼•特罗洛普 “五何”原则一一你必须说明何人因何故在何时何地做了何事。如果你在布劳恩公司里面写一封信或指示某人去做某事，但没有告诉他原因，那么你可能会被解雇。实际上，你只要犯两次这种错误，就会被解雇。 你们也许会问，这有那么重要吗？嗯，这也跟心理学的原理有关。如果你能够将一堆模式的知识组合起来，回答一个又一个为什么，你就能够更好地思考：同样道理，如果你告诉人们事情的时候，总是告诉他们原因，他们就能更深刻地理解你说的话，就会要加重视你说的话，也会更倾向于听从你说的话。就算他们不理解你的理由，他们也会更倾向于听你的语。 正如你想要从问一个又一个的“为什么”开始获得普世的智慧一样，你在跟别人交流沟通时，也应该把原因讲清楚。就算答案很浅显，你把“为什么”讲清仍是一种明智的做法。 遇到好机会，就全力出击。就是这么简单。 ","date":"2019-07-29","objectID":"/posts/book/poor_charlie_book/:0:0","tags":["理财"],"title":"[读书笔记] 《穷查理宝典》","uri":"/posts/book/poor_charlie_book/"},{"categories":["Tech"],"content":"具体的解决方案如下： 苹果-\u003e系统偏好设置-\u003e最下边点mysql 在弹出页面中 关闭mysql服务（点击stop mysql server） 进入终端输入：cd /usr/local/mysql/bin/ 回车后 登录管理员权限 sudo su 输入mac的管理员密码 回车后输入以下命令来禁止mysql验证功能 ./mysqld_safe –skip-grant-tables \u0026 回车后mysql会自动重启（偏好设置中mysql的状态会变成running） 输入命令 ./mysql 输入命令 FLUSH PRIVILEGES; 输入命令 SET PASSWORD FOR ‘root’@’localhost’ = PASSWORD(‘你的新密码’); 至此，密码已经修改成功，可以登录啦！ ","date":"2019-06-16","objectID":"/posts/tech/setup/mac-reset-mysql-pwd/:0:0","tags":["install","mysql"],"title":"Mac下Mysql重置密码","uri":"/posts/tech/setup/mac-reset-mysql-pwd/"},{"categories":["Java","多线程"],"content":" 并发: 一个处理器同时处理多个任务。有效解决了单CPU下的多任务问题； 并行: 多个处理器或者是多核的处理器同时处理多个不同的任务.[ 能够并行执行任务的基础就是多核CPU ] 前者是逻辑上的同时发生（simultaneous），而后者是物理上的同时发生． 并发性(concurrency)，又称共行性，是指能处理多个同时性活动的能力，并发事件之间不一定要同一时刻发生。 并行(parallelism)是指同时发生的两个并发事件，具有并发的含义，而并发则不一定并行。 来个比喻：并发和并行的区别就是 一个人同时吃三个馒头 和 三个人同时吃三个馒头。 并发与并行的区别 下图反映了一个包含8个操作的任务在一个有两核心的CPU中创建四个线程运行的情况。 假设每个核心有两个线程，那么每个CPU中两个线程会交替并发，两个CPU之间的操作会并行运算。 单就一个CPU而言两个线程可以解决线程阻塞造成的不流畅问题，其本身运行效率并没有提高； 多CPU的并行运算才真正解决了运行效率问题，这也正是并发和并行的区别。 双核四线程运行示意图 ","date":"2019-05-25","objectID":"/posts/tech/java/concurrencyparall/:0:0","tags":["并行\u0026\u0026并发"],"title":"并行\u0026\u0026并发","uri":"/posts/tech/java/concurrencyparall/"},{"categories":["Java","多线程"],"content":"Refer 参考 ","date":"2019-05-25","objectID":"/posts/tech/java/concurrencyparall/:1:0","tags":["并行\u0026\u0026并发"],"title":"并行\u0026\u0026并发","uri":"/posts/tech/java/concurrencyparall/"},{"categories":["Java"],"content":"Java基础概括 ","date":"2019-03-19","objectID":"/posts/tech/java/java-learning/:1:0","tags":["Java"],"title":"Java学习随笔","uri":"/posts/tech/java/java-learning/"},{"categories":["Java"],"content":"大图 ","date":"2019-03-19","objectID":"/posts/tech/java/java-learning/:1:1","tags":["Java"],"title":"Java学习随笔","uri":"/posts/tech/java/java-learning/"},{"categories":["Java"],"content":"Java ","date":"2019-03-19","objectID":"/posts/tech/java/java-learning/:1:2","tags":["Java"],"title":"Java学习随笔","uri":"/posts/tech/java/java-learning/"},{"categories":["Java"],"content":"设计模式 \u0026\u0026 算法 ","date":"2019-03-19","objectID":"/posts/tech/java/java-learning/:1:3","tags":["Java"],"title":"Java学习随笔","uri":"/posts/tech/java/java-learning/"},{"categories":["Java"],"content":"框架 \u0026\u0026 spring ","date":"2019-03-19","objectID":"/posts/tech/java/java-learning/:1:4","tags":["Java"],"title":"Java学习随笔","uri":"/posts/tech/java/java-learning/"},{"categories":["Java"],"content":"中间件 \u0026\u0026 其他 ","date":"2019-03-19","objectID":"/posts/tech/java/java-learning/:1:5","tags":["Java"],"title":"Java学习随笔","uri":"/posts/tech/java/java-learning/"},{"categories":["Java"],"content":"Java ","date":"2019-03-19","objectID":"/posts/tech/java/java-learning/:2:0","tags":["Java"],"title":"Java学习随笔","uri":"/posts/tech/java/java-learning/"},{"categories":["Java"],"content":"Document Oracle Java tutorial ","date":"2019-03-19","objectID":"/posts/tech/java/java-learning/:2:1","tags":["Java"],"title":"Java学习随笔","uri":"/posts/tech/java/java-learning/"},{"categories":["Java"],"content":"List public class ArrayList\u003cE\u003e extends AbstractList\u003cE\u003e implements List\u003cE\u003e, RandomAccess, Cloneable, java.io.Serializable{} public class LinkedList\u003cE\u003e extends AbstractSequentialList\u003cE\u003e implements List\u003cE\u003e, Deque\u003cE\u003e, Cloneable, java.io.Serializable{} public class CopyOnWriteArrayList\u003cE\u003e implements List\u003cE\u003e, RandomAccess, Cloneable, java.io.Serializable {} List list = Collections.synchronizedList(new ArrayList(...)); ","date":"2019-03-19","objectID":"/posts/tech/java/java-learning/:2:2","tags":["Java"],"title":"Java学习随笔","uri":"/posts/tech/java/java-learning/"},{"categories":["Java"],"content":"Java equals() and hashCode() refer Java HashMap equals() Object class defined equals() method like this: public boolean equals(Object obj) { return (this == obj); } According to java documentation of equals() method, any implementation should adhere to following principles. For any object x, x.equals(x) should return true. For any two object x and y, x.equals(y) should return true if and only if y.equals(x) returns true. For multiple objects x, y, and z, if x.equals(y) returns true and y.equals(z) returns true, then x.equals(z) should return true. Multiple invocations of x.equals(y) should return same result, unless any of the object properties is modified that is being used in the equals() method implementation. Object class equals() method implementation returns true only when both the references are pointing to same object. hashCode() Java Object hashCode() is a native method and returns the integer hash code value of the object. The general contract of hashCode() method is: Multiple invocations of hashCode() should return the same integer value, unless the object property is modified that is being used in the equals() method. An object hash code value can change in multiple executions of the same application. If two objects are equal according to equals() method, then their hash code must be same. If two objects are unequal according to equals() method, their hash code are not required to be different. Their hash code value may or may-not be equal. Importance of equals() and hashCode() method Java hashCode() and equals() method are used in Hash table based implementations in java for storing and retrieving data. I have explained it in detail at How HashMap works in java? The implementation of equals() and hashCode() should follow these rules. If o1.equals(o2), then o1.hashCode() == o2.hashCode() should always be true. If o1.hashCode() == o2.hashCode is true, it doesn’t mean that o1.equals(o2) will be true. When to override equals() and hashCode() methods? When we override equals() method, it’s almost necessary to override the hashCode() method too so that their contract is not violated by our implementation. Note that your program will not throw any exceptions if the equals() and hashCode() contract is violated, if you are not planning to use the class as Hash table key, then it will not create any problem. If you are planning to use a class as Hash table key, then it’s must to override both equals() and hashCode() methods. Let’s see what happens when we rely on default implementation of equals() and hashCode() methods and use a custom class as HashMap key. public class DataKey { private String name; private int id; // getter and setter methods @Override public String toString() { return \"DataKey [name=\" + name + \", id=\" + id + \"]\"; } } public class HashingTest { public static void main(String[] args) { Map\u003cDataKey, Integer\u003e hm = getAllData(); DataKey dk = new DataKey(); dk.setId(1); dk.setName(\"Pankaj\"); log.info(\"{}\", dk.hashCode()); Integer value = hm.get(dk); log.info(\"{}\", value); } private static Map\u003cDataKey, Integer\u003e getAllData() { Map\u003cDataKey, Integer\u003e hm = new HashMap\u003c\u003e(); DataKey dk = new DataKey(); dk.setId(1); dk.setName(\"Pankaj\"); log.info(\"{}\", dk.hashCode()); hm.put(dk, 10); return hm; } } When we run above program, it will print null. It’s because Object hashCode() method is used to find the bucket to look for the key. Since we don’t have access to the HashMap keys and we are creating the key again to retrieve the data, you will notice that hash code values of both the objects are different and hence value is not found. We can also use Project Lombok to auto generate equals and hashCode method implementations. import lombok.Data; @Data public class DataKey { private String name; private int id; @Override public String toString() { return \"DataKey [name=\" + name + \", id=\" + id + \"]\"; } } What is Hash Collision ?? In very simple terms, Java Hash table implementations uses following logic for get and put opera","date":"2019-03-19","objectID":"/posts/tech/java/java-learning/:2:3","tags":["Java"],"title":"Java学习随笔","uri":"/posts/tech/java/java-learning/"},{"categories":["Java"],"content":"Project Lombok refer ","date":"2019-03-19","objectID":"/posts/tech/java/java-learning/:2:4","tags":["Java"],"title":"Java学习随笔","uri":"/posts/tech/java/java-learning/"},{"categories":["Java"],"content":"Serialization and Deserialization Serialization is the conversion of the state of an object into a byte stream;deserialization does the opposite. Stated differently, serialization is the conversion of a Java object into a static stream (sequence) of bytes, which we can then save to a database or transfer over a network. When should I implement Serializable interface? implement the Serializable interface when you need to store a copy of the object, send them to another process which runs on the same system or over the network. Why do we do that? Because you want to store or send an object. Does it give any advantages or security? It makes storing and sending objects easy. It has nothing to do with security. What to do instead Instead, use a serialization scheme that you can explicitly control. Such as Protocol Buffers, JSON, XML, or your own custom scheme. refer refer2 ","date":"2019-03-19","objectID":"/posts/tech/java/java-learning/:2:5","tags":["Java"],"title":"Java学习随笔","uri":"/posts/tech/java/java-learning/"},{"categories":["Java"],"content":"Java 泛型（generics） Java Genrics is one of the most important features introduced in Java 5. What does the syntax mean in Java? Here \u003cE\u003e denotes the type parameter of Node class .The type parameter defines that it can refer to any type (like String, Integer, Employee etc.). Java generics have type parameter naming conventions like following: Java Generic Type Naming convention helps us understanding code easily and having a naming convention is one of the best practices of Java programming language. So generics also comes with its own naming conventions. Usually, type parameter names are single, uppercase letters to make it easily distinguishable from java variables. The most commonly used type parameter names are: E - Element (used extensively by the Java Collections Framework, for example ArrayList, Set etc.) K - Key (Used in Map) N - Number T - Type V - Value (Used in Map) S,U,V etc. - 2nd, 3rd, 4th types ？- 通配符泛型 For example take the following scenerio public class Node\u003cE\u003e{ E elem; Node\u003cE\u003e next, previous; } class Test{ Node\u003cString\u003e obj = new Node\u003c\u003e(); } You can use generics with Interface,method and constructor too. For more about generics visit these: https://www.javatpoint.com/generics-in-java Generics in Java Generics was added in Java 5 to provide compile-time type checking and removing risk of ClassCastException that was common while working with collection classes. The whole collection framework was re-written to use generics for type-safety. Let’s see how generics help us using collection classes safely. List list = new ArrayList(); list.add(\"abc\"); list.add(new Integer(5)); //OK for(Object obj : list){ //type casting leading to ClassCastException at runtime String str=(String) obj; } Above code compiles fine but throws ClassCastException at runtime because we are trying to cast Object in the list to String whereas one of the element is of type Integer. After Java 5, we use collection classes like below. List\u003cString\u003e list1 = new ArrayList\u003cString\u003e(); // java 7 ? List\u003cString\u003e list1 = new ArrayList\u003c\u003e(); list1.add(\"abc\"); //list1.add(new Integer(5)); //compiler error for(String str : list1){ //no type casting needed, avoids ClassCastException } Notice that at the time of list creation, we have specified that the type of elements in the list will be String. So if we try to add any other type of object in the list, the program will throw compile-time error. Also notice that in for loop, we don’t need typecasting of the element in the list, hence removing the ClassCastException at runtime. https://www.journaldev.com/1663/java-generics-example-method-class-interface Why do we use Generics in Java? Generics provide strong compile-time type checking and reduces risk of ClassCastException and explicit casting of objects. What is T in Generics? We use to create a generic class, interface, and method. The T is replaced with the actual type when we use it. How does Generics work in Java? Generic code ensures type safety. The compiler uses type-erasure to remove all type parameters at the compile time to reduce the overload at runtime. refer reter 2 泛型通配符 ","date":"2019-03-19","objectID":"/posts/tech/java/java-learning/:2:6","tags":["Java"],"title":"Java学习随笔","uri":"/posts/tech/java/java-learning/"},{"categories":["Java"],"content":"Java Reflection refer Reflection in Java is a very powerful concept and it’s of little use in normal programming but it’s the backbone for most of the Java, J2EE frameworks. Some of the frameworks that use java reflection are: JUnit - uses reflection to parse @Test annotation to get the test methods and then invoke it. Spring - dependency injection, read more at Spring Dependency Injection Tomcat web container to forward the request to correct module by parsing their web.xml files and request URI. The list is endless and they all use java reflection because all these frameworks have no knowledge and access of user defined classes, interfaces, their methods etc. We should not use reflection in normal programming where we already have access to the classes and interfaces because of following drawbacks. Poor Performance - Since java reflection resolve the types dynamically, it involves processing like scanning the classpath to find the class to load, causing slow performance. Security Restrictions - Reflection requires runtime permissions that might not be available for system running under security manager. This can cause you application to fail at runtime because of security manager. Security Issues - Using reflection we can access part of code that we are not supposed to access, for example we can access private fields of a class and change it’s value. This can be a serious security threat and cause your application to behave abnormally. High Maintenance - Reflection code is hard to understand and debug, also any issues with the code can’t be found at compile time because the classes might not be available, making it less flexible and hard to maintain. ","date":"2019-03-19","objectID":"/posts/tech/java/java-learning/:2:7","tags":["Java"],"title":"Java学习随笔","uri":"/posts/tech/java/java-learning/"},{"categories":["Java"],"content":"Java Annotations refer Java 1.5 introduced annotations and now it’s heavily used in Java EE frameworks like Hibernate, Jersey, and Spring. Java Annotation is metadata about the program embedded in the program itself. It can be parsed by the annotation parsing tool or by the compiler. We can also specify annotation availability to either compile time only or till runtime. import java.lang.annotation.Documented; import java.lang.annotation.ElementType; import java.lang.annotation.Inherited; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; import java.lang.annotation.Target; @Documented @Target(ElementType.METHOD) @Inherited @Retention(RetentionPolicy.RUNTIME) public @interface MethodInfo{ String author() default \"Pankaj\"; String date(); int revision() default 1; String comments(); } Meta annotations in java There are five types of meta annotations: @Documented indicates that elements using this annotation should be documented by javadoc and similar tools. This type should be used to annotate the declarations of types whose annotations affect the use of annotated elements by their clients. If a type declaration is annotated with Documented, its annotations become part of the public API of the annotated elements. @Target indicates the kinds of program element to which an annotation type is applicable. Some possible values are TYPE, METHOD, CONSTRUCTOR, FIELD etc. If Target meta-annotation is not present, then annotation can be used on any program element. @Inherited indicates that an annotation type is automatically inherited. If user queries the annotation type on a class declaration, and the class declaration has no annotation for this type, then the class’s superclass will automatically be queried for the annotation type. This process will be repeated until an annotation for this type is found, or the top of the class hierarchy (Object) is reached. @Retention indicates how long annotations with the annotated type are to be retained. It takes RetentionPolicy argument whose Possible values are SOURCE, CLASS and RUNTIME @Repeatable used to indicate that the annotation type whose declaration it annotates is repeatable. Java Annotations Example Let’s see a java example showing the use of built-in annotations in java as well as the use of custom annotation created by us in the above example. import java.io.FileNotFoundException; import java.util.ArrayList; import java.util.List; public class AnnotationExample { public static void main(String[] args) { } @Override @MethodInfo(author = \"Pankaj\", comments = \"Main method\", date = \"Nov 17 2012\", revision = 1) public String toString() { return \"Overriden toString method\"; } @Deprecated @MethodInfo(comments = \"deprecated method\", date = \"Nov 17 2012\") public static void oldMethod() { System.out.println(\"old method, don't use it.\"); } @SuppressWarnings({ \"unchecked\", \"deprecation\" }) @MethodInfo(author = \"Pankaj\", comments = \"Main method\", date = \"Nov 17 2012\", revision = 10) public static void genericsTest() throws FileNotFoundException { List l = new ArrayList(); l.add(\"abc\"); oldMethod(); } } I believe above java annotation example is self-explanatory and showing the use of annotations in different cases. Java Annotations Parsing We will use Reflection to parse java annotations from a class. Please note that Annotation Retention Policy should be RUNTIME otherwise its information will not be available at runtime and we won’t be able to fetch any data from it. import java.lang.annotation.Annotation; import java.lang.reflect.Method; public class AnnotationParsing { public static void main(String[] args) { try { for (Method method : AnnotationParsing.class.getClassLoader() .loadClass((\"com.michael.annotations.AnnotationExample\")).getMethods()) { // checks if MethodInfo annotation is present for the method if (method.isAnnotationPresent(com.michael.annotations.MethodInfo.class)) { try { // iterates all the annotations available in the method for (Annotation a","date":"2019-03-19","objectID":"/posts/tech/java/java-learning/:2:8","tags":["Java"],"title":"Java学习随笔","uri":"/posts/tech/java/java-learning/"},{"categories":["Java"],"content":"Map ","date":"2019-03-19","objectID":"/posts/tech/java/java-learning/:2:9","tags":["Java"],"title":"Java学习随笔","uri":"/posts/tech/java/java-learning/"},{"categories":["Java"],"content":"HashMap refer Java HashMap is one of the most popular Collection classes in java. Java HashMap is Hash table based implementation. HashMap in java extends AbstractMap class that implements Map interface. public class HashMap\u003cK,V\u003e extends AbstractMap\u003cK,V\u003e implements Map\u003cK,V\u003e, Cloneable, Serializable {} Some of the important points about HashMap in Java are; Java HashMap allows null key and null values. HashMap is not an ordered collection. You can iterate over HashMap entries through keys set but they are not guaranteed to be in the order of their addition to the HashMap. HashMap is almost similar to Hashtable except that it’s unsynchronized and allows null key and values. HashMap uses it’s inner class Node\u003cK,V\u003e for storing map entries. HashMap stores entries into multiple singly linked lists, called buckets or bins. Default number of bins is 16 and it’s always power of 2. HashMap uses hashCode() and equals() methods on keys for get and put operations. So HashMap key object should provide good implementation of these methods. This is the reason immutable classes are better suitable for keys, for example String and Interger. Java HashMap is not thread safe, for multithreaded environment you should use ConcurrentHashMap class or get synchronized map using Collections.synchronizedMap() method. Java HashMap Constructors Java HashMap provides four constructors. public HashMap(): Most commonly used HashMap constructor. This constructor will create an empty HashMap with default initial capacity 16 and load factor 0.75 public HashMap(int initialCapacity): This HashMap constructor is used to specify the initial capacity and 0.75 load factor. This is useful in avoiding rehashing if you know the number of mappings to be stored in the HashMap. public HashMap(int initialCapacity, float loadFactor): This HashMap constructor will create an empty HashMap with specified initial capacity and load factor. You can use this if you know the maximum number of mappings to be stored in HashMap. In common scenarios you should avoid this because load factor 0.75 offers a good tradeoff between space and time cost. public HashMap(Map\u003c? extends K, ? extends V\u003e m): Creates a Map having same mappings as the specified map and with load factor 0.75 How HashMap works in java? HashMap in java use it’s inner class Node\u003cK,V\u003e for storing mappings. HashMap works on hashing algorithm and uses hashCode() and equals() method on key for get and put operations. HashMap use singly linked list to store elements, these are called bins or buckets. When we call put method, hashCode of key is used to determine the bucket that will be used to store the mapping. Once bucket is identified, hashCode is used to check if there is already a key with same hashCode or not. If there is an existing key with same hashCode, then equals() method is used on key. If equals returns true, then value is overwritten, otherwise a new mapping is made to this singly linked list bucket. If there is no key with same hashCode then mapping is inserted into the bucket. For HashMap get operation, again key hashCode is used to determine the bucket to look for the value. After bucket is identified, entries are traversed to find out the Entry using hashCode and equals method. If match is found, value is returned otherwise null is returned. There are much more things involved such as hashing algorithm to get the bucket for the key, rehashing of mappings etc. But for our working, just remember that HashMap operations work on Key and good implementation of hashCode and equals method is required to avoid unwanted behaviour. Below image shows the explanation of get and put operations. ","date":"2019-03-19","objectID":"/posts/tech/java/java-learning/:2:10","tags":["Java"],"title":"Java学习随笔","uri":"/posts/tech/java/java-learning/"},{"categories":["Java"],"content":"todo ","date":"2019-03-19","objectID":"/posts/tech/java/java-learning/:3:0","tags":["Java"],"title":"Java学习随笔","uri":"/posts/tech/java/java-learning/"},{"categories":["Java"],"content":"java 链表 java ListNode 链表 ","date":"2019-03-19","objectID":"/posts/tech/java/java-learning/:3:1","tags":["Java"],"title":"Java学习随笔","uri":"/posts/tech/java/java-learning/"},{"categories":["Tech"],"content":"1.保持学习 一个非常重要的观点是：如果你停留在一个地方不前，并不代表你能一直呆在那里，而是代表你正在落后（不进则退）。往前进并不意味着你是就能进步 - 这至少你不会沦落到最后（付出就会有收获） 。程序员为了保持向前发展，就需要不断学习 ，我们需要的不是慢慢的往前走，而是我们要奔跑起来！下面列出这方面的几个观点： 1）读书 2）订阅RSS和阅读一些杂志（我觉得msdn的杂志不错） 3）参加一些研讨会，自己准备一些简报(社区精英、博客园每月的活动等都不错) 4）学习一切可以帮助你的东西 5）教其他人其实也是教自己 ","date":"2018-06-03","objectID":"/posts/book/bettercoder/:1:0","tags":["学习"],"title":"如何成为一名优秀的码农","uri":"/posts/book/bettercoder/"},{"categories":["Tech"],"content":"2.给自己确定目标 如果不知道向什么方向发展，是很难有成就的。这一点关键是自己要有一个清晰地目标。这个应该是个长期的目标，然后要有一个目标的愿景。首先要把这个目标分成一些小的任务，建立实现这些目标的路线图。你可以创建每月或每年你必须完成的一个任务列表，然后根据这个任务列表去实现。 ","date":"2018-06-03","objectID":"/posts/book/bettercoder/:2:0","tags":["学习"],"title":"如何成为一名优秀的码农","uri":"/posts/book/bettercoder/"},{"categories":["Tech"],"content":"3.生活中的每一个挑战都是一个机遇 在日常工作时，总是会遇到各种各样的问题。你可能会遇到一些程序的bug；项目经理分配的新任务；你同事请你帮助；你请别人帮助。这些都是一个一个的挑战。问题是：你如何去解决这些挑战？我的一个答案是：你必要调动你所有的激情去应对这些挑战，因为每个挑战就是一个机遇。 ","date":"2018-06-03","objectID":"/posts/book/bettercoder/:3:0","tags":["学习"],"title":"如何成为一名优秀的码农","uri":"/posts/book/bettercoder/"},{"categories":["Tech"],"content":"4.抱有积极态度 对待每一件事情都应抱着积极的态度。如果发现你犯了一个错误，请不要在意，因为没有人是不会犯错误的。你可以想象一下，有谁喜欢那种一遇到问题就抱怨的人呢？如果你说“好吧,伙计们,我能做到的,请给我一分钟,我就会解决这个问题。”,然后笑着转过身就修改自己的错误，这样在别人眼里又是如何看待你呢？当您解决这个问题之后，你会感觉到异常的高兴。 相信自己的方法是正确的，自己正在快速进步。千万不要老是认为自己无法达到自己的目标。 ","date":"2018-06-03","objectID":"/posts/book/bettercoder/:4:0","tags":["学习"],"title":"如何成为一名优秀的码农","uri":"/posts/book/bettercoder/"},{"categories":["Tech"],"content":"5.给自己寻找一个导师 这并不是说你需要一个人来帮助你来完成你的工作。导师可能就是比你职别高的职员。而且他的职位是你想要去争取的。如果他的职位你争取到了，你可以再选择另外一个更高的。但是你必要一直都需要有这么一个人。也可以能督促你和支持你的朋友、亲人、恋人等等。 ","date":"2018-06-03","objectID":"/posts/book/bettercoder/:5:0","tags":["学习"],"title":"如何成为一名优秀的码农","uri":"/posts/book/bettercoder/"},{"categories":["Tech"],"content":"6.让自己公众化 如何让别人知道你呢？一个最简单的办法是写博客、提问题、帮别人解决问题。起码要google知道你吧。学会在团队和项目中分享自己的知识。如果你学了新的知识，就把它分享出来！如果你没有分享，下次再用的时候，你可能就忘记了。 ","date":"2018-06-03","objectID":"/posts/book/bettercoder/:6:0","tags":["学习"],"title":"如何成为一名优秀的码农","uri":"/posts/book/bettercoder/"},{"categories":["Tech"],"content":"7.时不时的审查一下自己，确保自己的方式正确 时不时的，你需要检查你做的方法是否全正确。检查一下是否完成即将完成的目标。如果没有，赶快找原因，加紧去完成。寻找你的薄弱环节，加强它们。这听起来很滑稽：我认识一个技术很强的开发人员，但他的打字速度却是很慢。为什么？因为他对键盘不熟悉，又不想花10-20小时进行键盘训练。兄弟，如果你会读到此，请务必要求自己克服此类的问题。 ","date":"2018-06-03","objectID":"/posts/book/bettercoder/:7:0","tags":["学习"],"title":"如何成为一名优秀的码农","uri":"/posts/book/bettercoder/"},{"categories":["Tech"],"content":"8.保持健康身体 我写这篇文章之前，算是“集思广益”的。我是一个年轻男子，跟我的笔记本电脑和另一台计算机工作了太长时间，我不能强迫自己做健身运动了。这个有点像磨刀不误砍柴工。有一个故事，两个樵夫打赌砍树，一个比较强壮，另外一个比较瘦弱。强壮的人相信他会赢得，因为他没有休息，持续砍了8小时。瘦小的那位，每隔一个小时就休息15分钟。最后瘦小的那位樵夫却赢了。他赢的秘密在于休息的时候将刀磨锋利了。你的健康就像是斧头，如果斧头钝了，你将无法为自己人生道路披荆斩刺…… ","date":"2018-06-03","objectID":"/posts/book/bettercoder/:8:0","tags":["学习"],"title":"如何成为一名优秀的码农","uri":"/posts/book/bettercoder/"},{"categories":["Tech"],"content":"9.其他 事繁勿慌，事闲勿荒。 每件事情或者项目完成之后，要告之需求者或者领导，让他们做个check，不管大事小事，免后顾之忧。 下班回家前收下邮件，确认没有剩下今天一定要完成的工作，下了班就忘了所有工作。 不要以项目急，作为写糟糕代码的借口，糟糕的代码在以后的维护中会给你带来更大的麻烦。 多请示，多汇报。 不要以工资低，做为不上心工作的借口，既然你接受了这个工资就好好的把事情做好。做一天就要做好一天，不想做就直接走人，别拖着。要做就做好，要么就不做。 动手写程序前，思路一定要清晰，逻辑一定要顺畅，不然写的累，以后维护更累。 碰到问题，就把他研究清楚，弄透彻，这样以后效率会越来越高。不要只知其然，而不知其所以然，下次这个问题还玩你。 要有自己的思想和主见，千万不要只会复制粘贴。 多做事情，不见得是坏事，公司会越来越需要你，多数公司是能看见的。如果你做N多事情，公司视而不见，你可以考虑走人了。 尽量培养自己的一技之长，不管是技术方面的或者业务方面的，提高自己的不可替代性。 学习，技术更新换代很快，不停的学习才是让自己的升值，最起码不贬值的唯一途径。 心态，什么行业，什么工作都会有压力，都会有烦乱的事情。保持良好心态才是王道。 ","date":"2018-06-03","objectID":"/posts/book/bettercoder/:9:0","tags":["学习"],"title":"如何成为一名优秀的码农","uri":"/posts/book/bettercoder/"},{"categories":["Tech"],"content":"Windows下通过bat调用jar时，传参，网上有很多例子，这里就不做阐述。 今儿讲下如何在bat调用jar后，bat可以获取jar的返回值： 思路如下： jar内部执行相应的逻辑，输出不同的内容； 通过常规bat调用jar，同时将jar的输出内容定向到某一个文件a.txt中。（jar中若有时间轮询或等待，bat则会等jar完全结束后，才回处理后续作业） bat后续通过读取文件a.txt内容，进行后续逻辑操作； 以上思路，曲线救国~ demo code如下：inovke.bat @echo off java -jar test.jar \u003e a.txt setlocal enabledelayedexpansion for /f \"tokens=1-3\" %%i in (a.txt) do echo 第一列：%%i 第二列：%%j 第三列：%%k echo %a% pause test.jar的主类文件： public class Config { public static void main(String[] args) { Random random = new Random(); int result = random.nextInt(10); try { TimeUnit.SECONDS.sleep(result);// 随机等待秒速 } catch (InterruptedException e) { e.printStackTrace(); } } } 以上，完成bat同jar的交互 ； 今儿发现另一个思路，可以使用python胶水，来曲线救国~ 记录一下~ ","date":"2018-05-08","objectID":"/posts/tech/tools/windowsbat/:0:0","tags":["bat"],"title":"Windows下bat同jar交互","uri":"/posts/tech/tools/windowsbat/"},{"categories":["Tech"],"content":" markdown-it-demo Refer markdown grammar Markdown，写博客当然要用这个。在线编辑器，所见即所得地编写。 ","date":"2018-05-06","objectID":"/posts/tech/tools/markdown/:0:0","tags":["markdown"],"title":"Markdown 基本语法","uri":"/posts/tech/tools/markdown/"},{"categories":["Tech"],"content":"标题 markdown总支持1~6六级标题，通过在一行之前加上不同数量的井号来表示。 # 这是 H1 # ## 这是 H2 ## ### 这是 H3 ### … ","date":"2018-05-06","objectID":"/posts/tech/tools/markdown/:1:0","tags":["markdown"],"title":"Markdown 基本语法","uri":"/posts/tech/tools/markdown/"},{"categories":["Tech"],"content":"段落 非常自然，一行文字就是一个段落。 段落开头的一个空格\u0026emsp;\u0026emsp; ","date":"2018-05-06","objectID":"/posts/tech/tools/markdown/:2:0","tags":["markdown"],"title":"Markdown 基本语法","uri":"/posts/tech/tools/markdown/"},{"categories":["Tech"],"content":"文本样式 字体样式常用的有粗体、斜体、删除线等。 *斜体字* 对应 斜体字 **粗体字** 对应 粗体字 ~~删除线~~ 对应 删除线 行内代码 对应 行内代码 还有一些样式原生不支持，但是可以通过html间接支持。 可以使用星号*或下划线_指定粗体或者斜体。 这是斜体 这也是斜体 这是粗体 这是粗体+斜体 *这是斜体* _这也是斜体_ **这是粗体** ***这是粗体+斜体*** ` 行内代码 ` ","date":"2018-05-06","objectID":"/posts/tech/tools/markdown/:3:0","tags":["markdown"],"title":"Markdown 基本语法","uri":"/posts/tech/tools/markdown/"},{"categories":["Tech"],"content":"引用 通过在行首加上大于号\u003e来添加引用格式。 DD DD 引用可以嵌套： w 引用可以嵌套： \u003ew \u003e \u003e引用可以嵌套： 也可以嵌套其他格式： ","date":"2018-05-06","objectID":"/posts/tech/tools/markdown/:4:0","tags":["markdown"],"title":"Markdown 基本语法","uri":"/posts/tech/tools/markdown/"},{"categories":["Tech"],"content":"列表 无序列表使用星号、加号或是减号作为列表标记： Red Green Blue 等同于 Red Green Blue 和 Red Green Blue - Red - Green - Blue 有序列表则使用数字接着一个英文句点： Bird McHale Parish 数字并不会影响输出的 HTML 结果，也就是说上面的例子等同于： Bird McHale Parish ","date":"2018-05-06","objectID":"/posts/tech/tools/markdown/:5:0","tags":["markdown"],"title":"Markdown 基本语法","uri":"/posts/tech/tools/markdown/"},{"categories":["Tech"],"content":"内联代码 用反引号` 来标记内联代码，它们会解释成标签 \u003ccode\u003e标签\u003c/code\u003e 如果代码的内容中有反引号，请用两个反引号包裹。 代码中的\u0026、\u003c、\u003e符号都会自动转义，请放心使用。 ` eee ` eee 还有一种是github的风格，代码段的前后用三个反引号 ``` 独占一行来标记。 ww ","date":"2018-05-06","objectID":"/posts/tech/tools/markdown/:6:0","tags":["markdown"],"title":"Markdown 基本语法","uri":"/posts/tech/tools/markdown/"},{"categories":["Tech"],"content":"分隔线 你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线： * * * *** ***** - - - --------------------------------------- ","date":"2018-05-06","objectID":"/posts/tech/tools/markdown/:7:0","tags":["markdown"],"title":"Markdown 基本语法","uri":"/posts/tech/tools/markdown/"},{"categories":["Tech"],"content":"超链接 an example an example [an example](http://example.com/) [an example](http://example.com/ \"Optional Title\") 会被解释为 \u003ca href='https://www.google.com/'\u003egoogle\u003c/a\u003e \u003ca href='https://www.google.com/' title=\"Optional Title\"\u003egoogle\u003c/a\u003e ","date":"2018-05-06","objectID":"/posts/tech/tools/markdown/:8:0","tags":["markdown"],"title":"Markdown 基本语法","uri":"/posts/tech/tools/markdown/"},{"categories":["Tech"],"content":"转义 markdown支持在以下字符前面插入反斜杠，插入之后，将不再解析这些字符，而是原样输出。 \\ 反斜线 ` 反引号 * 星号 _ 底线 {} 花括号 [] 方括号 () 括弧 # 井字号 + 加号 - 减号 . 英文句点 ! 惊叹号 ","date":"2018-05-06","objectID":"/posts/tech/tools/markdown/:9:0","tags":["markdown"],"title":"Markdown 基本语法","uri":"/posts/tech/tools/markdown/"},{"categories":["Tech"],"content":"表格 Item Value Qty Computer $1600 5 Phone $12 12 Pipe $1 234 | Item | Value | Qty | | :------- | ----: | :---: | | Computer | $1600 | 5 | | Phone | $12 | 12 | | Pipe | $1 | 234 | title1 title2 v1 v2 要注意第二行的冒号决定了居左居右还是居中，如果你不加冒号，默认是居左的。 另外可以把第一行去掉，做成没有表头的表格，但第二行始终是要有的。 ","date":"2018-05-06","objectID":"/posts/tech/tools/markdown/:10:0","tags":["markdown"],"title":"Markdown 基本语法","uri":"/posts/tech/tools/markdown/"},{"categories":["Tech"],"content":"TOC TOC = Table of content ， 将内容制作成导航 hexo toc 快速生成markdown目录TOC 快速生成markdown目录TOC，页内跳转 ","date":"2018-05-06","objectID":"/posts/tech/tools/markdown/:11:0","tags":["markdown"],"title":"Markdown 基本语法","uri":"/posts/tech/tools/markdown/"},{"categories":["Tech"],"content":"checkbox checkbox - [ ] checkbox 图片 ","date":"2018-05-06","objectID":"/posts/tech/tools/markdown/:12:0","tags":["markdown"],"title":"Markdown 基本语法","uri":"/posts/tech/tools/markdown/"},{"categories":["Tech"],"content":"内联 ![Alt text](/path/img.jpg) 会被解释为 \u003cimg src='/path/to/img.jpg'/\u003e 这种格式显示图片不能控制对齐和大小，需要的话可以采取raw html的方法： \u003cp align=\"center\"\u003e \u003cimg src=\"https://i.loli.net/2021/01/31/4ZHoWduI59fiqJY.png\" width=\"100\" /\u003e \u003c/p\u003e 自适配图片 引用方式如下： 独库公路-雪山 ","date":"2018-05-06","objectID":"/posts/tech/tools/markdown/:13:0","tags":["markdown"],"title":"Markdown 基本语法","uri":"/posts/tech/tools/markdown/"},{"categories":["Tech"],"content":"外联 ![图片](https://www.baidu.com/img/PCtm_d9c8750bed0b3c7d089fa7d55720d6cf.png) ","date":"2018-05-06","objectID":"/posts/tech/tools/markdown/:14:0","tags":["markdown"],"title":"Markdown 基本语法","uri":"/posts/tech/tools/markdown/"},{"categories":["Tech"],"content":"refer Refer ","date":"2018-05-06","objectID":"/posts/tech/tools/markdown/:15:0","tags":["markdown"],"title":"Markdown 基本语法","uri":"/posts/tech/tools/markdown/"}]