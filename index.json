[{"categories":["生活"],"content":"视角 ","date":"2021-01-03","objectID":"/posts/life/sentence/:1:0","tags":["励志"],"title":"心灵鸡汤","uri":"/posts/life/sentence/"},{"categories":["生活"],"content":"邓宁-克鲁格心理效应 能力欠缺的人在自己欠考虑的决定的基础上得出错误结论，但是无法正确认识到自身的不足，辨别错误行为，是一种认知偏差现象。这些能力欠缺者们沉浸在自我营造的虚幻的优势之中，常常高估自己的能力水平，却无法客观评价他人的能力。 邓宁-克鲁格心理效应 知识加经验是开悟之路的关键 ","date":"2021-01-03","objectID":"/posts/life/sentence/:1:1","tags":["励志"],"title":"心灵鸡汤","uri":"/posts/life/sentence/"},{"categories":["生活"],"content":"随笔 世上只有一种真正的英雄主义，就是认清了生活的真相后依然热爱生活。 - 罗曼·罗兰的《米开朗基罗传》 生活，就是抱最大的期望，尽最大的努力，做最坏的打算，持最好的心态，记住该记住的，忘记该忘记的。 不要沉迷框架，修炼内功 提高英语阅读能力【google translate】 职场从来不缺普通的程序员 工作之外有自己感兴趣的东西 学会规划自己的时间，时间管理【be foucused、番茄todo】 学会安排自己的任务【Trello】 学会使用工具提升工作效率 学会休息，注意健康 对业务和产品比较敏感。 提升技术的深度、技术的广度、对业务和产品敏感的个人。 用最快的方式，提高自己的核心竞争力。 ","date":"2021-01-03","objectID":"/posts/life/sentence/:2:0","tags":["励志"],"title":"心灵鸡汤","uri":"/posts/life/sentence/"},{"categories":["生活"],"content":"大道至简 加油，把刷题变成打游戏一样的兴趣。 天道酬勤，凡事感激. 编程能力就像任何其他技能一样，也是一个可以通过刻意练习大大提高。 大多数经典面试题目都有多种解决方案。 为了达到最佳的练习效果，我们强烈建议您至少将此清单里的题目练习两遍，如果可以的话，三遍会更好。 在第二遍练习时，你可能会发现一些新的技巧或新的方法。 到第三遍的时候，你会发现你的代码要比第一次提交时更加简洁。 如果你达到了这样的效果，那么恭喜你，你已经掌握了正确的练习方法！ 记住：刻意练习并不意味着寻找答案并记住它，这种练习方法不是长久之计。 在没有参考答案情况下，越能自主解决问题，才越能提高自身能力。 ","date":"2021-01-03","objectID":"/posts/life/sentence/:3:0","tags":["励志"],"title":"心灵鸡汤","uri":"/posts/life/sentence/"},{"categories":["生活"],"content":"北大通知书 假如北大在你高一的时候就给你发了一张录取通知书，但是要想得到它的话，你需要在高中三年满足以下六个条件，你答应还是不答应？ 第一，每天早晨05:40起床，唤醒大脑，坚持晨读。 第二，每天坚持背50个单词。 第三，每天坚持复习昨天学过的内容。 第四，每周末坚持整理本周的数理化错题。 第五，经常思考学过的知识点，它背后的逻辑没有掌握好，就去重新学习。 第六，每天抽时间做体育锻炼。 等到三年以后，你只要满足以上条件，那这张录取通知书就生效，你愿意答应吗？ 我想你心中已经有了答案，但其实如果你三年能够坚持做到这六点事儿，完全可以自己考上北大。 ","date":"2021-01-03","objectID":"/posts/life/sentence/:4:0","tags":["励志"],"title":"心灵鸡汤","uri":"/posts/life/sentence/"},{"categories":["读书笔记"],"content":"微习惯-成就卓越自我管理的法则 ","date":"2023-06-22","objectID":"/posts/book/tools/mini-habits/:1:0","tags":["读书笔记"],"title":"[读书笔记] 微习惯","uri":"/posts/book/tools/mini-habits/"},{"categories":["读书笔记"],"content":"关于书 武君 著 ","date":"2023-06-22","objectID":"/posts/book/tools/mini-habits/:1:1","tags":["读书笔记"],"title":"[读书笔记] 微习惯","uri":"/posts/book/tools/mini-habits/"},{"categories":["读书笔记"],"content":"微习惯是什么 狗家族出了一只很有志气、很有地的的小细，它向整个家族宣布：要去横穿大沙漠！所有的狗都跑水向它表示祝贺。在一片欢呼声中，这只小狗带足了食物、水，然后上路了。3天后，突然传来了小狗不幸牺牲的消息。 是什么原因使这只很有理想的小狗死了呢？检查食物，还有很多；水不足吗？也不是，水壶里还有水。后来经过研究，终于发现了小狗牺牲的秘密一—小狗是被尿憋死的。 之所以被尿憋死是因为狗有一个习惯——定要在树干旁撒尿。由于大沙漠中没有树，也没有电线杆，所以可怜的小狗一直憋了了天，终于被憋死了。 狗是如此，人呢？ 狗是习慨的动物，同样人也是。一个人的行为方式、生活可惯是多年养成的。比如，与人沟通交往的方式、与人相处的模式。。都是多年习惯积累慢慢成型的。 孔子在《论语》中提道。“性相近，习相远也。”人的本性是很接近的，但由于习惯不同便相去甚远； 小时候培养的品格就好像是天生就有的，长期养成的习惯就好像完全出于自然。俗话说：“贫穷是一种习惯，富有也是一种习惯；失败是一种习惯，成功也是一种习惯。” 一条铁链竞能拴佳一头重达干斤的大象，可这令人难以置信的景象在印度和泰国随处可见。原来那些列象人在大象还是小象的时候，就用一条铁链把它绑在柱子上。由于力量尚末长成，无论小象怎样挣扎都无法摆脱锁链的束缚，于是小象渐渐地习惯了而不再挣扎，直到长成了庞然大物，虽然它此时可以轻而易举地挣脱链子，但是大象依然选择了放弃挣扎，因为在它的惯性思维里，它仍然认为摆脱链子是水远不可能的。 小象是被实实在在的链子鄉住的，而大象则是被看不见的习惯绑住的。 习惯虽小，却影响深远。习惯对我们的生活有绝对的影响，因为它是一贯的。在不知不觉中，习惯经年累月地影响着我们的品德，决定我们思维和行为的方式，左右着我们的成败。看看我们自己，看看我们周围，好习惯造就了多少辉煌成果，而坏习惯又毀掉了多少美好人生！ 习惯一旦形成，就极具稳定性。生理上的习惯左右着我们的行为方式，决定我们的生活起居；心理上的习惯左右着我们的思维方式，决定我们的待人接物。当我们的命运面临执择时，是习惯帮我们作出决定。 ","date":"2023-06-22","objectID":"/posts/book/tools/mini-habits/:1:2","tags":["读书笔记"],"title":"[读书笔记] 微习惯","uri":"/posts/book/tools/mini-habits/"},{"categories":["读书笔记"],"content":"关于书 张宏杰 / 岳麓书社 ","date":"2023-06-03","objectID":"/posts/book/zengguofan_1/:0:0","tags":["读书笔记"],"title":"[读书笔记] 曾国藩的正面与侧面-1","uri":"/posts/book/zengguofan_1/"},{"categories":["读书笔记"],"content":"序 ","date":"2023-06-03","objectID":"/posts/book/zengguofan_1/:1:0","tags":["读书笔记"],"title":"[读书笔记] 曾国藩的正面与侧面-1","uri":"/posts/book/zengguofan_1/"},{"categories":["读书笔记"],"content":"关于书 曾国藩 著 李青 译 相关链接： https://www.8bei8.com/book/zengguofanjiashu.html ","date":"2023-06-03","objectID":"/posts/book/zengguofan_letter/:0:0","tags":["读书笔记"],"title":"[读书笔记] 《曾国藩家书》","uri":"/posts/book/zengguofan_letter/"},{"categories":["读书笔记"],"content":"序 曾国藩（1811一1872），初名子城，字伯涵，号涤生。中国近代政治家、战略家、理学家、文学家，湘军的创立者和统帅。他一生奉行为政以耐烦为第一要义，主张凡事要勤俭廉劳，不可为官自傲。他修身律己，以德求官，礼治为先，以忠谋政，在官场上获得了巨大的成功，与李鸿章、左宗棠、张之洞并称 “晚清中兴四大名臣”. 当关于曾国藩的传记书籍越来越多，当人们将其越传越神奇之时，我们应该明白一点，那就是，不管曾国藩声名如何显赫，人生怎样传奇，他也只是一个凡人。如果我们用生面而立体的眼光去回顾他的一生，那么他不仅仅是一个伟大的政治家军事家，更大程度上，他是一个给子人们无数做人智慧的老者，一个参悟平常生活的智者。 从他亲笔留下的家书中，他的形象在我们面前逐渐清晰，他非天资聪颖之辈。其父曾文亭“平生因学而困苦”，便将学优而仕、光宗耀祖的希望寄托在儿子身上，从早到晚耳提面命，督促曾国藩用功读书。 曾国藩参加科举三败犹战，终入翰林，拜师求学日课十二事，自省自戒。如此，终学有所成。 普国藩是—个不怕犯错懂得及时忏悔自新的人。面对讥笑，他自嘲海涵，道出宽怀之道；遭受政界架空，他静思审慎之道;受到朝廷冷落，他反躬自省，了悟功成身退之道。 曾国藩是个读书有心，养生有道的智者。在他的观念中，“高明由于天分，精明在于学问”。“精明”是—个人内在气质、外在行为的修养规范，而“人之气质，由于天生，本难改变，为读书可变化气质”。读书虽有如此妙用，但书为人所用更要讲求方法门道。所以，曾国藩无数次将自己的读书经验、学习方法告知子弟，留下了大量宝贵的家书。 曾国藩读书有道，教子有方，处世有原则，养生亦有窍门，注重养生更注重养心。纵观他的一生，出身于普通农家的曾国藩，没有超绝的资质，却一步步走上晚清的政治舞台，成为四大中兴名豆之首，死后被朝廷称费为 “学问纯粹，器识宏深，秉性忠诚，持躬清正”。这十六个字，足以看出他修身齐家治国的智慧。 曾国藩的成就引发了一代又一代人对他的研究，他的墨宝更是为后人所极力研究。 在曾国藩仕途多年来写给一家老小的书信中，从修身、劝学、治家、为政、军事、交友、养生、理财等诸多方面与家人沟通、指教，互相提高，一起改进，不断进步和完善。他的智慧与善良、他的自省与恒心、他对兄弟和后辈的教导 与关爱、他的心怀家人关爱家乡，无不感念着一代代人，无不透露着一位智者身上无穷的智慧与力量。读之可以重温古人传奇，感受历史长河里的智慧，然后“取其精华，舍其糟粕”，体悟曾国藩家信所带给我们的现代启示。 归纳共有 劝学、修身、治家、为政、军事、交友、用人等篇； ","date":"2023-06-03","objectID":"/posts/book/zengguofan_letter/:1:0","tags":["读书笔记"],"title":"[读书笔记] 《曾国藩家书》","uri":"/posts/book/zengguofan_letter/"},{"categories":["读书笔记"],"content":"修身篇 ","date":"2023-06-03","objectID":"/posts/book/zengguofan_letter/:2:0","tags":["读书笔记"],"title":"[读书笔记] 《曾国藩家书》","uri":"/posts/book/zengguofan_letter/"},{"categories":["读书笔记"],"content":"致诸弟·明师益友虚心请教 如果可以发奋自立，那么不但家墊能够读书，就算旷野场方、热闹场所，也可以读书，背柴放牧，都能够读书。 如果无法发奋自立，那么不但家墊不适合读书，就算是清净的地方、神仙所居之地境，也都无法读书。为何要选择地方？为何要选择时间？只要问问自己：自己的志向是不是真的。 六弟埋怨自己的命运不好，我也深以为然。但仅仅是小试遇到挫折，就发牢骚，我暗笑他志向太小，其心中忧虑的不大。君子立志，要有为民众请命的器量，内修圣人的德行，外建王者称霸天下的雄功，然后才不负父母生育自己，不愧为天地间一个完全的人。所以他所忧虑的，是因自己比不上舜帝和周公而忧虑，以德行没有修整、学问没有大成而忧虑。因此，为顽固的刁民难以感化而忧虑；为野蛮狡猾的少数民族不能征服而忧虑；为小人在位而贤人得不到重用而忧；为普通百姓没有得到自己的恩泽而忧。这就是通常所说的悲天命而怜悯百姓穷苦，这属于君子的忧虑。如果只是一个人的屈与伸，一家人的饥和饱，世俗所说的荣与零、得与失、贵与贱、毁与誉，君子还没有工夫去为这些忧虑呢。 六弟为一次小试感到受屈，自己觉得命运不济，我暗笑他的忧虑太小了。如果人不读书便罢了，只要自称为读书人，那么就一定要学习《大学》。《大学》的纲要有三点：明德、新民、止至善，皆为读书人分内的事情。如果读书人无法深入领会，认为这三点与自己毫不相干，那读书又有何用？可以写文作诗，博学雅用自吹自擂，也只算得一个识宇的牧童而已，怎么能叫明白事理有用的人。朝廷以制艺来选取人才，也是因为他可以代替圣贤人士立言，必然明白圣贤的道理，行圣贤的行为，可以为官管理民众，以身作则来带领别人。如果认为宣教德化教导百姓是分外的事情，那么就算可以写文行诗，却对于修身治人的道理茫然不懂，朝廷用这样的人当官与用牧童当官，又有什么区别呢？ 既然自称读书人，那么《大学》的纲领都是自己立身切要的事情，就十分明白了。《大学》应该修的科目共有八个方面，在我看来，取得功效的地方，只有两个方面：一个叫格物，一个叫诚意。 格物，致知的事情；诚意，力行的事情。物是什么？就是本末的事物。身体、心灵、意念、知识、家、国、天下，都是物，天地万物，都是物。日常用的、做的，都是物。格，是探究物的同时探索理。比如侍奉父母、定期探亲，是物；探求为什么应该定期探亲的理由，就是格物。侍奉兄长，更随他行动就是物；探求为什么应该跟随兄长的理由，就是格物。我的心，是物；探索自己心理存在的原因，深入研究心的省悟、观察、酒养的道理，就是格物。我的身体，是物；研究如何敬惜身体，并深入研究坐得端正、站得恭敬以敬身的道理，就是格物。每天所看的书，句句都是物；切身领悟，探究其中的道理，就是格物。这都是致知方面的事。所谓诚意，就是根据自己领悟的道理努力去做，不自欺欺人。知道一句话的道理，每天按照实行，这是力行的事。两者并进，下学在这里，上达也在这里。 我的朋友吴竹如格物功夫很深，一事一物，都要求它的道理。倭艮峰先生诚意功夫非常严谨，每天有日课册子。一天之中，一念之差、一事之失、一句话一刻思考，他都会记录下来。宇都是正楷，三个月订一本，从乙未年起，已订了三十本。由于他慎独严格，即使偶尔出现妄念，也一定会马上克服，写在书上。所以他读的书，句向都是切合自身的良药，现将艮峰先生日课抄三页寄回给弟弟们看。 我从十月初一日起，也像艮峰一样，每天一个念头、一件事情都记录在册子 上，以便随时看见了加以克服，也写正楷。冯树堂和我同日记起，也有日课册子。树堂非常虛心，爱扩我就像兄长，敬重我就像老师，将来一定有所成就。 我向来有缺少恒心的毛病，从写日记本子开始，可以保证一生有恒心了。明师益友，不断督促着我，只可前进不可后退。本打算抄我的日课册给弟弟们看，今天镜海先生来，要将本子带回，因此没来得及抄。十一月有信使，一定抄几页寄回。 我的益友，如倭艮峰的鲜明端庄，让人肃然起敬；吴竹如、实兰泉的精研究义，一言一事，实事求是。昊子序、邵蔥西谈经，深恩明耕：何子贞谈宇，其精妙处，与我无一不合，谈诗尤其底见一致。子支非常喜欢我的诗，所以我从十月以来巴作十八首，现抄两页寄回，给弟弟看。冯树堂、陈农云立志，深切而不慌忙，也是良友。统海先生，我虽然没有拿着礼物去请求授业，而心里早已师从他了。 ","date":"2023-06-03","objectID":"/posts/book/zengguofan_letter/:2:1","tags":["读书笔记"],"title":"[读书笔记] 《曾国藩家书》","uri":"/posts/book/zengguofan_letter/"},{"categories":["读书笔记"],"content":"致九弟·时刻悔悟大有进益 弟弟要求为兄随时训示，先自问近年来，得力于一个\"悔\"字决。以前自负，觉得自己的本领大，能屈能伸，可行可藏，又经常看见别人的不足。自从丁巴年、戊午年大悔悟之后，才知道自己没有本领，凡事都看见别人有几分对。因此自成午年到现在九年里，与四十岁之前完全不同。大致上以能立能达为体，以不怒不尤为用。立，是发奋自强，站得住的意思。达，是办事周到行得通的意思。 九年以来我痛下决心改掉没有恒心的毛病，看书写字，从不间断，选将练兵，也时常操心，这都是自强自立的功夫。奏疏公牍，再三斟酌，没有一句过头的话，没有一个自夸的词，这都是圆润练达的功夫。至于怨天，本来就不敢；尤人还无法避免，但也能随时强制自己克服。 弟弟如果想自己警惕，似乎可以学为元丁、戊二年的悔悟，然后痛下决心改正，定会有大收获。“立达”二宇，我在己未年曾经写在常弟的手卷上，弟弟也时常想自立自强，不过对达字还缺体验，对于不怨天尤人，还难以克制。我在信中随时指点，劝弟克制自己。赵广汉原本是汉的贤臣，因星变而弹劾魏相，后来身受灾祸，可引以戒。心中暗存“悔” 字，没有什么事不可挽回。（同治六年正月初二日） ","date":"2023-06-03","objectID":"/posts/book/zengguofan_letter/:2:2","tags":["读书笔记"],"title":"[读书笔记] 《曾国藩家书》","uri":"/posts/book/zengguofan_letter/"},{"categories":["读书笔记"],"content":"致九弟四弟·早起乃健身之妙方 家里的后辈子弟，身体弱的学射击，最能够保养身体，而早起尤其为健身的千金妙方，是长寿的金丹啊！（成丰十年三月二十四日） ","date":"2023-06-03","objectID":"/posts/book/zengguofan_letter/:2:3","tags":["读书笔记"],"title":"[读书笔记] 《曾国藩家书》","uri":"/posts/book/zengguofan_letter/"},{"categories":["读书笔记"],"content":"致四弟·述养身有五事 我越来越老了，勉强支持一年半，实在不能再担大任了。 我想我们兄弟身休都不大好，后辈子侄们更是虚弱，适合在平日学习一些养身的方法，不应该临念时乱看郎中乱吃药。 养身的方法，基本上有五个方面： 一是睡眠有规律； 二是制怒： 三是节欲： 四是每晚临睡时洗脚： 五是每天两餐后各走三千步。 制怒就是我在文章中所讲的养生以少恼怒为本。还有洗脚二事，星冈公坚持了四十年，我也学着些坚持了七年，饭后三千步，我近来试着实行，从此以后再也不间断。弟弟以前太辛苦了，年近五十，希望你下决心将这五个方面的事实行起来，并劝沅弟和子侄们也实行。 我和沅弟同时封爵开府当督抚，门庭可算得上是非常兴盛，但不是能够长期依仗的。我还记得正月，星冈公训竹亭公说： “宽一虽点了翰林，我家仍然要靠作田为业，不可以靠他吃饭。” 这话最有道理，如今也应该以这两句为命脉。希望弟弟在作田上用功，辅以“书、蔬、鱼、猪、早、扫、考、宝”八个宇，不管家里如何富贵兴盛，一定不要完全改变道光初年的规模。 但凡家道能够长久的，不是依靠一时的官爵，而是依在长远的家规。不是依靠一两个人的骤然发迹，而是依靠大众的维持。 老亲旧戚，贫困的族党，不能怠慢人家，对待贫困的要和对待富有的一个样，在兴盛的时候要预先有衰落的打算，那自然就有深厚坚实的基础了。（同治五年一月初五日） ","date":"2023-06-03","objectID":"/posts/book/zengguofan_letter/:2:4","tags":["读书笔记"],"title":"[读书笔记] 《曾国藩家书》","uri":"/posts/book/zengguofan_letter/"},{"categories":["读书笔记"],"content":"劝学篇 ","date":"2023-06-03","objectID":"/posts/book/zengguofan_letter/:3:0","tags":["读书笔记"],"title":"[读书笔记] 《曾国藩家书》","uri":"/posts/book/zengguofan_letter/"},{"categories":["读书笔记"],"content":"致诸弟·必须立志猛进 四位老弟足下： 从7月发信以后，没有收到弟弟们的信。乡里寄信比省城要难百倍，因此我也不盼望。九弟上次的信中说他有意同刘霞仙同伴读书，这个想法非常不错。霞仙最近读朱子的书，很有见解，不过不清楚他的谈吐容貌、规模气质如何？如若他言语行为有礼，威仪能够成为表率，那么师从他也是可行的，何必仅限于朋友呢？不过与他同住，也要真的可以有收获才好，不要只是仰慕別人的虚名。 一个人如果能够自己立志，那么圣贤豪杰什么事情做不成？又何必借助別人呢？我想仁，仁便达到了。我想要做孔、孟，那就日夜孜孜以求，唯有孔、孟才去学，那叉谁能阳挡得了我呢？如果自己不立志，就算是天天与尧、舜、禹、汤同住，也是他是他，我是我，又与我有何关系？ 去年温甫想要到省城来读书，我以为离开家庭局促的狭小天地而与省城那些比自己优秀的人相处，进步一定是不可限量的。两年以来，他看书也不怎么多，至于诗文也没有任何长进，所以不能归因于环境的局促。 去年我为他选择丁君叙忠为师，后来由于丁君的北方太远了，没去，我印象中就没有其他老师可从了。今年第弟自己选择罗罗山政文，此后却没有了消息，因此也不能归因于没有良师益交。时光飞近，两过几年，他就满三十了，不能不趁现三十岁前，立志快速进步啊。我受父亲教育，但我不能救弟弟成名，这让我深感惭。别人与我交往，很多都受到我的益处，而唯独几位弟弟没有收益，这也是我所深深痛恨的。 ","date":"2023-06-03","objectID":"/posts/book/zengguofan_letter/:3:1","tags":["读书笔记"],"title":"[读书笔记] 《曾国藩家书》","uri":"/posts/book/zengguofan_letter/"},{"categories":["读书笔记"],"content":"致四弟九弟·谆嘱瑞侄用功 澄、沅弟左右： 纪瑞侄得了县里的案首，大让人欣慰了。我没有指望家里代代得富贵，但希望家里代代有秀才。秀才就是读书的种子、世家的招牌、礼义的旗帜。谆浮教导瑞侄从此更加用功，做人和做学问一超进步，一定要戒 “骄奢”三字，这样家里的风气便会越来越淳厚，而众侄子们都会争相学习磨炼。 ","date":"2023-06-03","objectID":"/posts/book/zengguofan_letter/:3:2","tags":["读书笔记"],"title":"[读书笔记] 《曾国藩家书》","uri":"/posts/book/zengguofan_letter/"},{"categories":["读书笔记"],"content":"致四弟九弟·述为不学有四要事 澄、沅两弟左右： 多次接到你们的来信，并看了弟弟给纪泽等的谕站，知道了所有。哥哥我从八月十三日出省，十月十五日回来，在外边勿忙，不能经常给你们写信，深表歉意。小澄生子，岳松入学，是家里最近值得庆祝的事。沅弟夫妇生病后快速痊愈，也是值得欣慰的。 我看家里后辈都体质虚弱，读书不大长进，曾经以养生六大要事勉励子侄辈： 一是饭后走一千步； 一是睡觉前泡脚； 一是胸中没有恼怒； 一是在固定时问按时静坐； 一是在固定时问练习射箭： 一是在黎明时分吃一碗白饭，一口菜都不吃。 这些我都听老人说的，屡试不爽，没有一丝弊病，现在希望家中子侄能尝试。 又曾经以为学等四什事勉励儿辈。 一是看生书要做到快速，不多读就会太寡闻。 一是温习旧书要求熟悉，不背诵就容易忘记。 一是习字要有恒心，不会写就好像是身上无衣，山上没有树。 一是作文要苦思，不会写文章，好比哑巴不能说话，马跛不能行走。 四者缺一不可，这是我阅历一生的深切体会，现在也希望家里子侄们能努力实行。养生和学习两件事，齐头并进，就一定能锻炼意志并强建身体，这或是家中振兴的征兆。两位弟弟如果觉得对，希望常以这四点教诫子侄。 哥哥我在外两月多了，应酬非常繁忙，眩罩、疝气等病，幸好没有复发，脚肿也好了。只是眼晴模糊一天此一天严重，小便太多，衰老相逼而来，时势这样，不足为怪。（同治十年十月二十三日） ","date":"2023-06-03","objectID":"/posts/book/zengguofan_letter/:3:3","tags":["读书笔记"],"title":"[读书笔记] 《曾国藩家书》","uri":"/posts/book/zengguofan_letter/"},{"categories":["读书笔记"],"content":"治家篇 ","date":"2023-06-03","objectID":"/posts/book/zengguofan_letter/:4:0","tags":["读书笔记"],"title":"[读书笔记] 《曾国藩家书》","uri":"/posts/book/zengguofan_letter/"},{"categories":["读书笔记"],"content":"禀父母·教弟以和睦为第一 正是由于儿子有可埋怨的五点，因此四弟、六弟难免心里藏着这些不满，以前一直门在心里没有申述的机会，所以从不给我写信。 去年腊月给我写了一封长信，才把这一肚子怨气都吐了出来。儿子接到信后，又高兴又害怕。高兴的是弟弟们都非常有志气，不可阳挡，担心的是儿子如果再次违背他们的意愿，那么就会伤了兄弟间的和气。 兄弟和睦，就算是穷困的小户也一定会兴旺;兄弟不和，就算是世代官宦人家也一定会败落。儿子深知这个道理，因此禀告堂上长辈，答应儿子等兄弟的请求，一定要将兄弟和睦放在第一位。九弟前年想回，儿子百般挽留，到去年才不再强留，也是害怕违背了他的意愿。临走时彼此之间依依不舍情深似海。因此儿子从九弟走后，非常思念他，也非常相信他。 ","date":"2023-06-03","objectID":"/posts/book/zengguofan_letter/:4:1","tags":["读书笔记"],"title":"[读书笔记] 《曾国藩家书》","uri":"/posts/book/zengguofan_letter/"},{"categories":["读书笔记"],"content":"致诸弟·在家宜注重勤敬和 兄弟姑嫂之间，总不可以有半点不和气。 任何一个家庭，勤、敬两个宇能做到几分，没有不兴旺的；如果一分都做不到，没有不败落的。和字能做到几分，没有不兴旺的；不和，没有不衰败的。 弟弟们试着在乡中将这三个字拿到家族亲威当中挨个验证，必定会觉得我的话没错。 弟弟们不喜欢打扫卫生，比我还严重，这是败家的表现，以后一定要细心打相，就算是一张纸一根线，就是竹头木屑，也常要打扫干净，要给儿侄辈树立榜样。第一代人如果疏忽懒散，第二代就会骄奢淫逸，那么就会渐渐出现白天睡觉，晚上打牌、吃鸦片这些坏事！ 四弟、九弟比较勤快，六弟、季弟比较懒散，以后勤快的要更加勤快，懒散的要痛改，不要让子孙学会怠惰懒散的样子，非常重要！ 子侄们除了读书，还要教他们打扫房间、擦桌椅、拾粪、除草，这些都是很好的事情，一定不要觉得这有损面子，而不去做。（威丰四年八月十一日） ","date":"2023-06-03","objectID":"/posts/book/zengguofan_letter/:4:2","tags":["读书笔记"],"title":"[读书笔记] 《曾国藩家书》","uri":"/posts/book/zengguofan_letter/"},{"categories":["读书笔记"],"content":"致四弟·治家有八字诀 澄侯四弟左右： 二十七日收到你的信，欣慰知悉全家平安。沅弟当天申刻到了，又详细询问了一切，恭敬地得知叔父临终前完全没有忧郁的情绪，感到很安慰！ 我与沅弟讨论治家的方略，所有都以星冈公为准则。大约有八字诀，其中四个字就是去年说的书、蔬、鱼、猪，还有四个宇就是早、扫、考、宝。 早，是早起床。 扫，是洒扫房屋庭院。 考，是祭祀祖先，奉祭显考、王考、曾祖考，这话对妣也一样。 宝，指同亲威邻居经常往来，贺喜吊丧，询问疾苦，救助困难。 星冈公经常说：“人与人之间互相抬举，实属无价之宝。” 星冈公一生对这些治家方略执行得最是认真，因此我开玩笑编为八字诀：书、蔬、鱼、猪、早、扫、考、宝。这看起来像是开玩笑的话，但我准备写在屏上，用来祝贺贤弟夫妇的寿辰，让后世子孙知道我们兄弟的家教，也知道我们兄弟的风趣，弟弟觉得怎样？（咸丰十年国三月二十九日） 人待人，无价之宝也； ","date":"2023-06-03","objectID":"/posts/book/zengguofan_letter/:4:3","tags":["读书笔记"],"title":"[读书笔记] 《曾国藩家书》","uri":"/posts/book/zengguofan_letter/"},{"categories":["读书笔记"],"content":"致四弟·教子侄做人要谦虚勤劳 我身体平安。这一个月里的惊恐危急，实在比八月徽、宁失守时要危险艰难很多倍。我这几年在外面，问心无愧，死生祸福，都不怎么在意了，只是接到英、法、美各国通商条款，知道大局已败，难免心灰意冷。现在奇回两本通商条款，给弟弟看看。形势一天不如一天。 我家的子侄们一定要以谦、勤两个字为重，戒掉骄做懒惰，这是保全家族的办法啊！（威丰十年十二月初） ","date":"2023-06-03","objectID":"/posts/book/zengguofan_letter/:4:4","tags":["读书笔记"],"title":"[读书笔记] 《曾国藩家书》","uri":"/posts/book/zengguofan_letter/"},{"categories":["读书笔记"],"content":"为政篇 ","date":"2023-06-03","objectID":"/posts/book/zengguofan_letter/:5:0","tags":["读书笔记"],"title":"[读书笔记] 《曾国藩家书》","uri":"/posts/book/zengguofan_letter/"},{"categories":["读书笔记"],"content":"禀父母·不敢求非分之荣 儿子国藩跪禀父母亲大人万福金安： 九月十七日，收到第五、第六两封家信，很高兴堂上各位老人身体安康，家里的事情顺利，无比欣然！儿子今年不得差，六弟乡试未能考取，想来堂上长辈难免感到忧虑。但是儿子反以不得差而感到欣喜，因为天下的道理，大满就会招来损失，位子大高容易遭到败亡，大阳升到最高就会西落，月亮圆了就会缺，这是不变的道理。儿子毫无学识，做官做到学士，多次得到非分的荣耀，祖父母、父母又都健康，可说已经非常兴盛了。 现在的京官，翰林里没有喜事下传，只有我家独享这种难得的福泽。所以儿子战战兢兢，不敢谋求非分的荣宠，只希望堂上长辈睡眠饮食不出问题，全家平安，就是最大的幸运。希望祖父母、父母、叔父母不要因为我不得差、六弟不中为虑，就是最大的安慰了！更何况儿子三次考差两次已中，六弟第一次去考场，年红还小，更不必放在心上。 ","date":"2023-06-03","objectID":"/posts/book/zengguofan_letter/:5:1","tags":["读书笔记"],"title":"[读书笔记] 《曾国藩家书》","uri":"/posts/book/zengguofan_letter/"},{"categories":["读书笔记"],"content":"致九弟·述弟为政优于带兵 沅弟左右： 昨天写好信后没有发，初五晚上玉六等回来，又收到了你的信，告诉我抚州收复的消息，说收复別的郡容易但是收复吉安很难。我本来就担心弟弟焦急，人一旦焦躁，那么心情就会不好，办事就无法妥当。我前年之所以那么荒废，也是由于心里焦躁。 你一定要平心静气，稳妥办事。 家里请的长沙园丁已到了吗？菜蔬长得茂盛吗？子侄们没有傲气吗？傲是凶德，情是衰气，二者都是败家的道路。要戒惰没有比早起更好的了，要戒傲没有比多走路少坐轿更好的了。希望弟弟留心。如果听到我有傲、惰的方面，也要写信来规劝。（同治元年七月十四日） ","date":"2023-06-03","objectID":"/posts/book/zengguofan_letter/:5:2","tags":["读书笔记"],"title":"[读书笔记] 《曾国藩家书》","uri":"/posts/book/zengguofan_letter/"},{"categories":["读书笔记"],"content":"交友篇 ","date":"2023-06-03","objectID":"/posts/book/zengguofan_letter/:6:0","tags":["读书笔记"],"title":"[读书笔记] 《曾国藩家书》","uri":"/posts/book/zengguofan_letter/"},{"categories":["读书笔记"],"content":"致诸弟·交友拜师宜专一 六弟、九弟今年依然在省城罗山兄处读书，很好。既然在那里读书，就不必送诗文给其他老师们看了，以表示自己有专门学习的老师。做任何事情都贵在专一，拜师学习不专，那么也没法有多大受益，交友不专，则只有泛泛之交却没有至交。心里有专一的宗旨，然后博来众长扩充自己的认识（知识）也不是不可以的。但是见异思迁，这山望着那山高，则万万不可。罗山兄很为刘霞仙、欧晓岑他们所推崇，有一个叫杨生的人，也可以说出他的大概，那么他真的是可以为人师表了。只可惜我不能经常与他在一起交流啊。 在省城里用钱，可以在家里支用，我不能另外再寄给弟弟了。我去年十一月二十日到京，那时没有折差回湖南，到十二月中旬才寄信。结果两个弟弟来信，写我糊涂，为何这样不检点？赵子舟和我同路，未曾有过一封信，那他的糊涂更如何？我自从去年五月底到十二月初不曾收到过一封家信，我在四川可以写信从京城寄到家中，难道家里的信不可以从京城转寄四川吗？这又该骂谁糊涂呢？凡动笔，不可以不检查约束。 ","date":"2023-06-03","objectID":"/posts/book/zengguofan_letter/:6:1","tags":["读书笔记"],"title":"[读书笔记] 《曾国藩家书》","uri":"/posts/book/zengguofan_letter/"},{"categories":["读书笔记"],"content":"致诸弟·交友须勤加来往 溢弟在料理家事的余闲，要经常看看《五种遗规》。 ","date":"2023-06-03","objectID":"/posts/book/zengguofan_letter/:6:2","tags":["读书笔记"],"title":"[读书笔记] 《曾国藩家书》","uri":"/posts/book/zengguofan_letter/"},{"categories":["读书笔记"],"content":"致诸弟·切勿占人便宜 澄候、子植、季洪三弟足下： 发卷所走各家，一半是我的老朋友，只是多次去打扰别人，我心里很不安。我自从去年到外面周游，到今天仍然感到遗憾。将来万一做外官，或做督、抚，或做学政，以前对我有过恩情的人，或者几百，或者几千，都像钓鱼的食饵，他如果到我的衙门上来，不答应他的要求，则未免太刻薄了，答应他的要求，则给他十倍的报偿，还不一定可以满足他的欲望。 因此自从兄长调到京城以来，至今八年不愿意轻易接受别人的恩惠，情愿別人占我的便宜，也绝不能去占別人的便宜。如果将来去做外官，京城之中没有人会责备我不报偿的。登弟在京城一年多，也基本上知道的，这次澄弟所收各家的情，既成事实就不去说它，以后任何事情都不可以占人半点便宜，不可轻易受人钱财，一定要牢记！ ","date":"2023-06-03","objectID":"/posts/book/zengguofan_letter/:6:3","tags":["读书笔记"],"title":"[读书笔记] 《曾国藩家书》","uri":"/posts/book/zengguofan_letter/"},{"categories":["读书笔记"],"content":"理财篇 ","date":"2023-06-03","objectID":"/posts/book/zengguofan_letter/:7:0","tags":["读书笔记"],"title":"[读书笔记] 《曾国藩家书》","uri":"/posts/book/zengguofan_letter/"},{"categories":["读书笔记"],"content":"禀祖父母·先馈赠亲戚族人 孙儿之所以急于送赠，有两个原因： 一是我家气运太盛，不可不格外小心，要注意持盈保泰的道理。旧账还请，好处最多，害怕盈到极点生亏损，留点债不还清，虽有些美中不足，但也是处于乐处的办法。 二是亲威们都穷，而年老的，现在不稍微资助，那以后不知怎么样。自从孙儿进入京城后，如彭满野普祖、彭王姑母、欧阳岳祖母、江通十第，已去世好几个。再过几年，就算我们想要送赠，还不知道怎样！家里的债，今天虽不还，以后还可以还，送人的事，如果今天不做，以后便只有后悔了，这两点是孙儿的愚见。 然而孙儿年轻不懂事，没有深谋远虑，一切求祖父、父亲、叔父做主，孙儿不敢自己专权。这笔银子等欧阳小岑回湖南时，孙儿寄回一大箱。衣物银两一起奇到那里，孙儿负担一半车费，那时再有信回。孙儿谨禀。（道光二十四年三月初十日） ","date":"2023-06-03","objectID":"/posts/book/zengguofan_letter/:7:1","tags":["读书笔记"],"title":"[读书笔记] 《曾国藩家书》","uri":"/posts/book/zengguofan_letter/"},{"categories":["读书笔记"],"content":"致四弟·送银子共患难者 同乡京官，今年冬天的炭费，还要照旧放送。昨天让李翥汉回湖南，给罗家送二百两、李家二百两、刘家一百两，他们以前曾经和我共患难。之前寄弟弟那边的一千两，数量不多，自有两江总督以来，尚未有如此薄待胞弟的。但是身处乱世，钱越多患就越大，兄长还有弟弟家都不适合多存现钱，每年够一年的用度，就算是天下的大富翁，人间的大福星了。家中要想兴旺，全靠有贤子弟，如果子弟不贤不才，就算多积钱、积谷、积产、积书、积衣，也是空的。 子弟的贤与否，六分出于天生，四分在于家教。我家世代都有明德明训，特别是星冈公的教训，尤其应当道守牢记，近来我将星冈公的家规编成八句话：“书蔬猪鱼，考早扫宝，常说常行，八者都好，地命医理，僧巫祈祷，留客久住，六者俱恼。” 因为星冈公对于风水先生、算命的、郎中、和尚、巫师等五种人看见就恼火，即使是亲友、远容，住久了他也恼火。 这“八好”“六恼”，我们家要世代遵守，永为家训，子孙虽然愚笨，也一定能使他们在这个范围内。（同治五年十二月初六日） ","date":"2023-06-03","objectID":"/posts/book/zengguofan_letter/:7:2","tags":["读书笔记"],"title":"[读书笔记] 《曾国藩家书》","uri":"/posts/book/zengguofan_letter/"},{"categories":["读书笔记"],"content":" 一个爸爸会说：“贪财乃万恶之源。”而另一个爸爸却说：“贫穷才是万恶之本。” 两个不同的观点造就不同的人生； 一个人的观点对他的一生影响巨大； 选择不同，命运也会不同； ","date":"2023-03-19","objectID":"/posts/book/poordadrichdad/:0:0","tags":["经济学"],"title":"[读书笔记] 《穷爸爸富爸爸》","uri":"/posts/book/poordadrichdad/"},{"categories":["读书笔记"],"content":"关于书 《微习惯-成就卓越自我管理的法则》 武君 ","date":"2023-03-18","objectID":"/posts/book/minihabits/:1:0","tags":["微习惯"],"title":"[读书笔记] 《微习惯-成就卓越自我管理的法则》","uri":"/posts/book/minihabits/"},{"categories":["读书笔记"],"content":"笔记 本书通过分类，阐述了涉及多个方向的微习惯，并在每个分类下引用了不同的实例作为参考样例，证明不同微习惯带给我们的正向效果，侧重于表达微习惯的作用。 但在如何培养微习惯上，没有过多的阐述； 通过本书目录，可以快速了解不同分类下，作者建议具备的微习惯； 本书可以作为一本了解微习惯的参考书； ","date":"2023-03-18","objectID":"/posts/book/minihabits/:1:1","tags":["微习惯"],"title":"[读书笔记] 《微习惯-成就卓越自我管理的法则》","uri":"/posts/book/minihabits/"},{"categories":["读书笔记"],"content":"内容简介 微习惯是一种非常微小的积极行为，你需要每天强迫自己完成它。 微习惯太小，正是因为这个特性，它不会给你造成任何负担，因此成了极具优势的习惯养成策略。 本书阐述了人一生要养成的成功微习惯、工作微习惯、思考微习惯、礼仪微习惯、社交微习惯、生活微习惯等，提出了培养良好微习惯的方法和窍门， 主题选择具有时代感和生活性，对自我管理具有很强的指导意义。当你翻开本书，了解了这些重要的人生习惯后，再根据书中的指导，持之以恒地去培养好习惯，相信一定能收获高效能的工作和高品质的生活，你的人生也会因此而改变。 ","date":"2023-03-18","objectID":"/posts/book/minihabits/:2:0","tags":["微习惯"],"title":"[读书笔记] 《微习惯-成就卓越自我管理的法则》","uri":"/posts/book/minihabits/"},{"categories":["读书笔记"],"content":"前言 习惯具有一种能左右人命运、决定人生成败的巨大力量。 古罗马诗人奥维德有一句经典名言：“没有什么比习惯的力量更强大。〞美国著名成功学大师拿破仑•希尔也说：“习惯决定成败。” 习惯是由一个人行为的累积而形成的某些固定行为，是人们生活中习以为常的行为举止。 习惯在我们不知不觉反复重复的过程中，会逐渐变成我们本能的一部分。而微习惯是-种非常微小的积极行为，你需要每天强迫自己完成它。 微习惯太小，小到不会给你造成任何负担，而且具有超强的“欺骗性”它也因此成了极具优势的习惯养成策略。 著名的贝尔实验室和 3M 公司曾经过近10年的研究，终于得出了一条令人吃惊的结论：使个人比其他人更优秀的最重要因素，不是智商高，也不是良好的社交技巧，而是具备了良好的习惯。只要培养出良好的习惯并在实践中运用，发挥出;自己巨大的潜能，你就能从平凡走向卓越。 从现在起，不要再抱怨命运没有给自己机会，而要问自己有没有养成能够把握住机会的可惯。很多人并不从白身的情性因素中寻找原因，总是终日喋喋不休于外事外物对自身的影响，其实这对改善自身的素质百分之百的无济于事。 请你加快行动的步伐吧，切从自我做起从点滴做起，从培养良好的习惯做起•微习惯策略的科学原理表明了人们无法长期坚持大多数主流成长策略的原因，也揭示了人们长期坚持微习惯策略的可能性。人们无法让改变的效果持久时，往往认为原因在于自己但其实有问题的并不是他们本身，而是他们采用的策略。 本书阐述了人一生要养成的成功微习惯、工作微习惯、社交微习惯思考微习惯、时问微习惯、情绪微习惯、礼仪微习惯、生活徵习惯等，提出了培养良好微习惯的方法和窍门，主题选择具有时代感和生活性，对自我管理具有很强的指导意义。 一位哲人说过：“播下一种思想，收获一种行为，播下一种行为，收获一种习惯；播下一种习惯，收获一种性格；播下一种性格，收获一种命运。” 要想不断提升自己的素质，在人生中取得成功，就要在各个方面养成良好的习惯。当你翻开本书，了解了这些重婴的人生习慨后，再根据书中的指导，持之以恒地去培养好习惯，相信你一定能收获高效能的工作和高品质的生活，你的人生也会因此而改变。 ","date":"2023-03-18","objectID":"/posts/book/minihabits/:3:0","tags":["微习惯"],"title":"[读书笔记] 《微习惯-成就卓越自我管理的法则》","uri":"/posts/book/minihabits/"},{"categories":["读书笔记"],"content":"第一章 微习惯 ","date":"2023-03-18","objectID":"/posts/book/minihabits/:4:0","tags":["微习惯"],"title":"[读书笔记] 《微习惯-成就卓越自我管理的法则》","uri":"/posts/book/minihabits/"},{"categories":["读书笔记"],"content":"成就卓越自我管理的法则 ","date":"2023-03-18","objectID":"/posts/book/minihabits/:4:1","tags":["微习惯"],"title":"[读书笔记] 《微习惯-成就卓越自我管理的法则》","uri":"/posts/book/minihabits/"},{"categories":["读书笔记"],"content":"习惯是什么 ","date":"2023-03-18","objectID":"/posts/book/minihabits/:4:2","tags":["微习惯"],"title":"[读书笔记] 《微习惯-成就卓越自我管理的法则》","uri":"/posts/book/minihabits/"},{"categories":["读书笔记"],"content":"微习惯的力量无比巨大 ","date":"2023-03-18","objectID":"/posts/book/minihabits/:4:3","tags":["微习惯"],"title":"[读书笔记] 《微习惯-成就卓越自我管理的法则》","uri":"/posts/book/minihabits/"},{"categories":["读书笔记"],"content":"成功的习惯重在培养 ","date":"2023-03-18","objectID":"/posts/book/minihabits/:4:4","tags":["微习惯"],"title":"[读书笔记] 《微习惯-成就卓越自我管理的法则》","uri":"/posts/book/minihabits/"},{"categories":["读书笔记"],"content":"卓卓越是一种习惯，平庸也是一种习惯 ","date":"2023-03-18","objectID":"/posts/book/minihabits/:4:5","tags":["微习惯"],"title":"[读书笔记] 《微习惯-成就卓越自我管理的法则》","uri":"/posts/book/minihabits/"},{"categories":["读书笔记"],"content":"第二章 成功微习惯 ","date":"2023-03-18","objectID":"/posts/book/minihabits/:5:0","tags":["微习惯"],"title":"[读书笔记] 《微习惯-成就卓越自我管理的法则》","uri":"/posts/book/minihabits/"},{"categories":["读书笔记"],"content":"每天进步一点点的无负担自律策略 ","date":"2023-03-18","objectID":"/posts/book/minihabits/:5:1","tags":["微习惯"],"title":"[读书笔记] 《微习惯-成就卓越自我管理的法则》","uri":"/posts/book/minihabits/"},{"categories":["读书笔记"],"content":"不为失败找借口 ","date":"2023-03-18","objectID":"/posts/book/minihabits/:5:2","tags":["微习惯"],"title":"[读书笔记] 《微习惯-成就卓越自我管理的法则》","uri":"/posts/book/minihabits/"},{"categories":["读书笔记"],"content":"珍惜每一分钟 ","date":"2023-03-18","objectID":"/posts/book/minihabits/:5:3","tags":["微习惯"],"title":"[读书笔记] 《微习惯-成就卓越自我管理的法则》","uri":"/posts/book/minihabits/"},{"categories":["读书笔记"],"content":"每天学一点东西 ","date":"2023-03-18","objectID":"/posts/book/minihabits/:5:4","tags":["微习惯"],"title":"[读书笔记] 《微习惯-成就卓越自我管理的法则》","uri":"/posts/book/minihabits/"},{"categories":["读书笔记"],"content":"相信你自己 ","date":"2023-03-18","objectID":"/posts/book/minihabits/:5:5","tags":["微习惯"],"title":"[读书笔记] 《微习惯-成就卓越自我管理的法则》","uri":"/posts/book/minihabits/"},{"categories":["读书笔记"],"content":"不浪费每一分钱 ","date":"2023-03-18","objectID":"/posts/book/minihabits/:5:6","tags":["微习惯"],"title":"[读书笔记] 《微习惯-成就卓越自我管理的法则》","uri":"/posts/book/minihabits/"},{"categories":["读书笔记"],"content":"独立自主的习惯 ","date":"2023-03-18","objectID":"/posts/book/minihabits/:5:7","tags":["微习惯"],"title":"[读书笔记] 《微习惯-成就卓越自我管理的法则》","uri":"/posts/book/minihabits/"},{"categories":["读书笔记"],"content":"培养不轻言放弃的习惯 ","date":"2023-03-18","objectID":"/posts/book/minihabits/:5:8","tags":["微习惯"],"title":"[读书笔记] 《微习惯-成就卓越自我管理的法则》","uri":"/posts/book/minihabits/"},{"categories":["读书笔记"],"content":"耐得住寂寞 ","date":"2023-03-18","objectID":"/posts/book/minihabits/:5:9","tags":["微习惯"],"title":"[读书笔记] 《微习惯-成就卓越自我管理的法则》","uri":"/posts/book/minihabits/"},{"categories":["读书笔记"],"content":"每天自省5分钟### ","date":"2023-03-18","objectID":"/posts/book/minihabits/:5:10","tags":["微习惯"],"title":"[读书笔记] 《微习惯-成就卓越自我管理的法则》","uri":"/posts/book/minihabits/"},{"categories":["读书笔记"],"content":"第三章 工作微习惯 ","date":"2023-03-18","objectID":"/posts/book/minihabits/:6:0","tags":["微习惯"],"title":"[读书笔记] 《微习惯-成就卓越自我管理的法则》","uri":"/posts/book/minihabits/"},{"categories":["读书笔记"],"content":"做好每一件小事的职场精进法 ","date":"2023-03-18","objectID":"/posts/book/minihabits/:6:1","tags":["微习惯"],"title":"[读书笔记] 《微习惯-成就卓越自我管理的法则》","uri":"/posts/book/minihabits/"},{"categories":["读书笔记"],"content":"坚持记好工作日记 ","date":"2023-03-18","objectID":"/posts/book/minihabits/:6:2","tags":["微习惯"],"title":"[读书笔记] 《微习惯-成就卓越自我管理的法则》","uri":"/posts/book/minihabits/"},{"categories":["读书笔记"],"content":"对重要文件和档案做备份 ","date":"2023-03-18","objectID":"/posts/book/minihabits/:6:3","tags":["微习惯"],"title":"[读书笔记] 《微习惯-成就卓越自我管理的法则》","uri":"/posts/book/minihabits/"},{"categories":["读书笔记"],"content":"比别人多做一点 ","date":"2023-03-18","objectID":"/posts/book/minihabits/:6:4","tags":["微习惯"],"title":"[读书笔记] 《微习惯-成就卓越自我管理的法则》","uri":"/posts/book/minihabits/"},{"categories":["读书笔记"],"content":"勇于承认错误 ","date":"2023-03-18","objectID":"/posts/book/minihabits/:6:5","tags":["微习惯"],"title":"[读书笔记] 《微习惯-成就卓越自我管理的法则》","uri":"/posts/book/minihabits/"},{"categories":["读书笔记"],"content":"从不忽视关键细节 ","date":"2023-03-18","objectID":"/posts/book/minihabits/:6:6","tags":["微习惯"],"title":"[读书笔记] 《微习惯-成就卓越自我管理的法则》","uri":"/posts/book/minihabits/"},{"categories":["读书笔记"],"content":"不公开批评他大 ","date":"2023-03-18","objectID":"/posts/book/minihabits/:6:7","tags":["微习惯"],"title":"[读书笔记] 《微习惯-成就卓越自我管理的法则》","uri":"/posts/book/minihabits/"},{"categories":["读书笔记"],"content":"不占公司的小便宜 ","date":"2023-03-18","objectID":"/posts/book/minihabits/:6:8","tags":["微习惯"],"title":"[读书笔记] 《微习惯-成就卓越自我管理的法则》","uri":"/posts/book/minihabits/"},{"categories":["读书笔记"],"content":"每天补充专业知识 ","date":"2023-03-18","objectID":"/posts/book/minihabits/:6:9","tags":["微习惯"],"title":"[读书笔记] 《微习惯-成就卓越自我管理的法则》","uri":"/posts/book/minihabits/"},{"categories":["读书笔记"],"content":"提高工作效率从整理办公桌开始 ","date":"2023-03-18","objectID":"/posts/book/minihabits/:6:10","tags":["微习惯"],"title":"[读书笔记] 《微习惯-成就卓越自我管理的法则》","uri":"/posts/book/minihabits/"},{"categories":["读书笔记"],"content":"只要还能坚持上班就不请假### ","date":"2023-03-18","objectID":"/posts/book/minihabits/:6:11","tags":["微习惯"],"title":"[读书笔记] 《微习惯-成就卓越自我管理的法则》","uri":"/posts/book/minihabits/"},{"categories":["读书笔记"],"content":"第四章 社交微习惯 ","date":"2023-03-18","objectID":"/posts/book/minihabits/:7:0","tags":["微习惯"],"title":"[读书笔记] 《微习惯-成就卓越自我管理的法则》","uri":"/posts/book/minihabits/"},{"categories":["读书笔记"],"content":"管好自己赢得别人的交际小技巧 ","date":"2023-03-18","objectID":"/posts/book/minihabits/:7:1","tags":["微习惯"],"title":"[读书笔记] 《微习惯-成就卓越自我管理的法则》","uri":"/posts/book/minihabits/"},{"categories":["读书笔记"],"content":"换位恩考 ","date":"2023-03-18","objectID":"/posts/book/minihabits/:7:2","tags":["微习惯"],"title":"[读书笔记] 《微习惯-成就卓越自我管理的法则》","uri":"/posts/book/minihabits/"},{"categories":["读书笔记"],"content":"积极倾听 ","date":"2023-03-18","objectID":"/posts/book/minihabits/:7:3","tags":["微习惯"],"title":"[读书笔记] 《微习惯-成就卓越自我管理的法则》","uri":"/posts/book/minihabits/"},{"categories":["读书笔记"],"content":"与人为善 ","date":"2023-03-18","objectID":"/posts/book/minihabits/:7:4","tags":["微习惯"],"title":"[读书笔记] 《微习惯-成就卓越自我管理的法则》","uri":"/posts/book/minihabits/"},{"categories":["读书笔记"],"content":"善于发现别人的优点 ","date":"2023-03-18","objectID":"/posts/book/minihabits/:7:5","tags":["微习惯"],"title":"[读书笔记] 《微习惯-成就卓越自我管理的法则》","uri":"/posts/book/minihabits/"},{"categories":["读书笔记"],"content":"赞美的习惯 ","date":"2023-03-18","objectID":"/posts/book/minihabits/:7:6","tags":["微习惯"],"title":"[读书笔记] 《微习惯-成就卓越自我管理的法则》","uri":"/posts/book/minihabits/"},{"categories":["读书笔记"],"content":"善于用语言技巧建立融洽的人际关系 ","date":"2023-03-18","objectID":"/posts/book/minihabits/:7:7","tags":["微习惯"],"title":"[读书笔记] 《微习惯-成就卓越自我管理的法则》","uri":"/posts/book/minihabits/"},{"categories":["读书笔记"],"content":"在任何时候都留有余地 ","date":"2023-03-18","objectID":"/posts/book/minihabits/:7:8","tags":["微习惯"],"title":"[读书笔记] 《微习惯-成就卓越自我管理的法则》","uri":"/posts/book/minihabits/"},{"categories":["读书笔记"],"content":"只能修正自己，不能修正别人### ","date":"2023-03-18","objectID":"/posts/book/minihabits/:7:9","tags":["微习惯"],"title":"[读书笔记] 《微习惯-成就卓越自我管理的法则》","uri":"/posts/book/minihabits/"},{"categories":["读书笔记"],"content":"第五章 思考微习惯 ","date":"2023-03-18","objectID":"/posts/book/minihabits/:8:0","tags":["微习惯"],"title":"[读书笔记] 《微习惯-成就卓越自我管理的法则》","uri":"/posts/book/minihabits/"},{"categories":["读书笔记"],"content":"大处着眼小处着手的精准思维 ","date":"2023-03-18","objectID":"/posts/book/minihabits/:8:1","tags":["微习惯"],"title":"[读书笔记] 《微习惯-成就卓越自我管理的法则》","uri":"/posts/book/minihabits/"},{"categories":["读书笔记"],"content":"先找靶心后射击 ","date":"2023-03-18","objectID":"/posts/book/minihabits/:8:2","tags":["微习惯"],"title":"[读书笔记] 《微习惯-成就卓越自我管理的法则》","uri":"/posts/book/minihabits/"},{"categories":["读书笔记"],"content":"抓住问题的关键点 ","date":"2023-03-18","objectID":"/posts/book/minihabits/:8:3","tags":["微习惯"],"title":"[读书笔记] 《微习惯-成就卓越自我管理的法则》","uri":"/posts/book/minihabits/"},{"categories":["读书笔记"],"content":"在变化中化解问题 ","date":"2023-03-18","objectID":"/posts/book/minihabits/:8:4","tags":["微习惯"],"title":"[读书笔记] 《微习惯-成就卓越自我管理的法则》","uri":"/posts/book/minihabits/"},{"categories":["读书笔记"],"content":"用吃牛排的方式解决问题 ","date":"2023-03-18","objectID":"/posts/book/minihabits/:8:5","tags":["微习惯"],"title":"[读书笔记] 《微习惯-成就卓越自我管理的法则》","uri":"/posts/book/minihabits/"},{"categories":["读书笔记"],"content":"把问题消灭在萌芽状态 ","date":"2023-03-18","objectID":"/posts/book/minihabits/:8:6","tags":["微习惯"],"title":"[读书笔记] 《微习惯-成就卓越自我管理的法则》","uri":"/posts/book/minihabits/"},{"categories":["读书笔记"],"content":"扔掉 “可是”这个借口 ","date":"2023-03-18","objectID":"/posts/book/minihabits/:8:7","tags":["微习惯"],"title":"[读书笔记] 《微习惯-成就卓越自我管理的法则》","uri":"/posts/book/minihabits/"},{"categories":["读书笔记"],"content":"拒绝说 “办不到” ","date":"2023-03-18","objectID":"/posts/book/minihabits/:8:8","tags":["微习惯"],"title":"[读书笔记] 《微习惯-成就卓越自我管理的法则》","uri":"/posts/book/minihabits/"},{"categories":["读书笔记"],"content":"“此路不通”就换方法 ","date":"2023-03-18","objectID":"/posts/book/minihabits/:8:9","tags":["微习惯"],"title":"[读书笔记] 《微习惯-成就卓越自我管理的法则》","uri":"/posts/book/minihabits/"},{"categories":["读书笔记"],"content":"遇事别钻“牛角尖”### ","date":"2023-03-18","objectID":"/posts/book/minihabits/:8:10","tags":["微习惯"],"title":"[读书笔记] 《微习惯-成就卓越自我管理的法则》","uri":"/posts/book/minihabits/"},{"categories":["读书笔记"],"content":"第六章 时间微习惯 ","date":"2023-03-18","objectID":"/posts/book/minihabits/:9:0","tags":["微习惯"],"title":"[读书笔记] 《微习惯-成就卓越自我管理的法则》","uri":"/posts/book/minihabits/"},{"categories":["读书笔记"],"content":"高效利用每一点脑力的时问整理术 ","date":"2023-03-18","objectID":"/posts/book/minihabits/:9:1","tags":["微习惯"],"title":"[读书笔记] 《微习惯-成就卓越自我管理的法则》","uri":"/posts/book/minihabits/"},{"categories":["读书笔记"],"content":"守时 ","date":"2023-03-18","objectID":"/posts/book/minihabits/:9:2","tags":["微习惯"],"title":"[读书笔记] 《微习惯-成就卓越自我管理的法则》","uri":"/posts/book/minihabits/"},{"categories":["读书笔记"],"content":"做个零碎时间的 ","date":"2023-03-18","objectID":"/posts/book/minihabits/:9:3","tags":["微习惯"],"title":"[读书笔记] 《微习惯-成就卓越自我管理的法则》","uri":"/posts/book/minihabits/"},{"categories":["读书笔记"],"content":"“焊接工” ","date":"2023-03-18","objectID":"/posts/book/minihabits/:9:4","tags":["微习惯"],"title":"[读书笔记] 《微习惯-成就卓越自我管理的法则》","uri":"/posts/book/minihabits/"},{"categories":["读书笔记"],"content":"挤出时问的 ","date":"2023-03-18","objectID":"/posts/book/minihabits/:9:5","tags":["微习惯"],"title":"[读书笔记] 《微习惯-成就卓越自我管理的法则》","uri":"/posts/book/minihabits/"},{"categories":["读书笔记"],"content":"“油水” ","date":"2023-03-18","objectID":"/posts/book/minihabits/:9:6","tags":["微习惯"],"title":"[读书笔记] 《微习惯-成就卓越自我管理的法则》","uri":"/posts/book/minihabits/"},{"categories":["读书笔记"],"content":"找到躲在角落里的时间 ","date":"2023-03-18","objectID":"/posts/book/minihabits/:9:7","tags":["微习惯"],"title":"[读书笔记] 《微习惯-成就卓越自我管理的法则》","uri":"/posts/book/minihabits/"},{"categories":["读书笔记"],"content":"抓住闲暇时光 ","date":"2023-03-18","objectID":"/posts/book/minihabits/:9:8","tags":["微习惯"],"title":"[读书笔记] 《微习惯-成就卓越自我管理的法则》","uri":"/posts/book/minihabits/"},{"categories":["读书笔记"],"content":"去行动吧！不要再拖延了 ","date":"2023-03-18","objectID":"/posts/book/minihabits/:9:9","tags":["微习惯"],"title":"[读书笔记] 《微习惯-成就卓越自我管理的法则》","uri":"/posts/book/minihabits/"},{"categories":["读书笔记"],"content":"一次做好一件事 ","date":"2023-03-18","objectID":"/posts/book/minihabits/:9:10","tags":["微习惯"],"title":"[读书笔记] 《微习惯-成就卓越自我管理的法则》","uri":"/posts/book/minihabits/"},{"categories":["读书笔记"],"content":"运用 20/80 法则 ","date":"2023-03-18","objectID":"/posts/book/minihabits/:9:11","tags":["微习惯"],"title":"[读书笔记] 《微习惯-成就卓越自我管理的法则》","uri":"/posts/book/minihabits/"},{"categories":["读书笔记"],"content":"充分利用好你的最佳时间 ","date":"2023-03-18","objectID":"/posts/book/minihabits/:9:12","tags":["微习惯"],"title":"[读书笔记] 《微习惯-成就卓越自我管理的法则》","uri":"/posts/book/minihabits/"},{"categories":["读书笔记"],"content":"用好 “神奇的三小时”### ","date":"2023-03-18","objectID":"/posts/book/minihabits/:9:13","tags":["微习惯"],"title":"[读书笔记] 《微习惯-成就卓越自我管理的法则》","uri":"/posts/book/minihabits/"},{"categories":["读书笔记"],"content":"第七章 情绪微习惯 ","date":"2023-03-18","objectID":"/posts/book/minihabits/:10:0","tags":["微习惯"],"title":"[读书笔记] 《微习惯-成就卓越自我管理的法则》","uri":"/posts/book/minihabits/"},{"categories":["读书笔记"],"content":"轻松摆脱负面小情绪的情商养成法 ","date":"2023-03-18","objectID":"/posts/book/minihabits/:10:1","tags":["微习惯"],"title":"[读书笔记] 《微习惯-成就卓越自我管理的法则》","uri":"/posts/book/minihabits/"},{"categories":["读书笔记"],"content":"将嫉妒转化为动力 ","date":"2023-03-18","objectID":"/posts/book/minihabits/:10:2","tags":["微习惯"],"title":"[读书笔记] 《微习惯-成就卓越自我管理的法则》","uri":"/posts/book/minihabits/"},{"categories":["读书笔记"],"content":"不陷人忧虑的沼泽地 ","date":"2023-03-18","objectID":"/posts/book/minihabits/:10:3","tags":["微习惯"],"title":"[读书笔记] 《微习惯-成就卓越自我管理的法则》","uri":"/posts/book/minihabits/"},{"categories":["读书笔记"],"content":"不被回忆所控制 ","date":"2023-03-18","objectID":"/posts/book/minihabits/:10:4","tags":["微习惯"],"title":"[读书笔记] 《微习惯-成就卓越自我管理的法则》","uri":"/posts/book/minihabits/"},{"categories":["读书笔记"],"content":"正确对待压力 ","date":"2023-03-18","objectID":"/posts/book/minihabits/:10:5","tags":["微习惯"],"title":"[读书笔记] 《微习惯-成就卓越自我管理的法则》","uri":"/posts/book/minihabits/"},{"categories":["读书笔记"],"content":"永不抱怨 ","date":"2023-03-18","objectID":"/posts/book/minihabits/:10:6","tags":["微习惯"],"title":"[读书笔记] 《微习惯-成就卓越自我管理的法则》","uri":"/posts/book/minihabits/"},{"categories":["读书笔记"],"content":"用运动来驱散心头的郁闷 ","date":"2023-03-18","objectID":"/posts/book/minihabits/:10:7","tags":["微习惯"],"title":"[读书笔记] 《微习惯-成就卓越自我管理的法则》","uri":"/posts/book/minihabits/"},{"categories":["读书笔记"],"content":"情绪低落时不妨假装一下快乐 ","date":"2023-03-18","objectID":"/posts/book/minihabits/:10:8","tags":["微习惯"],"title":"[读书笔记] 《微习惯-成就卓越自我管理的法则》","uri":"/posts/book/minihabits/"},{"categories":["读书笔记"],"content":"用幽默和微笑来战胜不良情绪 ","date":"2023-03-18","objectID":"/posts/book/minihabits/:10:9","tags":["微习惯"],"title":"[读书笔记] 《微习惯-成就卓越自我管理的法则》","uri":"/posts/book/minihabits/"},{"categories":["读书笔记"],"content":"不生气等于消除坏情绪的源头 ","date":"2023-03-18","objectID":"/posts/book/minihabits/:10:10","tags":["微习惯"],"title":"[读书笔记] 《微习惯-成就卓越自我管理的法则》","uri":"/posts/book/minihabits/"},{"categories":["读书笔记"],"content":"感到压抑时，让自己静坐在阳光下 ","date":"2023-03-18","objectID":"/posts/book/minihabits/:10:11","tags":["微习惯"],"title":"[读书笔记] 《微习惯-成就卓越自我管理的法则》","uri":"/posts/book/minihabits/"},{"categories":["读书笔记"],"content":"第八章 礼仪微习惯 ","date":"2023-03-18","objectID":"/posts/book/minihabits/:11:0","tags":["微习惯"],"title":"[读书笔记] 《微习惯-成就卓越自我管理的法则》","uri":"/posts/book/minihabits/"},{"categories":["读书笔记"],"content":"举手投足尽显风度的行为细节 ","date":"2023-03-18","objectID":"/posts/book/minihabits/:11:1","tags":["微习惯"],"title":"[读书笔记] 《微习惯-成就卓越自我管理的法则》","uri":"/posts/book/minihabits/"},{"categories":["读书笔记"],"content":"举于投足都会影响你的社交效果 ","date":"2023-03-18","objectID":"/posts/book/minihabits/:11:2","tags":["微习惯"],"title":"[读书笔记] 《微习惯-成就卓越自我管理的法则》","uri":"/posts/book/minihabits/"},{"categories":["读书笔记"],"content":"站立如松，行动如风 ","date":"2023-03-18","objectID":"/posts/book/minihabits/:11:3","tags":["微习惯"],"title":"[读书笔记] 《微习惯-成就卓越自我管理的法则》","uri":"/posts/book/minihabits/"},{"categories":["读书笔记"],"content":"坐姿从容淡定，卧姿优雅大方 ","date":"2023-03-18","objectID":"/posts/book/minihabits/:11:4","tags":["微习惯"],"title":"[读书笔记] 《微习惯-成就卓越自我管理的法则》","uri":"/posts/book/minihabits/"},{"categories":["读书笔记"],"content":"从掌心开始你们的交流 ","date":"2023-03-18","objectID":"/posts/book/minihabits/:11:5","tags":["微习惯"],"title":"[读书笔记] 《微习惯-成就卓越自我管理的法则》","uri":"/posts/book/minihabits/"},{"categories":["读书笔记"],"content":"-握手 ","date":"2023-03-18","objectID":"/posts/book/minihabits/:11:6","tags":["微习惯"],"title":"[读书笔记] 《微习惯-成就卓越自我管理的法则》","uri":"/posts/book/minihabits/"},{"categories":["读书笔记"],"content":"交换名片是继续联系的纽带 ","date":"2023-03-18","objectID":"/posts/book/minihabits/:11:7","tags":["微习惯"],"title":"[读书笔记] 《微习惯-成就卓越自我管理的法则》","uri":"/posts/book/minihabits/"},{"categories":["读书笔记"],"content":"日常沟通礼仪规范 ","date":"2023-03-18","objectID":"/posts/book/minihabits/:11:8","tags":["微习惯"],"title":"[读书笔记] 《微习惯-成就卓越自我管理的法则》","uri":"/posts/book/minihabits/"},{"categories":["读书笔记"],"content":"得体地问候为你赚分 ","date":"2023-03-18","objectID":"/posts/book/minihabits/:11:9","tags":["微习惯"],"title":"[读书笔记] 《微习惯-成就卓越自我管理的法则》","uri":"/posts/book/minihabits/"},{"categories":["读书笔记"],"content":"通过电话传递你的彬彬礼仪 ","date":"2023-03-18","objectID":"/posts/book/minihabits/:11:10","tags":["微习惯"],"title":"[读书笔记] 《微习惯-成就卓越自我管理的法则》","uri":"/posts/book/minihabits/"},{"categories":["读书笔记"],"content":"电话礼仪应注意的五个事项 ","date":"2023-03-18","objectID":"/posts/book/minihabits/:11:11","tags":["微习惯"],"title":"[读书笔记] 《微习惯-成就卓越自我管理的法则》","uri":"/posts/book/minihabits/"},{"categories":["读书笔记"],"content":"魅力礼仪养成四法则 ","date":"2023-03-18","objectID":"/posts/book/minihabits/:11:12","tags":["微习惯"],"title":"[读书笔记] 《微习惯-成就卓越自我管理的法则》","uri":"/posts/book/minihabits/"},{"categories":["读书笔记"],"content":"身送七步，不可忘记的商务礼仪 ","date":"2023-03-18","objectID":"/posts/book/minihabits/:11:13","tags":["微习惯"],"title":"[读书笔记] 《微习惯-成就卓越自我管理的法则》","uri":"/posts/book/minihabits/"},{"categories":["读书笔记"],"content":"别让小细节毁了你的形象 ","date":"2023-03-18","objectID":"/posts/book/minihabits/:11:14","tags":["微习惯"],"title":"[读书笔记] 《微习惯-成就卓越自我管理的法则》","uri":"/posts/book/minihabits/"},{"categories":["读书笔记"],"content":"第九章 生活微习惯 ","date":"2023-03-18","objectID":"/posts/book/minihabits/:12:0","tags":["微习惯"],"title":"[读书笔记] 《微习惯-成就卓越自我管理的法则》","uri":"/posts/book/minihabits/"},{"categories":["读书笔记"],"content":"让生活更有仪式感和节奏感的日常小窍门 ","date":"2023-03-18","objectID":"/posts/book/minihabits/:12:1","tags":["微习惯"],"title":"[读书笔记] 《微习惯-成就卓越自我管理的法则》","uri":"/posts/book/minihabits/"},{"categories":["读书笔记"],"content":"大多数疾病和生活方式有关 ","date":"2023-03-18","objectID":"/posts/book/minihabits/:12:2","tags":["微习惯"],"title":"[读书笔记] 《微习惯-成就卓越自我管理的法则》","uri":"/posts/book/minihabits/"},{"categories":["读书笔记"],"content":"养成运动的好习惯 ","date":"2023-03-18","objectID":"/posts/book/minihabits/:12:3","tags":["微习惯"],"title":"[读书笔记] 《微习惯-成就卓越自我管理的法则》","uri":"/posts/book/minihabits/"},{"categories":["读书笔记"],"content":"只吃健康的食物 ","date":"2023-03-18","objectID":"/posts/book/minihabits/:12:4","tags":["微习惯"],"title":"[读书笔记] 《微习惯-成就卓越自我管理的法则》","uri":"/posts/book/minihabits/"},{"categories":["读书笔记"],"content":"拥有良好的睡眠 ","date":"2023-03-18","objectID":"/posts/book/minihabits/:12:5","tags":["微习惯"],"title":"[读书笔记] 《微习惯-成就卓越自我管理的法则》","uri":"/posts/book/minihabits/"},{"categories":["读书笔记"],"content":"主动一些，不要等累了再休息 ","date":"2023-03-18","objectID":"/posts/book/minihabits/:12:6","tags":["微习惯"],"title":"[读书笔记] 《微习惯-成就卓越自我管理的法则》","uri":"/posts/book/minihabits/"},{"categories":["读书笔记"],"content":"别向生物钟下“战书〞 ","date":"2023-03-18","objectID":"/posts/book/minihabits/:12:7","tags":["微习惯"],"title":"[读书笔记] 《微习惯-成就卓越自我管理的法则》","uri":"/posts/book/minihabits/"},{"categories":["读书笔记"],"content":"杜绝坏的生活习惯 ","date":"2023-03-18","objectID":"/posts/book/minihabits/:12:8","tags":["微习惯"],"title":"[读书笔记] 《微习惯-成就卓越自我管理的法则》","uri":"/posts/book/minihabits/"},{"categories":["读书笔记"],"content":"每天抽点时问，独自去散步 ","date":"2023-03-18","objectID":"/posts/book/minihabits/:12:9","tags":["微习惯"],"title":"[读书笔记] 《微习惯-成就卓越自我管理的法则》","uri":"/posts/book/minihabits/"},{"categories":["读书笔记"],"content":"睡前喝一杯浓香的牛奶 ","date":"2023-03-18","objectID":"/posts/book/minihabits/:12:10","tags":["微习惯"],"title":"[读书笔记] 《微习惯-成就卓越自我管理的法则》","uri":"/posts/book/minihabits/"},{"categories":["读书笔记"],"content":"养一盆绿色植物，把自然请进室内 ","date":"2023-03-18","objectID":"/posts/book/minihabits/:12:11","tags":["微习惯"],"title":"[读书笔记] 《微习惯-成就卓越自我管理的法则》","uri":"/posts/book/minihabits/"},{"categories":["读书笔记"],"content":"选择一天只吃水果，给身体排排毒 ","date":"2023-03-18","objectID":"/posts/book/minihabits/:12:12","tags":["微习惯"],"title":"[读书笔记] 《微习惯-成就卓越自我管理的法则》","uri":"/posts/book/minihabits/"},{"categories":["读书笔记"],"content":"关于书 《小狗钱钱-孩子和家长共同成长的金融读物》 [德]博多•舍费尔 著；王钟欣 余茜译 四川少年儿童出版社 引导孩子正确认识财富、创造财富的“金钱童话” ","date":"2022-12-11","objectID":"/posts/book/small_dog_money/:1:0","tags":["读书笔记"],"title":"[读书笔记]《小狗钱钱》","uri":"/posts/book/small_dog_money/"},{"categories":["读书笔记"],"content":"关于作者 博多•舍费尔 1960年9月10日出生在德国科隆。 16岁时移民美国。在加州一所高等学校毕业后，他先后在美国旧金山和墨西哥学习法律，之后在不同公司中担任各种重要职务。 26岁时他遭遇了个人经济危机-他的贸易公司陷人了财务危机，债台高筑。在财务顾问的帮助下，他开始实施个人发展战路。用不到4年的时间，他就摆脱了债务，并获得了源源不断的利息收人。 他决定把自己的理财经验与更多的人一起分享：他的著作被翻译成十几种语言在全球各地广为传播，并创下了 110周稳居德国图书排行榜首位的记录；他每年在欧洲各地的巡回演讲吸引了数十万人的热情参与。 他已经帮助成千上万的欧洲人在个人财务问题上取得了巨大的进步，成为欧洲第一理财大师，拥有“欧洲巴菲特”和“欧洲第一金钱教练”的美誉。 ","date":"2022-12-11","objectID":"/posts/book/small_dog_money/:2:0","tags":["读书笔记"],"title":"[读书笔记]《小狗钱钱》","uri":"/posts/book/small_dog_money/"},{"categories":["读书笔记"],"content":"前言 全书以一个小女孩和一个会说话的狗狗\"钱钱\"之间的故事为引线，叙述了关于理财的一些思维方法； 天下难事必作于易，天下大事必作于细; -《道德经》老子 天下间的难事一定是由容易的事情演变而成的，天下的大事一定是从细小处开始累积的。 类似，不积跬步，无以至千里；不积小流，无以成江海。 ","date":"2022-12-11","objectID":"/posts/book/small_dog_money/:3:0","tags":["读书笔记"],"title":"[读书笔记]《小狗钱钱》","uri":"/posts/book/small_dog_money/"},{"categories":["读书笔记"],"content":"财富法则 列举其中最重要的一些原则，这也是本书的线索。当你在故事中再次读到这些原则的时候，你的记忆就会加深，也会有更强烈的行动力。 一开始，必须明确金钱对你的意义。 确立最重要的目标。为什么我们必须特别强调在我们“长长的愿望清单中”的某几个目标？ 为什么梦想储蓄罐和梦想相册很重要？我们的潜意识如何支持看我们？我们为此需满足哪些前提条件？ 为什么仅有较高的收人绝不可能解决我们的财务难题？ 如何使我们不放弃已经作出的决定–想象的艺术。 总会有一些人想要阻止我们实现自己的目标，阻力然至经常来自我们的来成朋友，但还是有一些不让自己迷失的方法 为什么一本成功日记能促使我们的收人不断地增加？为什么自信是最关键的因素？ 人们如何将自己最大的爱好作为职业，并由此再次大幅度提高自己的收入？ 重要性和紧迫性之间有什么区别？如何保证在任何情况下都不偏离制订的目标？ 付诸实施的关键：72小时规定 如何以轻松的方式挣到许多钱？ 关于如何处理债务的4个忠告。 一只下金蛋的鹅的故事–人们如何量入为出 如何正确使用银行并使之成为一种乐趣？ 幸福的本质以及我们如何才能获得更多的幸福。 爱钱有什么不对吗？保险箱里留多少现金比较合适？ “金钱是‘中性’的”指的是什么意恩？钱与幸福之间有什么联系？ 归还我们的一部分所得是十分重要的。（做慈善和公益事业，） 对待恐惧的最佳方式。成功日记所起的作用。 增加金钱的最有效途径之一：投资俱乐部。保证成功的5条规定。 白手起家的魔法。 适用于所有投资的了条最重要的规定。 什么是股票？股票是如何运作的？收益是如何产生的？ 你是否造合股票投资？ 为什么偶尔放弃熟悉的环境、从事我们畏惧的事情很重要？ 怎样确保每年获得12%以上的利息？近乎完美的投资形式和投资战略是什么？ 为什么股票基金是保险的，而且可以为你带来丰厚的利润？挑选保险的基金的 3个注意事项。 投资基金为什么很简单？ 在投资基金的情况下，你的钱变成了什么-利滚利的力量 浮动利率：如何乎衡风险和赢利。 如何轻松地计算利息与复利？ 当汇率下跌时应 当做什么？如何在这种情况下获得高额利润？ 用基金获得可靠的高利润的前提。 通货膨胀的真正含义以及如何轻松计算出它对财产的影响。如何使通货膨胀成为你最好的朋友—当你正确选择投资对象时。 金钱对我们生活中的其他领域会产生什么影响？当我们更多地研究金钱这个题目时，将会发生怎样的变化？ ","date":"2022-12-11","objectID":"/posts/book/small_dog_money/:3:1","tags":["读书笔记"],"title":"[读书笔记]《小狗钱钱》","uri":"/posts/book/small_dog_money/"},{"categories":["读书笔记"],"content":"一切皆有可能 只需要一点思想的火花就足以让你走上富裕的道路。可是在这里，我还想提醒你注意一个令人惊讶的事实，在某种程度一旦丰厚的资产开始流动，其上也作为一个预先的提醒-速度之快和数量之大都可能让你吃惊： 以前它们都藏到哪里去了？ 这个现象还纠正了广为流传的错误观点一人们只能通过多年艰苦的工作才能实现富裕。财富应该是某种思想观点、某种以富裕为导向的信仰的产品。只要满足了这些前提条件，那么这一切比大多数人想象的都要简单得多。 ","date":"2022-12-11","objectID":"/posts/book/small_dog_money/:3:2","tags":["读书笔记"],"title":"[读书笔记]《小狗钱钱》","uri":"/posts/book/small_dog_money/"},{"categories":["读书笔记"],"content":"忽视是一种认输 大多数人对自己的财务状况关心得不够。在这方面，他们像一个了岁的孩子，只会闭上眼睛想：反正现在看不见它了。财务问题始终存在，如果我们对它不闻不问，它就会变成一种消极力量，降低我们的生活质量。忽视财务问题，就是放弃成功的机会。 财务自曲是今天每个人都可能实现的目标，当然这需要我们拥有進求自己真正想要的生活的勇气。正如一向名言所说：“并非國难使我们放弃，而是因为我们放奔，才显得如此困难。 ","date":"2022-12-11","objectID":"/posts/book/small_dog_money/:3:3","tags":["读书笔记"],"title":"[读书笔记]《小狗钱钱》","uri":"/posts/book/small_dog_money/"},{"categories":["读书笔记"],"content":"明确目标，并经常查看目标 1.明年夏天参加交换学生项目去美国，提高自己的英语水平。 2.一台笔记本电脑。 3.帮爸爸妈妈还清债务，让他们不再那么伤心， “很好的愿望，你做了很聪明的选择。〞钱钱兴奋地说，“我要祝贺你！” 我心里洋滥着自豪感。可是我还是不明白做这个练习到底有什么意义。钱钱又一次看出了我的想法，马上回答说：“大多数人并不清楚自己想要的是什么，他们只知道，自己想得到更多的东西。你可以把自己的生活想象成一家很大的邮购公司如果你给一家邮购公司写信说 ‘请给我奇一些好东西来’，你肯定什么都得不到。我们的愿望也是一样。我们必领确切地知道自自己心里渴望的是什么才行。” 我有点怀疑：“是不是只要我明确知道自己想要什么，就真的能实现呢？ “当然你还要为此付出努力，”钱钱答道，“但是至少你已经迈出了关键的第一步。 “是因为我写下了自己的愿望吗？”我问道。 “是的。”钱钱说，“从现在开始，你必须每天都把这张写着自己的愿望的单子从头到尾看一遍，它会不断地提醒你自己想得到什么，那么你就会密切关注一切可以帮助你实现这些愿望的机遇了。” “我想知道，这种方法会不会有效？” 我有些怀疑的问到。 “如果你带者这样一种态度来做这件事的话，我的方法肯定发挥不了作用。但是只要你做3件事，就可以轻易改变白己的想法。 第一，我建议你拿一本相册作为你的梦想相册。收集一些与自己的愿望有关的照片，把它们贴在相册里。我们要通过图片来思考。 就是说，不借助文宇。”钱钱，“当你想到加利福尼亚的时候，你的脑海里浮现出的是‘加利福尼亚，这几个字，还是某一幅画面？” 钱钱说得有道理，我的眼前立刻浮现出迪士尼乐园、旧金山和好菜坞的画面。 “那我到哪里去找这些照片呢？” 我问钱钱。 钱钱用一种奇怪的眼神看着我，好像在嘲笑我似的。 “好吧，”我赶紧说，“笔记本电脑的照片我可以从广告里剪不来，头于美国的照片我也许可以向交换学生机构要。可是尽管如此，我还是不太明白为什么要做这些。 有的时候我们不需要完全明白这种方法为什么有效，也不必管它是怎样起作用的，关键是它有效。” 我想起钱钱剛才说过，只要做到了什事，我就会相信自己的愿望真的可以实现。 第一件事就是准备一本相册，贴满与我的梦想有关的照片。那么另外的两件事是什么呢？ 我立即得到了回答：“第二件你可以做的事，就是每天看八遍相册，然后想象着，你已经在美国了，已经拥有笔记本电脑了还要想象你替爸爸还清债务后自豪的神情。 我诧异地说：“这和做梦是一样的呀！可是妈妈总是告诉我，不要做白日梦。” 钱钱耐心地解释道：“人们把这种行为称作 ‘视觉化’。成功的人之所以成功，就是因为他们一直梦想着自己成功的那一天不停地想象着自己实现了理想时的情形。当然，人不能停留在梦想里，你妈妈要对你说的是这一层意思。” 我觉得这一切都显得很可笑。这跟我设想中的关于金钱的第一课完全不同。 “这就叫学习”钱钱的回答，“学习就是认识新观念和新想法的过程。假如人们始终以同一种思维方式來思考问题的话，那么始终只会得到同祥的结果。 因为我对你讲述的许多内容是你以前从未接触过的，所以我建议你，在你还没有做之前，不要轻易下结论。没有想象力的人是很难成就大事的。我们对一件事投入的精力越多，成功的可能性也越大。 ","date":"2022-12-11","objectID":"/posts/book/small_dog_money/:4:0","tags":["读书笔记"],"title":"[读书笔记]《小狗钱钱》","uri":"/posts/book/small_dog_money/"},{"categories":["读书笔记"],"content":"我该到哪里去挣钱？ “我给你讲一个有趣味的放事，一个名叫达瑞的美国男孩，他在17的时候就已经挣到了几百万马克，而他其实只不过是一个非常普通的男孩。但是在讲故事之前，我先要告诉你一个非常重要的道理： 你是否能挣到钱，最关键的并不是你有没有好点子，也不是你有多聪明，而是你的自信程度。” “我的自信程度？”我重复着钱钱的话，又问道，“这和挣钱有什么关系呢？” 钱钱一脸严肃地直立起来，它是在向我表明，这是非常重要的内容：“你的自信程度决定了你是否相信自己的能力，是否相信你自己。假如你根本不相信你能做到的话，那么你就根本不会动手去做， 假如你不开始去做，那么你就什么也得不到。\" 这就是自信。 ","date":"2022-12-11","objectID":"/posts/book/small_dog_money/:4:1","tags":["读书笔记"],"title":"[读书笔记]《小狗钱钱》","uri":"/posts/book/small_dog_money/"},{"categories":["读书笔记"],"content":"如何树立自信？ “我不觉得自己特别自信。” 〝那没关系，”钱钱说，“自信是很容易树立的。你想知道应该怎样做吗？” “当然了。，我赶紧回答。 “那么我可以告诉你。你去准备一个本子，给它取名叫 ‘成功日记’，然后把所有做成功的事情记录进去。你最好每天都做这件事，每次都写至少5条你的个人成果，任何小事都可以。 开始的时候也许你觉得不太容易，可能会问自己，这件或那件事情是否真的可以算作成果。在这种情况下，你的回答应该是肯定的。过于自信比不够自信要好得多。” 钱钱想了一会儿，然后接着说：“你最好立即开始做这项工作。我们一会儿晚饭后再见。到那时我会给你讲达瑞的故事。 我很想立即听到达瑞的故事，可是我越来越信任钱钱了相信它的安排是有道理的。看上去似乎所有的事情都在它的掌握之中，所以我同意了。我们一起散步回家。 一回到家，我就钻进自己的房间。我拿出一本旧的练习本， 这是我以前的化学作业本。我把写了字的几张纸撕掉，然后在本子的封面上贴了一张新的标签，写上“成功日记” 我写下今天的日期，准备开始我的第一篇成功日记。我目不转睛地盯着面前的白纸，我昨天都做成什么事了呢？想了好一会儿，除了淮备梦想储蓄罐这件事，我什么都想不起来了。 〝故事是这样开始的。在达瑞8岁的时候，有一天，他想去看电影但是没有钱。他面临一个基本的问题，是问爸爸妈妈要钱还是自己挣钱。最后他选择了后者。他自己调制了一种汽水，把它放在街边，向过路的行人出售。可那时正是寒冷的冬天，没有人来买，只有两个人例外他的爸爸和妈妈。 “他偶然得到了一个机会，可以与一位非常成功的商人谈话。当他对商人讲述了自己的‘破产史’后，商人给了他两个重要的建议：第一，为别人解决一个难题，那么你就能赚到许多钱；第二，把精力集中在你知道的、能做的和拥有的东西上。 “这两个建议很关键。因为对于一个8岁的男孩而言，他不会做的事情有很多。于是他一边沿着大街小巷漫步，一边不停地思考人们会有什么难题，他又该如何利用这个机会为他们解决难题。 “这其实很不容易。好点子似乎都躲起来了，他什么办法都想不出来。但是有一天，他的爸爸无意中给他指出了一条路。吃早饭时，爸爸让达瑞去取报纸。这里必领补充一点，美国的送报员总是把报纸塞进花园篱笆上挂着的报箱里。假如你想穿着睡衣舒舒服服地一边吃早饭一边看报的话，就必领先离开温暖的房间，冒着寒风到房子的人口处去取。即使在天气不好的时候也是如此。 “情况顺景的时候，人人都能赚到线。只有在逆境中，一切才能见分销。\" 钱我对我点了点头，说：“困难总是在不断地出现。尽管如此，你每天还是要不间断地去做对你的未来意义重大的事情。你为此花费的时间不会超过10分钟，但是就是这10分钟会让一切变得不同。大多数人总是在现有的水平上停滞不前，就是因为他们没有拿出这10分钟。他们总是期望情况能向有利于自己的方向转变，但是他们忽视了一点，那就是他们首先必须改变自己\" 钱钱停了停，又接着说：“这10分钟就是你用来改变自己的最好机会。你最好现在大声地发誓，从现在开始会不间断地记录你的成功日记，并且不间断地设想你的末來。而且不论在什么情况下，每天都坚持这么做。。 我举起右手宣暂：我要从现在开始，每天记录我的成功，并不间断地设想我的未来，我发誓。 〝第二点，”钱钱说，“在—切进展非常顺利的情况下，你也应该做这些事情。”我疑恐不解地望着它。它这么说是什么意思呢？ “你有成干上万件事情可能让你分心，因此你每天应该在固定的时间里，有规律的做这些事情。” 一个规律，“当你决定做一件事情的时候，你必须在72小时之内完成，否则你很可能永远不会再做了。\" 我要在72小时内完成我決定要做的事情。 “大多数人都认为工作肯定是一件艰苦而令人不愉快的，他向我解释道，“其实只有做自己喜欢的事情的人，才能真正获得成功。\" ","date":"2022-12-11","objectID":"/posts/book/small_dog_money/:4:2","tags":["读书笔记"],"title":"[读书笔记]《小狗钱钱》","uri":"/posts/book/small_dog_money/"},{"categories":["读书笔记"],"content":"资产管理 “我以前的主人金先生有一家理财咨询公司。这家公司的作用就是教人们学会如何管理他们的财产。”钱钱意味深长地说。 金先生自己只为非常富有的顾容当顾问，但是他公司野许多工作人员会为那些在财务上遇到重大难题的普通人提供帮助。因为我可以到处跑，所以我常常听到他们的谈话。 从根本上说，那些陷人债务的人只要听从4个忠告就可以解决负债问题一切都很简单， 欠债的人应当毁掉所有的信用卡。 “因为大多数人在使用信用卡的时候，会比使用现金时花的钱要多得多。 在许可范国内按最低的分期付款数目标准支付。 将扣除生活费后剩下的钱的一半存起来，剩下的一半用于支付消费货款。最好根本不申请消费货款。 这个忠告是针对消费货款的。消费货款是与住房无关的贷款。假如人们为了购置新的汽车、家具、电视机或其他用于生活的商品而贷款，就是消费贷款。这时候贷款的人应当遵守的一个原则，就是将不用于生活的那部分钱的一半存起来，另一半用于偿还贷款。 所有的消费贷款都是不明智的。聪明的做法是只把以前积攒起来的财富用于支出。 这真的有必要吗？ 债务人都应该在自己的钱包里贴一张纸条，上面写着，这真有必要吗’。这样的话，当他站在收银合前的时候，就会想到不应该花太多的钱。 “幸运其实只是充分准备加上努力工作的结果\" 一个人挣钱的多少是和他的自信心联系在一起的。另外，他的精力究竟是集中在自己的能力范围之内，还是放到了他力所不能及的事情上，这也是很重要的一点。没有我的成功日记本，我就不会去思考自己适合在哪些方面赚钱。 你可以做一个有能力帮助别人的人，而别人也会相信你，愿意接受你的帮助。 ","date":"2022-12-11","objectID":"/posts/book/small_dog_money/:5:0","tags":["读书笔记"],"title":"[读书笔记]《小狗钱钱》","uri":"/posts/book/small_dog_money/"},{"categories":["读书笔记"],"content":"如何投资 和钱有关的绝大多数课程，你在和别人的谈话中都已经学过了。这些人本身都很富有，是最好的老师。 你现在只差一门重要的课程，就是怎样投资。 确定自己希望获得财务上的成功。 自信，有想法，做自己喜欢做的事。 把钱分成日常开销、梦想目标和金鹅账户三部分 进行明智的投资。 享受生活。 投资俱乐部规定： 每月聚会一次。 出席会议是每个成员的义务。 每人都要交出一定数额的现金。 不得将该钱取出，因为我们希望“鹅”长大。 所有的决策由全体成员共同作出。 聪明的商人可不会让自己的钱只躺在银行里睡大觉，这样做根本没有什么利息。 如果你没有做今天这件事情，你就永远不会知道，给自己一些压力之后，你能够做到些什么。一个人觉得最引以为自豪的事情，往往是那些做起来最艰难的事情。这一点你千万不要忘记。 ","date":"2022-12-11","objectID":"/posts/book/small_dog_money/:6:0","tags":["读书笔记"],"title":"[读书笔记]《小狗钱钱》","uri":"/posts/book/small_dog_money/"},{"categories":["读书笔记"],"content":"投资风险 最好的办法就是，我们把钱投在一只大型的基金上，5~10年之内根本不去看它。然后，等我们再去查看它的行情的时候，肯定已经得到了丰厚的利润。 金先生对我说过的一句话：不要为失去的东西而忧伤，而要对拥有它的时光心存感激。 ","date":"2022-12-11","objectID":"/posts/book/small_dog_money/:7:0","tags":["读书笔记"],"title":"[读书笔记]《小狗钱钱》","uri":"/posts/book/small_dog_money/"},{"categories":["读书笔记"],"content":"关于书 《断舍离.心灵篇》 山下英子; 王珊译 广西科学技术出版社 ","date":"2022-12-10","objectID":"/posts/book/throw/:1:0","tags":["读书笔记"],"title":"[读书笔记]《断舍离》","uri":"/posts/book/throw/"},{"categories":["读书笔记"],"content":"三种扔不掉东西的人 ","date":"2022-12-10","objectID":"/posts/book/throw/:2:0","tags":["读书笔记"],"title":"[读书笔记]《断舍离》","uri":"/posts/book/throw/"},{"categories":["读书笔记"],"content":"逃避现实型 真麻烦； 这种类型的人太忙碌，几乎没什么时间待在家里，所以也没办法收拾屋子。多数情況下，这种人都是对家庭有所不满， 不愿意待在家里，所以就找各种各样的事，让自己忙碌起来。加上家里乱七八糟的，所以就更不想待在家里了。慢慢地，在这样的恶性循环里越陷越深。 ","date":"2022-12-10","objectID":"/posts/book/throw/:2:1","tags":["读书笔记"],"title":"[读书笔记]《断舍离》","uri":"/posts/book/throw/"},{"categories":["读书笔记"],"content":"执着过去型 真可惜； 这种类型的人，即便是现在己经不会再用的过去的东西，也非得收着不可。相册、奖杯等等，统统当作命根子似的保管起来。 他们多半隐含着对过去幸福时光的留恋。从不想面对现实这一层意义上来看，与逃避现实型也有相通之处。 ","date":"2022-12-10","objectID":"/posts/book/throw/:2:2","tags":["读书笔记"],"title":"[读书笔记]《断舍离》","uri":"/posts/book/throw/"},{"categories":["读书笔记"],"content":"担忧未来型 也许有天会用到； 这种类型的人致力于投资不知何时会发生的未来的不安要素。这类人的特点是过分地囤积纸巾等日用品，要是没了这些就会觉得困扰、焦虑不安。 在三种类型当中，这一类的人最多。 ","date":"2022-12-10","objectID":"/posts/book/throw/:2:3","tags":["读书笔记"],"title":"[读书笔记]《断舍离》","uri":"/posts/book/throw/"},{"categories":["读书笔记"],"content":"断舍离 概念 “断舍离”的概念非常简单： “断”，断绝想买回家但实际上并不需要的东西， “舍”，舍弃家里的那些泛滥的破烂， “离”，脱离对物品的执念，处在游刃有余的自在空间。 ","date":"2022-12-10","objectID":"/posts/book/throw/:3:0","tags":["读书笔记"],"title":"[读书笔记]《断舍离》","uri":"/posts/book/throw/"},{"categories":["读书笔记"],"content":"以自我为轴心 通过斩 “断”不必要的物品的流入，“舍〞去形同废物的物品，我们就能从物品的拘束中脱 “离”出来。“断”与“舍”这两种行动（doing ）的交替重复，会带来 “离” (being）的状态。到了这时，无论是身体还是精神，都会产生巨大的变化。 “俯瞰力”就是此时应运而生的“观点”变化。 我们会从以物品为轴心的短视点，转变成以 “我” 为轴心来正确掌握空间（整体性）， 并进一步发展成为更深刻的洞察、更高远的观点以及更广阔的视野，俯瞰力就是这样的。 最重要的是要把空间里物品的总量减少到能让住在里面的我们觉得舒适的程度。这也就是说，要重新检讨放在家里的物品与我们的关系，取回那些被物品夺走的空间和能量。 如果是一直过着那种对物品的量没有意识、毫无自觉的生活，那么家里的物品就会不断地增加再增加。 明明家是自己的，却往往会以他人为思考的轴心来保存物品，这是每个人都有可能出现的问题。 断舍离的着重点是以自我为轴心，考虑“自己会使用吗”，以此来做物品的筛选工作。 ","date":"2022-12-10","objectID":"/posts/book/throw/:3:1","tags":["读书笔记"],"title":"[读书笔记]《断舍离》","uri":"/posts/book/throw/"},{"categories":["读书笔记"],"content":"做减法，让生命发光发热 “断“、“舍”、“离”这三个汉宇，全都有减法的含义。 这几个字是智慧的体现，也是文化的精髓。 失去原本应当拥有的智慧，一路做着加法走来的现代人，现在到了应当学习“崇尚不足的精神”、〝减法的解决法”这些智慧的时候。 ","date":"2022-12-10","objectID":"/posts/book/throw/:4:0","tags":["读书笔记"],"title":"[读书笔记]《断舍离》","uri":"/posts/book/throw/"},{"categories":["读书笔记"],"content":"读者反馈 ","date":"2022-12-10","objectID":"/posts/book/throw/:5:0","tags":["读书笔记"],"title":"[读书笔记]《断舍离》","uri":"/posts/book/throw/"},{"categories":["读书笔记"],"content":"扔掉看得见的东西，改变看不见的学问 “断舍离”具体如何指导生活，我举个简单的例子。在超市购物时，面对一样物品，我们不是思考“在搞促销活动耶，多买多划算啊” “这个东西真便宜”、“这样子真好看”，而是思考“我现在需要吗”、〝这个东西适合我吗”。要不要扔掉某物或者送给其他人也是如此，不是思考 “还没坏，还能用，所以留下来” 、“扔掉好可惜啊”，而是思考“我现在要用吗”、“我还很喜欢吗” ，我不需要的东西就果断地断舍离。 作者山下英子一再强调〝断舍离” 的主角是自己而不是物品，核心是让人思考 “物品和自己的关系”，而时间轴永远是现在。这不单单是一种家居整理、收纳术，而是活在当下的人生整理观。 通过学习和实践断舍离，人们将不断重新审视自己与物品的关系，致力于将身边所有 “不需要、不合适、不舒服” 的东西替换为 “需要、合适、舒服”的东西， 改变居住环境，改善生活面貌。断舍离的意 义不单单在于此，它是一种健康的生活方式，一种独特的思考法则，甚至是一种心灵的修行术。从关注物品转换为关注自我，通过物品来认识、发现、肯定白我，重新认识这个世界，改变肉眼看得见的世果，从而改善看不见的精神世界，让人从外在到内在，都彻底焕然一新。 书中举了一些有意思的例子。 有亲人过世十年仍无法走出悲伤的女士，以断舍离为契机，扔掉旧物，接受亲人过世这一痛苦事实。 一个老师，在冰箱里囤积了大量食物，有的食物甚至冰冻了好几年，原来是她当初当班主任工作压力过大导致她国积食物。 让我印象深刻的是阳子小姐的故事。她是位三十多岁的单身女性，原本就擅长整理，听了断舍离的讲座后更加干劲十足，扔了许多不需要的东西，包含不少社科类的书，但是装满言情小说的一箱书， 始终无法扔掉，书中所写的内容都是没有结果的恋爱。此时，她突然发现，这些书就是自己过去恋爱经历的写照。她总是和那些绝对不会有结果的人谈恋爱。在她的潜意识中， 似乎栖息着一个拒绝婚姻的自己。于是，她当机立断，将这一箱子书断舍离掉，自己也慢慢试着不再排斥婚姻。 ","date":"2022-12-10","objectID":"/posts/book/throw/:5:1","tags":["读书笔记"],"title":"[读书笔记]《断舍离》","uri":"/posts/book/throw/"},{"categories":["读书笔记"],"content":"扔东西的学问 你经常收拾屋子吗？你收拾屋子的时候，什么东西是你丟也丢不掉的呢？ 每一年，我都要买很多很多的衣服、书籍、小物品⋯很多衣服穿过一次便再末上过身，很多东西用过一次就遗忘在了小角落。 日积月累，我被愈来愈多的物件包围，喜怒哀乐都浸泡其中。不是没想过整理，只是很多时侯它们承载过一段回忆让我不知从何下手；不是没想过丢弃无用的东西， 但转念又觉得可惜，不如放着或许以后能用到。手是，这些东西虽然“不需要、不适合、不舒服”，可还是扔不掉， 直留在家中，理由就是执念。但却忽略了东西真正的价值应该是有用。我们总活在过去或未来，而偏偏忽视了最重要的当下 “只有对当下的自己合适且必需，也确实在用的东西，才该留在自己的空间里。”用时间轴看物品，是本书令我受益匪浅的一个观点。 这和我们在这个年代经历的物化是一样的。面对我借由消费来肯定自己的存在感，可是我消费的东西回过头来吞嗾自己的这种优虑。 这时候，我们是被物品车着鼻子走的人， 我们因为物品而萌生喜怒哀乐各种情绪。欲望是需要被穻越的，书中所提出的〝断舍离”的概念则将主角锁定在自己， 考虑的是自己还需不需要它。而“扔了很可惜，还是留下来吧”这种想法，就是拿物品当主角。 从一定程度上来说，一个人所使用的物品，能够反映出自我形象。了解自己，放下过去的自己，就能发挥出自己的潜能。这些都不是有意为之，而是自然而然地实现。而这种筛选物品的工作，也具有改变自己与他人关系的奇妙力量。 和物品成为好朋友，和自己喜欢的东西生活在一起，这就是断舍离的最终阶段。用关系轴看物品，是本书另一让我拍案称奇的观点。 生活处处充满着哲学，断舍离就是“扔东西”的学问。收拾屋子这一件看起来再平凡不过的事情却是一种磨砺感应能力的技术。 而扔掉家里的一件垃圾，这一个简单的动作竟也能磨砺你的内在智慧。书中讲述了 “断舍离”这一哲学价值观应用到人生中的案例。 阳子是个三十多岁的单身女人，通过断舍离，她终于明白自己为什么一直谈着没有希望的恋爱而结不了婚。 香织本来对生活感到茫然，连看电视也只是不断换台。 后来毅然将40英寸液晶电视断舍离，整个人从此豁然开朗。 亲人突然离世的胜美，十年来都无法接受亲人已死的事实。家中一团糟的厨房代表了她十年来的悲伤感叹，终于她决定断舍离，连续三天把堆积了十年的东西都消灭干净，房间焕然一新，痛苦好像也彻底殆尽了。原来，重要的回忆， 放在心里就好。 生活中，我们总是背负了太多垃圾在前行。我不禁感叹：〝原来人生中有那么多的东西是应该舍弃却因舍不得而被牵绊着的啊。〞让自己回到清简的日子，给之前的生活做减法再做减法，将身边 “不需要、不合适、不舒服”的东西替换成， “需要、合适、舒服”的东西。同理，就如张德芬在《断舍离》的序言里所说的：“想要幸福，我们需要先放下对幸福的执念。 ”断掉负面的思考，割舍眼前既有的幸福进而投资出更多的幸福，驱家要求更多的幸福欲求。这便是我从书中读到的智慧。 我有多久没有整理白己的人生了？ 合上书，我决定就从此刻开始收拾我的房间！ ","date":"2022-12-10","objectID":"/posts/book/throw/:5:2","tags":["读书笔记"],"title":"[读书笔记]《断舍离》","uri":"/posts/book/throw/"},{"categories":["读书笔记"],"content":"最简单的生活之道-从你的衣柜开始 因为对物品占有的原始本能或担忧未来，大多数人常常会毫无意识地储存一大堆自己或许并不怎么用或者根本用不上的物品。 绝大多数人的思维模式是–某个物品，我买下来了于是我就拥有它了，通过不断增加的对物质的占有，借此得到感官上的满足（通常情况下，这一类人潜意识会觉得，人生的幸福是通过不停地做加法得来的）。 事实上，这样想的人，常常是反被这些身外之物占有了。例奶，某人买了车，初心是想给自己带来方便（极少部分人还有一点从众炫耀的意识），但是买了车之后， 需要执照、维护、保险、加油、停车位、朋友借车、担心被损坏或被盗等等，反而占用了自己大量的精力和时间，从时间成本和经济成本上并不见得划算。有人会说买车之后更方便了， 比如说出去游玩的时候之类的，是的，但是人们有多少时间是出去玩的呢？更多的时候，正是因为有车才促使了自己要出门的次数，也就是说这并非是必要的出门，而是附加滋生出来的成本- 这类似于购买了智能手机后，我们表面上是拥有了手机，实际上反过来被手机占用了大最的时间。原本这些时间是可以用来做更多更丰富的事情的，反而被无意义的消耗和浪费了。 另外的情况就是自己根本就不需要的东西，却因为从众或炫耀而购买，正如我们常说的“活在了别人的眼里”，这种时候从某种意义上来说，是别人拥有了你的东西，而不是你自己所拥有。 因此，在你购买或拥有某些物品的时候，是你占有了车、房、手机、电视机、游戏机，还是你被这此东西反过来占有了？ 同理，一些感情方面上的需求也如此，有些人觉得自己过得不好是因为自己孤身一人的原因，认为“等有个人陪、结婚成家、有了孩子之后，生活就会更好更幸福一些” 一开始自己所认为的这些需要，并非是自己所设想的那样，最终却被恋爱家庭婚姻孩子等反过来牵绊了，动弹不得，成为人生烦恼的重要来源. 在《断舍离》一书中，作者山下英子提到， 一此家庭主妇因为贪图便宜或是担忧末来，常常会购买和储存一大堆用不上的东西。比如，明明家里有不锈钢的勺子，两三个就足够一整个家庭使用了，但是遇到商场或餐厅赠送的塑料勺子还是一股脑地带回家 堆积起来。 另外，一些人明明家里有更高档的器具，如高级杯子、高级不锈钢器皿，却因为“怕损坏、太可惜了、平时用没必要、这是有客人来的时候用的”等理由放着不用， 仍旧让类似用途的廉价物品像废水一样流进家里，堆积起来占用空间不说，因为“都拿回来了，不管怎样还是用一用吧，不然怪可惜的”的想法， 迫使自己一直用这些廉价甚至劣质的东西。作者说，大多数这样做的人，从心理层面上来说有很严重的自卑和自我否定的心态，觉得自己配不上高档货，自己只能在舍不得丢掉的便宜货里面打转，不得不说是很悲哀的。 关于物质，它所仅仅展示出来的是表象，常常反映出来的是心灵的状态，储存或占用自己并不需要的东西、在明明拥有更好的选择的情况 下却使用低廉的物品、让为数众多的用不上的废物充斥自己的生活空间等等行为， 说来就是极其不自信的心态造成的。从心理形成机制上来说，通常源自童年的物质匮乏或自卑心态造成的，继而深远地影响到了成年后的生活。 对物质的占有欲近乎贪婪，但却以节约等借口购买便宜的东西，使用低劣的物品。面对物质时，拥有严重的自卑心态，捡了芝麻，丢了西瓜，让用不上、不必要的劣质产品包围堵塞自己的居家佳所， 又反过来让心灵变得更加拥堵不堪，无法快乐自在的生活。 佛说，所有对身外之物甚至身内之物的执念，皆是因为看不清、看不开所造成的。世间事通常是有舍有得，而世人总会忘记这一点，只愿获得而鲜有人愿意舍弃。 一个杯子，杯内毫无一物的时候，是它能装载最多东西的时候； 较之成人，小孩子生活得更快乐，也是因为他们的心灵更像是白纸一般，简单干净无欲无念无车无挂。 “空” 代表着无限，放下欲念，才能拥有更广阔的空间。 许多真正的佛教徒，都过着深居简出的生活，越是修为高深的僧人，通常居佳之处也简单到极致，生活清简并没有使他们的生活更糟糕，反倒有了常人所没有的平静与宽容。 说到这里，或许有人要误认为我是在规劝大家要像僧人一样节俭清苦，实际上并不是，我本凡人，我们不如来看看文学家村上春树在关于买车这件事情上是怎么说的： “自己不买车，原因是一年到头根本用不了几次，自己生性懒散，觉得打理那个东西实在是麻烦，要出门，坐车的土新千线都可以，买车完全实在没有必要。” 最重要的是要知道自己的需要，而不是随波逐流，埋没于自己的欲念中。 说了这么多，简单来说无非就是：生活很简单，以“自己是否需要”为中心来考虑问题，择优选择生活中的一切需要，仅保留当下能够用到的，即可。 想来自己是此方法的受益者： 清理了卧室衣柜内一半以上的衣服，不管新的旧的好的坏的现在不穿的不喜欢的看着不舒服的全部扔掉，衣柜顿时变得很清爽； 扔掉了不怎么穿的一堆鞋子，满满的鞋架变空了，只剩下自己喜欢的鞋子； 朋友送的各种布满灰尘的物件和礼物，现在用得上的留下，用不上的就送给需要的朋友； 把手机上用不上不常用的软件，应用、游戏、电子书等等，管它喜欢的或是不喜欢的， 精简删除到最少，相册清空、图片清空、视频清空，手机运行更快更流畅了； 把工作电脑上收藏的堆得像瀑布一般的网页、储存的一大批看过的电影、不可能有时间看的一堆学习资料、一堆过期的工作文件等等，一股脑删除； 把QQ、电话簿、微信等上的联系人，不常联系、不再联系、不认识不喜欢的，全部删除，只剩自己喜欢或喜欢自己的人，发现自己真心的良师益友就那么几个也就足矣； 下定决心和并不爱的人说再见，虽有歉意和不舍，但相信分开以后，各自都能过得更好，等等。 从整理衣柜开始，当我理解到幸福的生活应该是在做减法之后，内心像是有很多杂质也一并清除了心中获得前所末有的宁静。我想在未来，应该还有更多的东西等着我去清理，比如已经困扰我许久的纷扰杂乱的工作， 再如已经堆满了各种新书和旧书的书架——对于我这爱书狂人，我想这应该是不小的考验—尤其在对待自己钟爱的事物上，放弃舍弃挣脱，才能真正根治我们心中根深蒂固的执念，脱离欲望的苦海。 刚刚开始去做这一切的时候，可惜、犹豫、难舍等感情会一直在头脑中盘旋斗争，常常扔掉的东西又拿回来，总感觉实在是无法舍弃，总感觉扔掉很可惜。 但是，如果最终狠下心舍弃后，会发现其实也还好，本来就用不上或者不好的东西，与其它们在阴暗的角落滋生灰尘，那和扔掉又有什么区别呢。 想来，活于世间，就没有什么无法舍弃的东西。一切执念，都只是我们自己为自己的头脑拷上的柳锁而已。 试想，一场跑步比赛，一个负重奔跑的人，怎会可能有一个双手空空轻松上阵的人轻松呢。从普通的成功几率来算，谁取胜的可能性更大？ 我们的物质和意识之间有种看不见的关联，清除物质，只为心灵让出空间–这很简单，从你的房间衣柜开始， 无论高档低廉无论有特殊意义还是无意义，勇敢地和那些你不能用、用不上、不喜欢的东西说再见！ 当你觉得有点\"可惜\"和\"难以取舍\"的时候，告诉自己要做更优秀更自信的自己，你的精力和时间不该浪费在这些不好的废物上，最后，洒脱潇洒地扔掉它。 最后，我们只需记住：占有绝非是拥有，放下才能拥有更多。 ","date":"2022-12-10","objectID":"/posts/book/throw/:5:3","tags":["读书笔记"],"title":"[读书笔记]《断舍离》","uri":"/posts/book/throw/"},{"categories":["读书笔记"],"content":"效率 效能，单位时间内产生的生产价值；提高效能意味着 使用相对少的时间，产生相对大的生产价值。 效率，在产生效能过程中的使用的方式方法等。 大到机构、公司、经济体，小到团队、个人等，提升效率，方可产生最大效能； 在这个竞争越来越激烈的时代，谁能提供生产效率，谁就可以早一步，抢先占领市场，降低被淘汰的风险。 对于个人，无论读书、工作、学习，均需要提高效率；竞争无处不在，我们需要用相对短的时间，学习更多的知识，提升自己的综合能力，才能走的更长远。 ","date":"2022-12-10","objectID":"/posts/book/how_to_read_book/:1:0","tags":["读书笔记"],"title":"[读书笔记] 如何阅读一本书","uri":"/posts/book/how_to_read_book/"},{"categories":["读书笔记"],"content":"《如何有效阅读一本书》 ","date":"2022-12-10","objectID":"/posts/book/how_to_read_book/:2:0","tags":["读书笔记"],"title":"[读书笔记] 如何阅读一本书","uri":"/posts/book/how_to_read_book/"},{"categories":["读书笔记"],"content":"关于书 《如何有效阅读一本书》 [日本] 奥野宣之 ","date":"2022-12-10","objectID":"/posts/book/how_to_read_book/:2:1","tags":["读书笔记"],"title":"[读书笔记] 如何阅读一本书","uri":"/posts/book/how_to_read_book/"},{"categories":["读书笔记"],"content":"前言 “—味读下去”等于没有读过 至今为止，你读过那么多书，到底记住了多少内容呢？ 如果有人问你最喜欢哪本书，你也许能回答对方一个书名，说“我还是学生的时候读过这本书，它对我有很大的帮助”，而当对方问起下面的问题，你会怎样回答呢？ 这本书讲了什么内容？ 你最喜欢书的哪一部分？ 这本书对你有什么影响？ 它的优点又在哪里？ 再认真回想一下，你会发现读书确实是件很难的事情： 人的记忆力是有限的，回想不起具体内容也情有可原，但是，你读书时有没有留下些随笔或者笔记呢？ 通过做笔记吸取书中营养 之所以说这种方法很简单，是因为你只需要准备一本笔记本。一本随处可见的笔记本可以帮你找到想读的书辅助你的阅读，记录你阅读中的发现，或是回忆过去读过的内容。 一本笔记本可以把读书生活的点点滴滴管理得井井有条。 就是这么简单。概括来说，需要记录的就是这些： 要买什么书 要注意书中的哪个部分 想到了什么 把以上几个问题写在笔记本上，然后保存起来，时常拿出来看看，慢慢养成习惯。这看起来是件很简单的事情，但很少有人能真正做到。只要坚持下去，觉得自己 “记忆力不好”的人也能准确地记住书中的内容，而“想要再读一遍那段文字” 的人也可以迅速找到喜欢的段落。 笔记本是读书的助手，可以把读到的信息以准确的形式转变为你思想中的一部分。多读法和速读法也许也能达到这种效果，但这种读书方法很复杂； 想不起来以前读过一本怎样的书、书里有什么名言；也许你无法理解、吸收书里的内容，这些问题都可以通过做笔记来改善， 本书所讲的读书方法句括以下四方面内容： 如何选书：怎样选择自己真正想读的书 如何购书：怎样买到对自己真正有益的书 如何读书：怎样加深理解、深入思考 如何活用：怎样运用从书中获得的知识在这样的过程后，书里的内容才会真正成为自己的东西。 看到这里，你会不会觉得我是在要求你“把所有的事情记在笔记本上”呢？其实并没有那么麻烦。举个例子接下来我会提到把想买的书记在 “购书清单”上、把读后购书选书 书的堆放与收纳：把没读过、没做过读书笔记的书都堆起来，读过的就放在普通书架上； ","date":"2022-12-10","objectID":"/posts/book/how_to_read_book/:2:2","tags":["读书笔记"],"title":"[读书笔记] 如何阅读一本书","uri":"/posts/book/how_to_read_book/"},{"categories":["读书笔记"],"content":"让读书体验更充实的几个技巧 ","date":"2022-12-10","objectID":"/posts/book/how_to_read_book/:2:3","tags":["读书笔记"],"title":"[读书笔记] 如何阅读一本书","uri":"/posts/book/how_to_read_book/"},{"categories":["读书笔记"],"content":"写读书笔记的 几 款实用文具 ","date":"2022-12-10","objectID":"/posts/book/how_to_read_book/:2:4","tags":["读书笔记"],"title":"[读书笔记] 如何阅读一本书","uri":"/posts/book/how_to_read_book/"},{"categories":["读书笔记"],"content":"《如何练就阅读力》 ","date":"2022-12-10","objectID":"/posts/book/how_to_read_book/:3:0","tags":["读书笔记"],"title":"[读书笔记] 如何阅读一本书","uri":"/posts/book/how_to_read_book/"},{"categories":["读书笔记"],"content":"关于书 -《如何练就阅读力》 凃梦珊著 一个阅读狂人的自白，从不爱看书到一年读完300本书 ","date":"2022-12-10","objectID":"/posts/book/how_to_read_book/:3:1","tags":["读书笔记"],"title":"[读书笔记] 如何阅读一本书","uri":"/posts/book/how_to_read_book/"},{"categories":["读书笔记"],"content":"如何提升阅读速度 舍弃完美主义 “你看电影的时侯会把人物的所有对白都记住吗？” “不会啊。” “一本书里，所有的文字都是金句吗？” “当然不是啊。” “那为什么你在阅读一本书的时候要从头到尾都读呢？” “我也不知道啊，就是不这么读，心里着实难受！” 在我被问到的问题中， “如何提升阅读速度”是出现频率最高的一个。当我观察对方是如何阅读的时候，我发现很名朋友都是从头到尾的进行读。 ","date":"2022-12-10","objectID":"/posts/book/how_to_read_book/:3:2","tags":["读书笔记"],"title":"[读书笔记] 如何阅读一本书","uri":"/posts/book/how_to_read_book/"},{"categories":["读书笔记"],"content":"没时间读书怎么办 管理你的阅读精力 在建立阅读习惯时，一定要警愓消极的条件反射，而心理暗示可以说是人类最简单的条件反射，大体上分为积极的和消极的。而消极的心理暗示又总比积极的更加强大。 比如当我对你说 “不要想粉红色的大象”时，你的脑海里出现的偏偏就是粉红色的大象。 这样的句义还会延伸出很多你不易察觉的形态，比如销售领域就经常应用这些消极的心理暗示来刺激人们的购买行为。房地产市场总宣传总量稀觖，这就属于消极的心理暗示。 这样做的结果就是，即使数据显示土地资源充足，我们也依然觉得只有买了才能消除资源不足所引起的紧张感。在紧张和压力下，人们容易做出错误的判断，降低自己的效能。我们可以让自己避免被大脑欺骗。 当你尽量用积极关键词替代消极关键词进行暗示时，剔除掉其中与否定性内容相关的词语和暗示词，你会更加高效和积极积极地行动。 比如，你常常对自己说 “我的效率很低，读的很慢”，不如改成“我有极大的空间可以提升我的阅读速度”。 日常生活中最常见的心理现象就是心理暗示了，利用好心理暗示的力量，可以让我们的阅读更有效率， 没有时间读书其实就是一种消极的心理暗示，这是伪命题。我相信任何人都有时间进行阅读，但是由于我们总是在无意识当中告诉自己：我没有时间去阅读， 这种消极的心理暗示才会不断地损耗你本来就很稀缺的注意力和精力。 我们可以把“没有时间读书怎么办？〞转换为 “我要如何去管理自己的精力，才能有更多的时间用于阅读呢？〞因为很多时候即使你有时间，你也是给了其他运动，比如打游戏或看电匙，而没有选择网读。 所以我认为这并不是时间的问题，而是不会管理时间的问题。 ","date":"2022-12-10","objectID":"/posts/book/how_to_read_book/:3:3","tags":["读书笔记"],"title":"[读书笔记] 如何阅读一本书","uri":"/posts/book/how_to_read_book/"},{"categories":["读书笔记"],"content":"高效学习 只有将自己的生活规划清楚，不同的时间段不会相互打扰，其他领域不会时常打扰你正在进行的阅读，你才能专心地去做一件事情。你要有一个规律且良好的生活方式，对于生活状况混乱的人而言，去解决这个问题的思路不能是：我要怎样才能够自律？这种思路是一种做加法的思考方式。 正确的方法是：我生活当中哪些混乱的部分是可以砍掉的？这是一种做减法的思考方式。 现在请你拿出一张白纸，列出一个清单，看看现在的生活当中哪些事情导致了你的混乱？哪些事情上你给了自己无效的选择？然后一个一个地去做减法，精简自己的选择。 ","date":"2022-12-10","objectID":"/posts/book/how_to_read_book/:3:4","tags":["读书笔记"],"title":"[读书笔记] 如何阅读一本书","uri":"/posts/book/how_to_read_book/"},{"categories":["读书笔记"],"content":"以教为师，通过知识分享完善自我思考 为什么我们会记得多年前看过的一部经典电影，却会忘记上周刚刚读过的一本书？这是因为视听语言本质上是一种非常口语化的语言，我们看到的图像与我们生活的世界十分接近。同时， 视听语言由于更加立体化而刺激了我们的记忆感官，让我们的记忆吸收率更高。如下图： 不同学习方式的吸收留存率 听讲5% 阅读10% 视听20% 演示30% 讨论50% 实践75% 教授给他人90% 不同学习方式的吸收留存率而在所有的学习方法中，能大幅提升我们阅读读理解效率的方式就是教授给他人了。 教授给他人決定了你对一个概念或知识的真正理解。也就是说，决定我们阅读效率的关键性指标并不是速度，而是理解率。很多朋友会单纯地认为，记住就是一种理解，其实，记住的东西并不代表我们真的理解了，但理解了的东西你一定深刻地记住了。 张五常先生也说过，我们在读书的时候，要追求以理解代替记忆，而想要让自己深刻理解某一个知识或概念，最高效的方法就是以要教授给他人的目标去阅读。 不同学习方式的吸收留存率，其中最高的是教授给别人，教的时候你的吸收留存率可高达90%。 教授给他人这个行为其实就是我们的阅读老师，所谓以教为师，就是让我们体会到：输出是更高效的输人。我们要善于利用去分享给他人的契机，甚至主动去寻找这样的分享，来帮助我们达到完善知识的目的。 我们可以利用去分享给他人的契机，来达到自我知识的完善。 教的方式有两种： 一种是通过口语化的表达； 一种是通过写作化的表达。 每一个人擅长的表达方式不同，但具有不同表达方式的人，可以通过自己擅长的输出;通道来重新检视自己的思考。 重新检视自己的思考之所以重要，是因为这种检视可以帮助我们用口语化的表达去代替抽象的概念和内容。 从上图中，我们可以举一反三； 比如在学校语言过程中，比如学习英语，如何提升听说读写能力，光听不够，需要背诵、多讲、交流，从整个过程中去学习； 我们也可以想想当初是怎样学习自己的母语。 ","date":"2022-12-10","objectID":"/posts/book/how_to_read_book/:3:5","tags":["读书笔记"],"title":"[读书笔记] 如何阅读一本书","uri":"/posts/book/how_to_read_book/"},{"categories":["读书笔记"],"content":"《如何成为一个会读书的人》 ","date":"2022-12-10","objectID":"/posts/book/how_to_read_book/:4:0","tags":["读书笔记"],"title":"[读书笔记] 如何阅读一本书","uri":"/posts/book/how_to_read_book/"},{"categories":["读书笔记"],"content":"关于书 -《如何成为一个会读书的人》 [日]渡边康弘 北京联合出版有限责任公司 ","date":"2022-12-10","objectID":"/posts/book/how_to_read_book/:4:1","tags":["读书笔记"],"title":"[读书笔记] 如何阅读一本书","uri":"/posts/book/how_to_read_book/"},{"categories":["读书笔记"],"content":"新阅读方法,即为自己而读 阅读，大体可以分为两种。 第一种，是理解“作者的观点、意图” 换句话说就是，从第一页的第一行开始看到最后一页的最后一行，一字不落、直线式地阅读常规的应试教育下要求学生必须正确理解文章。 所以，大家习惯于有条理地、有逻辑地理解作者在书里想表达的意见和观点。 碰到小说，就要去享受其体裁、节奏，让白己完全沉浸在故事情节中。既不能读得大快，要花费时间仔仔细细地读， 避免出现理解偏差，又必须要记住书里的内容。 提到读书，持有这种想法的人是非常多的。 另一种，是“为自己而读”； 这种阅读方法是从书里找出一些对自己的人生和日常生活有益的东西，并付诸行动。 ","date":"2022-12-10","objectID":"/posts/book/how_to_read_book/:4:2","tags":["读书笔记"],"title":"[读书笔记] 如何阅读一本书","uri":"/posts/book/how_to_read_book/"},{"categories":["读书笔记"],"content":"阅读七宗罪 如果能摆脱负罪感，肩上的负担就会轻松很多。到那时可能就会觉得当初是多么荒唐，竟然会因为阅读而心力交瘁。阅读可以更有趣，而且能够更加高效地学习各种知识。 负罪感一 要从第一页看到最后一页，不能有任何遗漏 负罪感二 要读书就必须专门腾出时间 负罪感三 看完记不住书里的内容 负罪感四 必须准确理解作者的观点和意见 负罪感五 不愿意在书上画线 负罪感六 有很严重的藏书不读问题 负罪感七 想看得快一点，可是又不愿意速读 负罪感一 要从第一页看到最后一页，不能有任何遗漏 只阅读自己所需的部分即可 负罪感二 要读书就必须专门腾出时间 短时间＋边休息边阅读的效率更高 负罪感三 看完记不住书里的内容 记不住看过的内容也无妨，进行回想练习即可 负罪感四 必须准确理解作者的观点和意见 比起作者的观点，找到对白己 “有用”的内容更重要 负罪感五 不愿意在书上画线 不用勉强自己非得在书上画线 负罪感六 有很严重的藏书不读问题 负罪感七 想看得快一点，可是又不愿意速读 用手指做辅助，既能看得快，还能有效地集中注意力 ","date":"2022-12-10","objectID":"/posts/book/how_to_read_book/:4:3","tags":["读书笔记"],"title":"[读书笔记] 如何阅读一本书","uri":"/posts/book/how_to_read_book/"},{"categories":["读书笔记"],"content":"作者的疑问 不妨遵循以下三个步骤去寻找作者的疑问。 步骤1：阅读书籍的封面和腰封 步骤2：确认作者的简历 步骤3：关注“所谓”，从“序章”和“结语”入手寻找作者的疑问 为了让书籍畅销，编辑与作者大多会将要传递的信息体现在书籍的装帧上。 ","date":"2022-12-10","objectID":"/posts/book/how_to_read_book/:4:4","tags":["读书笔记"],"title":"[读书笔记] 如何阅读一本书","uri":"/posts/book/how_to_read_book/"},{"categories":["读书笔记"],"content":"可以实现理性阅读的 PREP 法 下面介绍一下先思考纲要，边预测边阅读的输出型阅读方法。 有一种名为 PREP 法的输出式思考框架。即观点(Point)、理由 (Reason)、案例 (Example)、结论（Point）的模式。 在这个方法的指导下，阅读 “前言” “目录” “结语” 就能理解书本的大部分内容。 ","date":"2022-12-10","objectID":"/posts/book/how_to_read_book/:4:5","tags":["读书笔记"],"title":"[读书笔记] 如何阅读一本书","uri":"/posts/book/how_to_read_book/"},{"categories":[""],"content":"基础 Learning 250+ advanced English words at a time 最常用1000句英语口语发音示范，太实用了！收藏起来！ 史上最全思维导图，一网打尽英语单词、句型和语法！ 每日一句经典句型188句合集 跟经典影片学英语100集合集-动画片 基础英语口语900句 斯坦福大学教授英语音标发音课程54集全集 ","date":"2022-12-03","objectID":"/posts/language/material/:1:0","tags":[""],"title":"英语素材","uri":"/posts/language/material/"},{"categories":[""],"content":"Method 英语知识、学习方法汇总 英语知识、学习方法汇总 背诵是英语学习的重要途径！ ","date":"2022-12-03","objectID":"/posts/language/material/:2:0","tags":[""],"title":"英语素材","uri":"/posts/language/material/"},{"categories":[""],"content":"系列课程 ","date":"2022-12-03","objectID":"/posts/language/material/:3:0","tags":[""],"title":"英语素材","uri":"/posts/language/material/"},{"categories":[""],"content":"新概念英语 《新概念英语》第一册144课全集 《新概念英语 》第二册96课全集（动画视频+教学视频+音频+文本+课文详解） 《新概念英语》第三册60集全集 《新概念英语》二、三、四册合集 《新概念英语》二、三、四册合集 ","date":"2022-12-03","objectID":"/posts/language/material/:3:1","tags":[""],"title":"英语素材","uri":"/posts/language/material/"},{"categories":[""],"content":"走遍美国 《走遍美国-80集》 《走遍美国》Family Album U.S.A 50集合集 》 10位语言大咖关于英语学习的建议 ","date":"2022-12-03","objectID":"/posts/language/material/:3:2","tags":[""],"title":"英语素材","uri":"/posts/language/material/"},{"categories":[""],"content":"TED TED演讲100篇(1) TED演讲100篇(2) ","date":"2022-12-03","objectID":"/posts/language/material/:4:0","tags":[""],"title":"英语素材","uri":"/posts/language/material/"},{"categories":[""],"content":"纪录片 BBC纪录片：《瘦身十律》 英文纪录片300集+合集 英文纪录片230集+ BBC纪录片：《生命》全10集 英文纪录片100集+ ","date":"2022-12-03","objectID":"/posts/language/material/:5:0","tags":[""],"title":"英语素材","uri":"/posts/language/material/"},{"categories":[""],"content":"BBC 跟BBC学商务英语66集全集 ","date":"2022-12-03","objectID":"/posts/language/material/:6:0","tags":[""],"title":"英语素材","uri":"/posts/language/material/"},{"categories":[""],"content":"China 《中国范儿》188集合集 央视86版《西游记》25集全集 英音英字 《西游记》Journey to the West 全108集 -动画片 用英语向世界介绍中国 Talk about China in English 最适合中国人的慢速情景剧100集合 《三十六计》Thirty-Six Stratagems 双语全文 《英语畅谈中国》全14集 《你好,中国》— (Hello, China)全100集 《孙子兵法》The Art of War 双语全文 《弟子规》Standards for Being a Good Student and Child 双语全文 《70秒·看见中国》See China in 70 seconds 全33集 Amazing China《美丽中国》58+14全集 ","date":"2022-12-03","objectID":"/posts/language/material/:7:0","tags":[""],"title":"英语素材","uri":"/posts/language/material/"},{"categories":[""],"content":"听名著 听读名著学英语70部合集 听读名著学英语：《雾都孤儿》Oliver Twist 听读名著学英语：《阿甘正传》Forrest Gump 听读名著学英语：《小公子方特洛伊》Little Lord Fauntleroy 听读名著学英语：《打赌》The Bet 听读名著学英语：《生命的法则》The Law of Life 哈佛教授Michael Sandel公开课 可以练习听力哟～ Justice: What’s The Right Thing To Do? 小破站有视频 喜马拉雅有音频～ ","date":"2022-12-03","objectID":"/posts/language/material/:8:0","tags":[""],"title":"英语素材","uri":"/posts/language/material/"},{"categories":[""],"content":"others 牛津在线英语150讲合集 在线观看：美（英）剧资源合集 在线观看：英文电影668部+ 英语听力强化训练188课合集 牛津在线英语100讲合集 ","date":"2022-12-03","objectID":"/posts/language/material/:9:0","tags":[""],"title":"英语素材","uri":"/posts/language/material/"},{"categories":[""],"content":"Songs 经典英文歌曲200首+ 席琳•迪翁30首经典歌曲，震撼全世界！ ","date":"2022-12-03","objectID":"/posts/language/material/:10:0","tags":[""],"title":"英语素材","uri":"/posts/language/material/"},{"categories":[""],"content":"演讲 华东师大女生击败清华、北大的学生，获全国英语演讲比赛冠军！ 英文演讲350篇+合集（含视频、音频和文稿） 伊丽莎白女王二世演讲合集 ","date":"2022-12-03","objectID":"/posts/language/material/:11:0","tags":[""],"title":"英语素材","uri":"/posts/language/material/"},{"categories":[""],"content":"励志 想要成为行业精英？去找个教练吧 励志演讲：人生最低谷并不可怕，只要你肯走，往哪都是上坡 别让任何人打乱你的人生节奏 ","date":"2022-12-03","objectID":"/posts/language/material/:12:0","tags":[""],"title":"英语素材","uri":"/posts/language/material/"},{"categories":["面试"],"content":"need work mac ","date":"2022-12-03","objectID":"/posts/job/inteview/interview-internal/:0:0","tags":["面试"],"title":"转岗面试之路","uri":"/posts/job/inteview/interview-internal/"},{"categories":["面试"],"content":"Daraz 物流相关的job 花费一个周末时间，整理简历； ","date":"2022-12-03","objectID":"/posts/job/inteview/interview-internal/:1:0","tags":["面试"],"title":"转岗面试之路","uri":"/posts/job/inteview/interview-internal/"},{"categories":["面试"],"content":"第1轮 技术面 面试官为认识的一个合作过的P8，之前有些工作上的交集，这里主要介绍了daraz这边的概况； ","date":"2022-12-03","objectID":"/posts/job/inteview/interview-internal/:1:1","tags":["面试"],"title":"转岗面试之路","uri":"/posts/job/inteview/interview-internal/"},{"categories":["面试"],"content":"第2轮 hr面 问题： 用三个词形容你自己和你的专业能力？ 对下一份工作的期待？ 你有什么问题吗？ ","date":"2022-12-03","objectID":"/posts/job/inteview/interview-internal/:1:2","tags":["面试"],"title":"转岗面试之路","uri":"/posts/job/inteview/interview-internal/"},{"categories":["面试"],"content":"第3轮 CTO面 问题： 对下一份工作的期待？ 你有什么问题吗？ ","date":"2022-12-03","objectID":"/posts/job/inteview/interview-internal/:1:3","tags":["面试"],"title":"转岗面试之路","uri":"/posts/job/inteview/interview-internal/"},{"categories":["面试"],"content":"第2次 技术面 问题： dd dd dd ","date":"2022-12-03","objectID":"/posts/job/inteview/interview-internal/:1:4","tags":["面试"],"title":"转岗面试之路","uri":"/posts/job/inteview/interview-internal/"},{"categories":["面试"],"content":"第3次 简历沟通 用户增长方向的机会，可以去新加坡； 因当前已收到LZD offer，友好表达谢意，谢绝面试要求；（算是距离新加坡最近的一次机会，英语和技术、管理等也需要再夯实牢固） ","date":"2022-12-03","objectID":"/posts/job/inteview/interview-internal/:1:5","tags":["面试"],"title":"转岗面试之路","uri":"/posts/job/inteview/interview-internal/"},{"categories":["面试"],"content":"LZD ","date":"2022-12-03","objectID":"/posts/job/inteview/interview-internal/:2:0","tags":["面试"],"title":"转岗面试之路","uri":"/posts/job/inteview/interview-internal/"},{"categories":["面试"],"content":"第1轮 技术面 介绍了组织架构 ","date":"2022-12-03","objectID":"/posts/job/inteview/interview-internal/:2:1","tags":["面试"],"title":"转岗面试之路","uri":"/posts/job/inteview/interview-internal/"},{"categories":["面试"],"content":"第2轮 HR面 问题： dd dd dd ","date":"2022-12-03","objectID":"/posts/job/inteview/interview-internal/:2:2","tags":["面试"],"title":"转岗面试之路","uri":"/posts/job/inteview/interview-internal/"},{"categories":["面试"],"content":"第3轮 大HR面 问题： dd dd dd ","date":"2022-12-03","objectID":"/posts/job/inteview/interview-internal/:2:3","tags":["面试"],"title":"转岗面试之路","uri":"/posts/job/inteview/interview-internal/"},{"categories":["面试"],"content":"转岗流程 11.29上午，收到接收方BU确认信息后，LZD hr告知了4个信息： 每月1号接受转岗入职； LZD职级和集团职级对应关系； 集团股票仍然能继续归属； 依旧base 杭州，不要去深圳； 11.29下午，同现BU主管沟通 在和LZD hr和LZD 技术老板 double check后，确认接受方都ok后，直接约当前主管沟通； 一楼咖啡厅聊了半个小时左右；大家心照不宣，主管也无挽留之意，好聚好散，当然做人留一线，日后好相见； 同现BU HR沟通 主管和大主管汇报后，反馈直接和HR聊； 后来说HR最近比较忙，要晚几天才能聊； 约了12.2上午 同HR聊, HR简要问下去向，为什么离开，一些官方话等； 信息同步LZD HR ","date":"2022-12-03","objectID":"/posts/job/inteview/interview-internal/:2:4","tags":["面试"],"title":"转岗面试之路","uri":"/posts/job/inteview/interview-internal/"},{"categories":["English"],"content":"vocabulary capacity:容量 mutex: 互斥 generic: 泛型、通用的 Java 泛型（generics） Java Generics and Inheritance Java 泛型和继承 violated 违反 ","date":"2022-11-18","objectID":"/posts/language/vocabulary/:1:0","tags":["English"],"title":"vocabulary","uri":"/posts/language/vocabulary/"},{"categories":[""],"content":"1. Can you introduce yourself? I am from Henan Province. My major is Computer science and technology. I graduated from Zhejiang University in 2016 I like reading, sports, fitness, such as: playing Badminton, running, mountain climbing and so on. I also like to travel. For example: I went to Xinjiang province in July this year. There are so many beautiful places in Xinjiang, such as snow mountains, delicious food and fruits, and It’s not hot here in summer, it’s cool. I really like the temperature here. I joined ALi in 2018 as a senior development engineer. Since joining Ali, I have been working in campaign domain to support AliExpress’ business. So I have a lot of work experience in campaign domain. Although I am a coder, I have a strong business mind, I have given my advice in many projects and got good business feedback. in this field; OK That’s it, thank you. ","date":"2022-11-17","objectID":"/posts/english/:1:0","tags":[""],"title":"English","uri":"/posts/english/"},{"categories":[""],"content":"2. Please describe yourself in 3 words? Responsible. Professional. Friendly/kind. Positive trustworthy hardworking ","date":"2022-11-17","objectID":"/posts/english/:2:0","tags":[""],"title":"English","uri":"/posts/english/"},{"categories":[""],"content":"3. Why did you leave your last job? I worked there for 4 years. I have learned a lot of skills and knowledge. The job and the company were wonderful. But there was no opportunity for further advancement. I think I need challenging work. At my current company, there isn’t room for growth. I’m looking for a bigger challenge to increase my work experience. ","date":"2022-11-17","objectID":"/posts/english/:3:0","tags":[""],"title":"English","uri":"/posts/english/"},{"categories":[""],"content":"4. Why do you want to join lzd? Why do you want to work for us? I think lzd is the number one e-commerce platform in South Asia. I really want to join because I think localization is an opportunity. I want to give it a try in this field. I hope to work in English environment at some point. I hope the future career development will be better. OK That’s it, thank you. ","date":"2022-11-17","objectID":"/posts/english/:4:0","tags":[""],"title":"English","uri":"/posts/english/"},{"categories":[""],"content":"5. What’s you most careful in the following job? work environment:in English environment ","date":"2022-11-17","objectID":"/posts/english/:5:0","tags":[""],"title":"English","uri":"/posts/english/"},{"categories":[""],"content":"6. Can you take a brief introduce about your project? Focus on demand with PD and business side. Develop a project plan. Design technical solutions. Project development, problem solving Control project risks. Review project results. ","date":"2022-11-17","objectID":"/posts/english/:6:0","tags":[""],"title":"English","uri":"/posts/english/"},{"categories":[""],"content":"What are your strong points and weak points? I am a good listener and communicator. I can finish job successful. My friends think I’m too hardworking because they complain that they don’t see me enough. but I think it’s all worth it. I pay too much attention to details. because I always want the best result from each job I do. I don’t know much about the e-commerce environment in Southeast Asia. I pay too much attention to details. This could sometimes lead to inefficiency. ","date":"2022-11-17","objectID":"/posts/english/:7:0","tags":[""],"title":"English","uri":"/posts/english/"},{"categories":["读书笔记"],"content":"概要 《金字塔原理》介绍了一种能清晰地展现思路的高效方法，是训练思考、使表达呈现逻辑性的实用宝典。金字塔原理能将零散的观点有序组织起来，化繁为简，适合所有需要精进思考、分析、表达能力的读者。 深入思考：建立金字塔思维，提取有价值的信息，找到问题的关键，将复杂的问题变得清晰简单。 解决问题：从基本事实切入直击要点，制定严谨合理的解决方案，突破瓶颈。 项目管理：明确目标，制定行动计划，根据MECE原则合理分配任务，不重叠、无遗漏。 清晰表达：陈述项目、演讲、讨论时，清晰呈现自己的观点，说服听众，与上级、同事、客户迅速建立共识，高效沟通。 轻松写作：挖掘读者的关注点、兴趣点、利益点，写出重点突出、条理鲜明的策划方案、分析报告、精彩文案和PPT，让人过目不忘。 ","date":"2022-11-13","objectID":"/posts/book/pyramidprinciple/:1:0","tags":["读书笔记"],"title":"[读书笔记] 《金字塔原理》","uri":"/posts/book/pyramidprinciple/"},{"categories":["读书笔记"],"content":"要点汇总 ","date":"2022-11-13","objectID":"/posts/book/pyramidprinciple/:2:0","tags":["读书笔记"],"title":"[读书笔记] 《金字塔原理》","uri":"/posts/book/pyramidprinciple/"},{"categories":["读书笔记"],"content":"第1章 为什么要用金字塔结构 为了交流方便，必须将思想（观点、结论、要点、论点、论据、建议、行动、步骤等）归类分组。 将分组后的思想，按照不同层次，进行抽象提炼、总结概括，搭建金字塔。 向读者介绍（传递、阐述、论证）思想最有效的途径，是结论先行，自上而下表达。 金字塔中的思想，应遵守4个基本原则（见右图）。 条理清晰的关键，是把你的思想组织成金字塔结构，并在写作前用金字塔原理检查。 关键概念 金字塔原理的 4个基本原则 结论先行： 每篇文章只有一个中心思想，并放在文章的最前面。 以上统下：每一层次上的思想必须是对下一层次思想的总结概括。 归类分组：每一组中的思想必须属于同一逻辑范畴。 逻辑递进：每一组中的思想必须按照逻辑顺序排列。 ","date":"2022-11-13","objectID":"/posts/book/pyramidprinciple/:2:1","tags":["读书笔记"],"title":"[读书笔记] 《金字塔原理》","uri":"/posts/book/pyramidprinciple/"},{"categories":["读书笔记"],"content":"第2章 金字塔内部的结构 金字塔结构的各个层级上包括各种思想；思想使受众（包括读者、听众、观众或学员）产生疑问。 在纵向方向上，各分支、各层级上的思想，与读者进行疑问/回答式对话。 在横向方向上，各种思想以演绎推理或归纳推理方式回答读者的疑问，但两种方式不可同时使用。 序言的讲故事形式是为了提醒读者，文章将回答的读者最初的疑问。 序言包括背景、冲突、读者的疑问和作者的回答。冲突因背景而产生，背景和冲突都是读者已知的事实。 冲突导致读者提出疑问，而文章将回答读者的疑问。 关键概念 金字塔结构中的逻辑关系 各种思想纵向相关（疑问／回答式对话）。 各种思想横向相关（演绎／归纳 ）。 金字塔顶端思想回答的疑问，来自读者已有的疑问。 序言引出读者最初的疑问。 ","date":"2022-11-13","objectID":"/posts/book/pyramidprinciple/:2:2","tags":["读书笔记"],"title":"[读书笔记] 《金字塔原理》","uri":"/posts/book/pyramidprinciple/"},{"categories":["读书笔记"],"content":"第3章 如何构建金字塔 自上而下法 确定作者想论述的主题 设想读者的疑问 给出答案 检查背景和冲突是否引发读者提出疑问 证实答案 填写关键句要点 自下而上法 列出所有作者想表达的要点 找出各要点之间的关系 得出结论 倒推出序言 关键概念 构建金字塔结构 确定主题 设想疑问 给出答案 检查背景和冲突是否引发读者提出疑问 证实答案 填写关键句要点 ","date":"2022-11-13","objectID":"/posts/book/pyramidprinciple/:2:3","tags":["读书笔记"],"title":"[读书笔记] 《金字塔原理》","uri":"/posts/book/pyramidprinciple/"},{"categories":["读书笔记"],"content":"第4章 序言的具体写法 序言的目的是提示读者已知的信息，而不是提供新信息。 序言通常包括背景、冲突、读者的疑问和作者的答案。 序言的长短，取决于读者的需要和主题的要求。 为每个关键句要点写一段引言。 关键概念 写序言 说明背景 指出冲突 冲突引发读者提出疑问 作者的文章给出答案 ","date":"2022-11-13","objectID":"/posts/book/pyramidprinciple/:2:4","tags":["读书笔记"],"title":"[读书笔记] 《金字塔原理》","uri":"/posts/book/pyramidprinciple/"},{"categories":["读书笔记"],"content":"第5章 演绎推理与归纳推理 演绎推理是一种论证，其中### 第二个论点对### 第一个论点加以评论，### 第三个论点说明前两个论点同时存在时的含义。 对演绎推理的概括，就是把最后一个论点作为主体，概括整个推理过程。 归纳推理是把具有相似性的思想归类分组，根据各要点具有的共同性得出结论。 在关键句层次，使用归纳推理比演绎推理更方便读者理解。 关键概念 逻辑推理 演绎推理，是一系列线性推理过程。 归纳推理，是把相似的、具有共同点的思想或相关的行动归类分组。 在关键句要点层次，使用归纳推理，比演绎推理更利于读者理解。 ","date":"2022-11-13","objectID":"/posts/book/pyramidprinciple/:2:5","tags":["读书笔记"],"title":"[读书笔记] 《金字塔原理》","uri":"/posts/book/pyramidprinciple/"},{"categories":["读书笔记"],"content":"第6章 应用逻辑顺序 应用逻辑顺序可以确保你不会： 把新闻条目当做思想列入 遗漏某一组中重要的思想 任一组思想的逻辑顺序都呈现了该组思想的分组基础。 时间顺序：通过设想某一流程，得出的思想。 结构顺序：通过评论某一结构，得出的思想 程度顺序：通过按程度或重要性不同分组，得出的思想。 如果你在某一组思想中找不到以上顺序，说明这些思想之间不存在逻辑关系，或者你的思考还不周全。 为了检查一组思想的逻辑顺序，你可以： 先把每一个句子改写成能说明其实质的短句（即只保留主语、谓语、宾语，删除定语、状语和补语，只保留动词、名词，删除形容词、副词）。 再把相匹配或具有共同点的句子合并同类项，组织在一起。 最后选择使用适当的顺序。 如果思想属于行动性思想（即说明行动、活动、行为、动作、步骤、流程等） 明确说明每一行动产生的最终结果（效果、目标）。 把能产生同样最终结果的行动（行为、步骤等）归类分组。 确定该组思想的分组基础（类别），并依此排序。 检查是否遗漏了任何步骤。 关键概念 将行动性思想（说明行动、活动、行为、步骤、流程）排序 明确说明每一行动产生的最终结果。 把能产生相同最终结果的思想合并、归类、分组。 确定该组思想的分组基础，并依此排序。检查是否遗漏了任何步骤。 如果思想属于描述性思想（即介绍观点、情况、信息等） 把说明类似事务，或具有共同点的思想归类分组。 确定该组思想的分组基础（找出相似之处、共同点）。 关键概念 归纳组合逻辑顺序共有3种 时间顺序：通过设想某一流程得出的思想。 结构顺序：通过评论某一结构得出的思想。 程度顺序：通过按程度或重要性的不同分组，得出的思想。 关键概念 将描述性思想（介绍观点、论点、论据、情况、信息）排序 把说明类似事务、或具有共同点的思想归类、合并、分组。 确定该组思想的分组基础。 把所有思想转换成完整的句子，并决定其顺序。 检查是否遗漏了任何步骤。 ","date":"2022-11-13","objectID":"/posts/book/pyramidprinciple/:2:6","tags":["读书笔记"],"title":"[读书笔记] 《金字塔原理》","uri":"/posts/book/pyramidprinciple/"},{"categories":["读书笔记"],"content":"第7章 概括各组思想 避免使用“缺乏思想”的句子（比如“存在3个问题……”等）。 分组应遵守“相互独立不重叠，完全穷尽无遗漏”（MECE）原则。 行动总是按时间顺序进行，通过说明行动产生的直接结果，概括行动性思想。 把描述性思想归类分组，是因为该组思想具有共同特性，它们都： 针对同一类主语- 针对同一类谓语（动作或对象） 包含同一类判断 关键概念 概括各组思想 通过说明行动产生的直接结果，概括行动性思想（概括一组行动）。 通过说明各思想具有的共同点、相似性，概括描述性思想（概括一组信息）。 关键概念 寻找思想的共同点 各思想是否针对同一类主题 各思想是否涉及同一类行动 各思想是否针对同一类对象 各思想是否包含同一类观点 将行动性思想分组时，要求： 发掘每一个行动的本质 区分不同的抽象层次（比如，采取一项行动，是必须在另一行动开始之前，还是为了完成另一行动？） 明确说明行动产生的最终结果 直接由行动概括出结果 关键概念 行动性思想分组 发掘每个行动的实质区分行动的不同层次明确说明行动性思想产生的最终结果（效果、目标）直接由行动概括出结果 将描述性思想分组时，要求： 找出句中结构的共同点 确定包括这些思想的最小范畴 说明共同点隐含的意义 关键概念 描述性思想分组 找出主语、谓语、宾语或含义的共同性确定包括这些思想的最小范畴说明共同性隐含的意义 ","date":"2022-11-13","objectID":"/posts/book/pyramidprinciple/:2:7","tags":["读书笔记"],"title":"[读书笔记] 《金字塔原理》","uri":"/posts/book/pyramidprinciple/"},{"categories":["读书笔记"],"content":"第8章 界定问题 展开“问题”的各要素 切入点/序幕（产生问题的具体领域、方面） 困扰／困惑（它的发生打乱了该领域的稳定） 现状R1（你不喜欢该方面正在产生的结果） 目标R2（你希望在该方面得到的结果） 答案（到目前为止，针对问题已经采取的措施，如果采取了的话）。 疑问（为了解决问题，必须做什么） 把界定的问题转换成序言 从左往右再往下 读者最后知道的事实就是冲突 关键概念 界定问题 设想问题产生的领域 说明什么事情的发生打乱了该领域的稳定（困扰／困惑） 确定非期望结果（现状，R1） 确定期望结果（目标，R2） 确定是否已经采取了解决问题的行动 确定分析所要回答的疑问 ","date":"2022-11-13","objectID":"/posts/book/pyramidprinciple/:2:8","tags":["读书笔记"],"title":"[读书笔记] 《金字塔原理》","uri":"/posts/book/pyramidprinciple/"},{"categories":["读书笔记"],"content":"第9章 结构化分析问题 使用诊断框架，呈现存在问题领域的详细结构，展示一个系统内的各个单位是如何相互影响的。 查找具有因果关系的活动 将产生问题的可能原因进行分类 收集资料，以证明或排除结构中导致问题产生的部分 使用逻辑树 产生和检验解决方案 揭示思想一览表的内在关系 ","date":"2022-11-13","objectID":"/posts/book/pyramidprinciple/:2:9","tags":["读书笔记"],"title":"[读书笔记] 《金字塔原理》","uri":"/posts/book/pyramidprinciple/"},{"categories":["读书笔记"],"content":"第10章 在书面上呈现金字塔 用多级标题、行首缩进、下划线和数字编号的方法，突出显示文章的整体结构 表现金字塔结构中主要组合之间的过渡。 表现金字塔结构中主要思想组之间的过渡。 ","date":"2022-11-13","objectID":"/posts/book/pyramidprinciple/:2:10","tags":["读书笔记"],"title":"[读书笔记] 《金字塔原理》","uri":"/posts/book/pyramidprinciple/"},{"categories":["读书笔记"],"content":"第11章 在PPT演示文稿中呈现金字塔 制作文字幻灯片，应尽量简明扼要。 制作图表幻灯片，使传达的信息更简单易懂；在幻灯片的上部说明要传达的信息。 使用故事梗概，简要说明整体结构。 排练，排练，再排练！ ","date":"2022-11-13","objectID":"/posts/book/pyramidprinciple/:2:11","tags":["读书笔记"],"title":"[读书笔记] 《金字塔原理》","uri":"/posts/book/pyramidprinciple/"},{"categories":["读书笔记"],"content":"第12章 在字里行间呈现金字塔 画脑图（在大脑中画图像，或画思维导图） 把图像复制成文字 ","date":"2022-11-13","objectID":"/posts/book/pyramidprinciple/:2:12","tags":["读书笔记"],"title":"[读书笔记] 《金字塔原理》","uri":"/posts/book/pyramidprinciple/"},{"categories":["Tech"],"content":"JDK ","date":"2022-11-12","objectID":"/posts/tech/java/commons/:1:0","tags":["Java"],"title":"Java常用工具类方法","uri":"/posts/tech/java/commons/"},{"categories":["Tech"],"content":"Objects Objects.equal(Object a, Object b) ","date":"2022-11-12","objectID":"/posts/tech/java/commons/:1:1","tags":["Java"],"title":"Java常用工具类方法","uri":"/posts/tech/java/commons/"},{"categories":["Tech"],"content":"JDK8 stream.anyMath(...) ","date":"2022-11-12","objectID":"/posts/tech/java/commons/:2:0","tags":["Java"],"title":"Java常用工具类方法","uri":"/posts/tech/java/commons/"},{"categories":["Tech"],"content":"Function.identity() Function.identity()的使用详解 List\u003cStudent\u003e studentLists = new ArrayList(); // list -\u003e map Map\u003cLong, Student\u003e collect = studentLists.stream() .collect(Collectors.toMap(a -\u003e a.getId(), Function.identity())); Map\u003cLong, Student\u003e collec1 = studentLists.stream() .collect(Collectors.toMap(Student::getId, Function.identity())); ","date":"2022-11-12","objectID":"/posts/tech/java/commons/:2:1","tags":["Java"],"title":"Java常用工具类方法","uri":"/posts/tech/java/commons/"},{"categories":["Tech"],"content":"3方库 ","date":"2022-11-12","objectID":"/posts/tech/java/commons/:3:0","tags":["Java"],"title":"Java常用工具类方法","uri":"/posts/tech/java/commons/"},{"categories":["Tech"],"content":"fastJson JSON.parseObject(str, Obj.class); ","date":"2022-11-12","objectID":"/posts/tech/java/commons/:3:1","tags":["Java"],"title":"Java常用工具类方法","uri":"/posts/tech/java/commons/"},{"categories":["Tech"],"content":"其他 ","date":"2022-11-12","objectID":"/posts/tech/java/commons/:4:0","tags":["Java"],"title":"Java常用工具类方法","uri":"/posts/tech/java/commons/"},{"categories":["Tech"],"content":"volatile privat volatile boolean inited = false; public volatile int inc = 0; ","date":"2022-11-12","objectID":"/posts/tech/java/commons/:4:1","tags":["Java"],"title":"Java常用工具类方法","uri":"/posts/tech/java/commons/"},{"categories":["Tech"],"content":"MapStruct ","date":"2022-11-12","objectID":"/posts/tech/java/commons/:5:0","tags":["Java"],"title":"Java常用工具类方法","uri":"/posts/tech/java/commons/"},{"categories":["Tech"],"content":"背景 在我们日常开发的分层结构的应用程序中，为了各层之间互相解耦，一般都会定义不同的对象用来在不同层之间传递数据，因此，就有了各种 XXXDTO、XXXVO、XXXBO 等基于数据库对象派生出来的对象，当在不同层之间传输数据时，不可避免地经常需要将这些对象进行相互转换。 一般处理两种处理方式： ① 直接使用 Setter 和 Getter 方法转换、 第一种方式如果对象属性比较多时，需要写很多的 Getter/Setter 代码。 ② 使用一些工具类进行转换（e.g. BeanUtil.copyProperties）。 第二种方式看起来虽然比第一种方式要简单很多，但是因为其使用了反射，性能不太好，而且在使用中也有很多陷阱。 MapStruct 是一个代码生成器，它基于约定优于配置方法极大地简化了 Java bean 类型之间映射的实现。自动生成的映射转换代码只使用简单的方法调用，因此速度快、类型安全而且易于理解阅读，源码仓库 Github 地址 MapStruct。总的来说，有如下三个特点： 基于注解 在编译期自动生成映射转换代码 类型安全、高性能、无依赖性 ","date":"2022-11-12","objectID":"/posts/tech/java/commons/:5:1","tags":["Java"],"title":"Java常用工具类方法","uri":"/posts/tech/java/commons/"},{"categories":["Tech"],"content":"原理 通过 debug 可以看出，XXXMapper.INSTANCE 获取到的是接口的实现类 XXXMapperImpl。这个转换器接口实现类是在编译期自动生成; 自动生成的代码和我们平时手写的差不多，简单易懂，代码完全在编译期间生成，没有运行时依赖。和使用反射的实现方式相比还有一个优点就是，出错时容易通过 debug 查询实现源码的方式来定位，而反射相对来说定位问题就要困难很多。 ","date":"2022-11-12","objectID":"/posts/tech/java/commons/:5:2","tags":["Java"],"title":"Java常用工具类方法","uri":"/posts/tech/java/commons/"},{"categories":["Tech"],"content":"使用3个步骤 引入依赖 \u003cdependency\u003e \u003cgroupId\u003eorg.mapstruct\u003c/groupId\u003e \u003cartifactId\u003emapstruct\u003c/artifactId\u003e \u003cversion\u003e1.4.2.Final\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.mapstruct\u003c/groupId\u003e \u003cartifactId\u003emapstruct-processor\u003c/artifactId\u003e \u003cversion\u003e1.4.2.Final\u003c/version\u003e \u003c/dependency\u003e 创建相关转换对象 @Data public class ActivityTypeConfigDO implements Serializable { private Long id; private String name; private String umpConfig; private String extra; } @Data public class ActivityTypeConfigDTO implements Serializable { private Long id; private String name; private UmpConfig umpConfig; private Map\u003cString,String\u003e extra;\\ } 创建转换器类(Mapper) @Mapper public interface ActivityTypeMapper { ActivityTypeMapper instance = Mappers.getMapper(ActivityTypeMapper.class); @Mapping(source = \"umpConfig\", target = \"umpConfig\", qualifiedByName = \"parse2UmpConfig\") @Mapping(source = \"extra\", target = \"extra\", qualifiedByName = \"parse2ExtraMap\") ActivityTypeConfigDTO toActivityTypeConfig(ActivityTypeConfigDO activityTypeConfigDo); List\u003cActivityTypeConfigDTO\u003e toActivityTypeConfigList(List\u003cActivityTypeConfigDO\u003e activityTypeConfigDos); @Named(\"parse2UmpConfig\") default UmpConfig parse2UmpConfig(String umpConfig) { return JSON.parseObject(umpConfig, UmpConfig.class); } @Named(\"parse2ExtraMap\") default Map\u003cString,String\u003e parse2ExtraMap(String extra) { return JSON.parseObject(extra, new TypeReference\u003cMap\u003cString,String\u003e\u003e(){}); } } 获取转换器类(Mapper) 获取转换器的方式根据 @Mapper 注解的 componentModel 属性不同而不同，常用以下2种取值方式： default 默认方式，默认方式，使用工厂方式（Mappers.getMapper(Class)）来获取 上文的示例中都是通过工厂方式获取的，也就是使用 MapStruct 提供的 Mappers.getMapper(Class clazz) 方法来获取指定类型的 Mapper。然后在调用的时候就不需要反复创建对象了，方法的最终实现是通过我们定义接口的类加载器加载 MapStruct 生成的实现类（类名称规则为：接口名称 + Impl），然后调用该类的无参构造器创建对象。核心源码如下所示： private static \u003cT\u003e T doGetMapper(Class\u003cT\u003e clazz, ClassLoader classLoader) throws NoSuchMethodException { try { Class\u003cT\u003e implementation = classLoader.loadClass(clazz.getName() + \"Impl\"); Constructor\u003cT\u003e constructor = implementation.getDeclaredConstructor(); constructor.setAccessible(true); return constructor.newInstance(); } catch (ClassNotFoundException var4) { return getMapperFromServiceLoader(clazz, classLoader); } catch (InvocationTargetException | IllegalAccessException | InstantiationException var5) { throw new RuntimeException(var5); } } spring Spring 的方式，可以通过 @Autowired 注解来获取，在 Spring 框架中推荐使用此方式 对于依赖注入（dependency injection），使用 Spring 框架开发的朋友们应该很熟悉了，工作中经常使用。MapStruct 也支持依赖注入的使用方式，并且官方也推荐使用依赖注入的方式获取。使用 Spring 依赖注入的方式只需要指定 @Mapper 注解的 componentModel = “spring” 即可，示例代码如下： @Mapper(componentModel = \"spring\") public interface SourceMapper { SourceMapper INSTANCE = Mappers.getMapper(SourceMapper.class); @Mapping(source = \"sourceName\", target = \"targetName\") Target toTarget(Source source); } 我们可以使用 @Autowired 获取的原因是 SourceMapper 接口的实现类已经被注册为容器中一个 Bean 了，通过如下生成的接口实现类的代码也可以看到，在类上自动加上了 @Component 注解。 ","date":"2022-11-12","objectID":"/posts/tech/java/commons/:5:3","tags":["Java"],"title":"Java常用工具类方法","uri":"/posts/tech/java/commons/"},{"categories":["内部"],"content":"个人发展 略 ","date":"2022-11-04","objectID":"/posts/tech/al/mine_record/:1:0","tags":["内部"],"title":"内部-个人总结","uri":"/posts/tech/al/mine_record/"},{"categories":["内部"],"content":"技术能力及组织影响力 ","date":"2022-11-04","objectID":"/posts/tech/al/mine_record/:2:0","tags":["内部"],"title":"内部-个人总结","uri":"/posts/tech/al/mine_record/"},{"categories":["内部"],"content":"1. 请简要说明当前核心工作内容 作为AE活动招商技术负责人 对接运营和产品侧需求，从业务和商家视角，深入理解业务上的真实痛点，使用技术的方式，为业务提供产品化的系统解决方案，助力业务快速发展，业务上大促GMV年同比增长20%+ 在系统架构上做架构分层，提升了系统的稳定性，系统的维护成本降低30%以上，同时中台底层能力能够快速扩展，支撑更多的业务站点（如：台湾、香港建站） 横向协同技术链路各域同学，通过共同完成技术项目的方式，快速为业务提供系统化的服务，为AE国际化业务发展提供稳定的技术服务 作为AE活动招商稳定性负责人 为业务方提供流畅、稳定的活动招商系统，为日常和大促提供优质货品池，助力业务GMV连续3年持续增长。 持续完善域内业务和系统的监控项，制定活动域大促招商保障SOP，保障18+次大促项目稳定性，活动域内无任何故障。 ","date":"2022-11-04","objectID":"/posts/tech/al/mine_record/:2:1","tags":["内部"],"title":"内部-个人总结","uri":"/posts/tech/al/mine_record/"},{"categories":["内部"],"content":"技术能力及组织影响力 ","date":"2022-11-04","objectID":"/posts/tech/al/mine_record/:3:0","tags":["内部"],"title":"内部-个人总结","uri":"/posts/tech/al/mine_record/"},{"categories":["内部"],"content":"1. 在技术能力及组织影响力上，支撑本次晋升提名最充分的理由是什么？ 作为活动招商技术负责人 连续3年聚焦支持活动招商业务，快速响应业务诉求，通过技术的能力提供产品化的解决方案（如一盘货招商、反向智能招商、分国家招商等），并拿到良好的业务结果（如FD频道GMV100%增长），受到业务产品侧同学一致好评。 Sirius战役期间表现突出，在项目强度大和人力不足的情况下，历经近6个月的开发迭代，按时按质按量上线全新的招商系统 成功支持了828、双11、黑五大促业务，拿到不错的业务结果。（其中双11GMV增长40%） 研发招商域活动冲突中心、大促控价中心，后续基于业务需求，可快速做到活动冲突和大促控价的能力升級。 作为活动招商稳定性负责人 负责活动域大促稳定性保障，招商数据一致性达到99.99%，制定活动域大促保障应急SOP，保障AE业务18+次大促，期间无任何故障。 2020年，在活动招商研发人力紧张情况下，主动肩负重担责任，全力支持活动业务并取得良好的业务结果；获得国际化中台[双11卓越战将]表彰 ","date":"2022-11-04","objectID":"/posts/tech/al/mine_record/:3:1","tags":["内部"],"title":"内部-个人总结","uri":"/posts/tech/al/mine_record/"},{"categories":["内部"],"content":"项目1-Sirius战役（招商域） 背景是什么？ 随着全球化进程的加速，国际化业务体量与日俱增，但历史业务系统架构相对陈旧，各域系统内或系统间交互链路冗余，开发维护成本巨大，无法快速响应国际化业务需求。 集团内部有多个海外电商业务，业务之间存在以下问题： 各业务在形态上存在共性和差异化，因为技术链路的不统一，业务彼此之间无法做到取长补短，快速复用。 各业务因历史原因各自为战，技术链路各不相同，无法快速有效形成一体化的合力，同时存在人力资源和设备资源的浪费。 解决什么问题？ 历史遗留问题 活动招商经过多个团队的交接和众多项目演化后，当时域内共有10个应用，涉及3个DB， 350+接口，210台机器，运维成本和稳定性风险巨大 效能问题 存在众多冗余的、跨多个系统数据链路交互的服务，接口服务性能低下，商家端接口RT长（平均1.8s+) 老系统技术体系陈旧(如webx、鹊桥等)，架构不合理（涉及10个应用），应用系统臃肿，定位不清晰，研发效能低下，技术侧 响应日常需求平均20人日以上。 招商事后控价功能，每次大促都需要人工介入处理，处理周期1到3天，效能低下，同时事后控价存在业务风险，容易在活动前剔除大量商品， 无任何中台化的系统架构能力，不支持快速建站。 稳定性和运维问题 系统间有较多的依赖，个别服务异常容易导致最上层业务服务异常，稳定性较差。月工单量均300+，大促期工单量均450+ 缺乏有效的日志监控体系，排查定位问题耗时大。 部分系统资源利用率低，存在机器资源浪费。 新老系统切换过程中，需要保障不影响业务的正常运营、卖家的正常使用。 我在其中发挥什么作用？ 概述： 在开发新招商系统的同时，并行保障老系统日常和大促招商，在6个月的过渡期內，支持日常和大促 （328、618大促等）活动的招商售卖。 按时按质按量上线全新的招商系统。 系统架构方面 重构招商系统，选用pandora-boot、dada等集团建议的新技术体系，进行功能开发，并完成业务代码的迁移工作。 设计事前控价技术方案，完成事前控价功能开发，后续大促不再需要人工千预剔除数据，降低人力成本和运维风险。 梳理旧日的数据调用链路，重新设计服务接口，引入选品校验能力，针对高耗时RT服务做性能优化，商家端接口RT整体降低33%（1.8s-\u003e1.25)。 如：一个商家资质校验上层服务，涉及3个应用的4个接口调用，优化只需要调用1次，减少3次调用6次网络耗时。 对接业务产品需求，组织协同优惠域、库存域、数据域、商品域。物流域，店铺域等同学，共同制定技术方案，完成招商商家端功能的开发。 系统设计开发时，预留相关扩展点，便于后续中台化解决方案的扩展和快速建站。 稳定性保障及运维方面： 全域梳理业务点，重构系统，简化应用数量；通过简化服务调用深度、使用买时数据校验等方式，提高服务质量，降低工单咨询量。 设计老系统数据迁移方案，结合离线数据和实时服务同步的方式，将日系统中数据平滑迁移，全过程无故障。 设计新老系统流量切换，以商家账号维度做流量灰度切换，不影响商家的正常使用，全过程无故障。 通过日志埋点的方式，从0-\u003e1建立基于新招商系统的日志监控体系，可以做到系统99%以上问题第一时间发现响应处理，降低故障发生率， 技术赋能业务： 开辟新思路，以活动招商域内数据为信息源，从0-\u003e1搭建活动招商数据平台，为业务提供数据驱动的系统解決方案 最终结果如何？ 技术侧： 全新的系统架构，按时上线交付全新的招商系統。 新系统上线后共包含2个应用，112个接口（服务收敛65%），60台机器（服务器缩容71%)，降低运维成本。 提升服务性能，商家端接口RT整体降低33%(1.8s-\u003e1.2s)。 技术侧响应日常需求平均10人日内，成本降低50%。 系统上线后月工单量均180+，咨询量降低40%。 具备中台化的能力,可以基于系统快速进行扩展建站。如：招商系统后期被快速复用手台湾建站和香港建站； 成功支撑了AE后续各类日常和大促，如828大促、双11、黑五大促业务。整个系统上线后未产生P3及以上故障。 业务侧： 系统按时上线，并成功支撑了大促业务，拿到非常不错的业务结果。（各大促GMV同比都显著提高，其中双11同比增长40%+） 运营侧通过招商小二工作台一站式快速高效进行业务操作，如活动创建、招商、 审品、圈品等； 全新的系统交互体验，便捷顺畅的操作体验，深受商家好评，PSAT得分100-\u003e122; ","date":"2022-11-04","objectID":"/posts/tech/al/mine_record/:3:2","tags":["内部"],"title":"内部-个人总结","uri":"/posts/tech/al/mine_record/"},{"categories":["内部"],"content":"项目2-一盘货招商项目 背景是什么？ Sirius战役后，国际化进程加速，AE业务侧整体得到了快速发展，在业务举办大促活动时，营销小二需要收拢整个业务侧活动规 则，统一平台大促价格力心智。但当前平台活动的招商模式无法满足业务诉求，没有收拢活动规则的基础能力。 当前AE活动招商业务中没有像淘系一盘货招商模式的业务抓手，业务团队之间在多招商场景情况下容易产生活动入口冲突，不具 备有业务灵活度。如：在大促场景下，大促项目组营销小二需要在业务上收拢活动规则，全局把控活动门槛，但各个行业因为业务 上的差异性，各个行业的招商门槛要求不同，需要针对不同的门槛要求创建多场招商活动。营销小二和行业运营每次大促前都需要 对焦各个活动的门槛要求，沟通成本巨大。 运营审核效能方面，业务运营在大促期因活动模式的限制，需要对同一商品反复申核，大促期运营之间沟通效率低，招商成本 大;商家报名时，面对众多招商活动入口，容易产生困惑，需要提高商家查找入口的效率。审核的不确定性让商家经营成本增加； 解決什么问题？ 架构问题 中台招商系统设计之初，因业务的局限性，没有一盘货招商的场景，所以系统缺少一盘货招商的基础能力。 一盘货招商包含很多功能项，如先报入围报玩法、活动不冲突、不互斥、关联禁编、关联退出活动等，中台系统需要构建一盘 货招商的模型，并提供后续扩展能力。 自动化审品能力：当前系统并无自动化审品能力，需要具备一种自动化审品的能力。 效能问题 活动报名：大促期间当有批量商品报名参加活动时，库存查询服务超时较高，容易引发线上问题。 稳定性和运维问题 当前无一盘货招商模式的服务监控体系。 项目上线时，需要保障不影响日常招商，不影响卖家的使用，PSAT得分 不能降低（当前120） 我在其中发挥什么作用？ 作为活动招商PM 业务需求对接，组织优惠域、选品域、库存域同学共同讨论制定技术方案 把控项目风险，保障项目按时按质按量上线。 作为招商核心研发 域内设计开发，跨域技术对接，开发联调。保障功能按期发布上线； 设计自动化审品方案，取商品报名时刻和设定自动审品时刻的区间差，通过消息延迟消费的基础能力，实现中台系统的自动化审品能力。 结合线上库存服务超时的实际问题，优化招商和库存老接口的数据交互，适度增加调用次数，同时推动库存域同学优化批量查询库存的接口服务，约定接口服务SLA，改造后库存服务超时量下降明细 （日均230次-\u003e0），RT均值人150ms降到50ms。 作为活动稳定性负责人 新增分国家维度服务日志，持续丰富招商系统监控项，做到第一时间自主发现问题。 制定项目发布策略，降低发布对日常招商的影响。 最终结果如何 技术侧： 活动招商系统能力扩展，支持一盘货招商、自动化审品等。 中台系统沉淀出自动化审核的能力，后期被快速复用于其他业务线：如香港站 库存服务超时量下降，服务RT均值从150ms降到50ms。 一盘货库招商系统上线至今，未出任何故障。 业务侧： 系统按时按质按量上线，成功支持了AE328十周年大促。 小二合作模式变革，提供新的一盘货招商模式，让营销小二主导大促价格心智的合作模式在系统有了支撑点。招商入口从双11的285到328大促的78，减少了73%, 商家报名效率方面，收拢招商报名活动入口，减少了大量活动入口，提高商家查找入口的效率。活动商品数/商家数较去年分别提升209%/67%，平台活动参与度较去年有所提升，招商目标达成率为217%， 运营审核效能方面，入围活动报名通过自动化审核的能力，大幅度减低小二审品压力，328大促商品平均审核时间89小时，较去年双11大促的255.5h平均时长，审品效率提升186.5%。 整个2020年所有S级和部分A级大促，都采用一盘货模式招商，覆盖商品量1600W+。 ","date":"2022-11-04","objectID":"/posts/tech/al/mine_record/:3:3","tags":["内部"],"title":"内部-个人总结","uri":"/posts/tech/al/mine_record/"},{"categories":["内部"],"content":"项目3-分国家营销(招商) 背景是什么？ 国家本地化是当前AE业务侧的平台战略。AE作为集团国际化电商排头兵，经过10年的发展，己覆盖全球200多个国家和地区， 支持18种本地语言和50多种本地币种的全球化电商平台：为更好的满足本地消费者的诉求，业务上逐渐从粗放型的一盘货一种方 式卖全球，进入到数据驱动国家差异化和精细化运营的深水区。 当前国家本地重要活动差异化营销抓手 不够，例如，国家本地促销节点与中台大促时间不一致，国家重点商家缺乏差异化优惠抓 手，在本地电商发力时、跟进抓手不足，本地商家对AE平台的售 卖信心 下降，其他本地商家看不到平台带来的营收机会，供给侧 跨境与本地不平衡问题无法得到改善。 AE业务侧今年有四大战略，本地化是其中之一，为了快速发展业务，本地化团队需要有本地化的运营策路，首先需要有本地化的 国家活动。 解决什么问题？ 架构问题 中台招商系统设计之初，没有分国家业务场景，所以没有分国家招商模式，系统底层不具备分国家维度的扩展能力 分国家活动招商包含很多子功能，如分国家招商、折扣、控价、最低价、活动冲突、打标投放等等，底层系统需要重新设计，并提供后续扩展能力。 效能问题 因早期业务的局限性，线上控价设计上不具备有多控价并行的能力。控价模型需要进行能力扩展，同时控价服务RT较高（平均50ms+) 稳定性和运维问题 当前不具备分国家维度的服务监控体系。 分国际项目上线后，需要保障不影响global招商的正常运营，不影响卖家的使用，工单咨询量不能有大量上升(当前月均210） 我在其中发挥什么作用？ 作为活动招商PM 业务需求对接，组织招商、优惠域、物流域同学共同讨论制定技术方案。 把控项目风险，保障项目按时按质按量上线。 作为招商核心研发 域内设计开发，跨域技术对接，开发联调。保障功能按期发布上线。 重构建活动模型，在已有活动模型的基础上，增加扩展宇段，提升整个模型的扩展能力，支持分 国家招商。 和优惠域同学进行多次沟通对接，提出了在不同场景下（活动和报名维度） 分别新增扩展点的建议，在实现分国家招商营销数据对接的基础上，同时減少业务数据冗余。 重构事前控价和活动报名折扣模型，新增扩展点，提升模型的扩展力，实现多控价并行、分国家控价、按活动排除控价、分国家设置折扣的功能。 推动测试进行控价服务压测，发现opensearch在高QPS情况下会出现rt增加的问题，通过动态调配opensearch和DB查询流量比的方式，优化服务性能，控价服务RT均值人50ms降到23ms，同时QPS峰值人550提升致950。 作为活动稳定性负责人 新增分国家维度服务日志，持续丰富招商系统监控项，做到第一时间自主发现问题。 系统上线前，正值328大促招商，为避免对线上服务产生影响，制定项目发布策路，降低发布对大促招商的影响。 最终结果如何？ 技术侧： 活动招商系统能力扩展，支持分国家活动招商报名、控价、分国家折扣、活动冲突、氛围打标等 系统具备分国家能力，后续可以更快速的实现基于分国家场景的业务诉求。 控价服务RT均值从50ms降到23ms，同时QPS峰峰值人人550提升致950。 系统上线后，招商域月工单咨询未见上升（月均210） 上线后至今3个月，系统运行良好，无故障 业务侧： 业务可以使用平台系统能力，对具体国家进行差异化营销（折扣、氛围打标、价格管控等都做到国家粒度)，本地商家参加本地 国家活动积极性高涨，平台营销效果被放大。 分国家项目活动招商域内按期发布上线，业务侧正常使用，同时取得良好的业务结果：法国日国家活动爆发系数1.76， GMV完 成度120%。巴西母亲节分国家GMV完成率109%。 未来AE国家站将举办更多场分国家活动，平台系统的分国家能力将在业务侧产生更大的商业价值。 《业务复盘结果》 ","date":"2022-11-04","objectID":"/posts/tech/al/mine_record/:3:4","tags":["内部"],"title":"内部-个人总结","uri":"/posts/tech/al/mine_record/"},{"categories":["内部"],"content":"技术价值和业务判断 ","date":"2022-11-04","objectID":"/posts/tech/al/mine_record/:4:0","tags":["内部"],"title":"内部-个人总结","uri":"/posts/tech/al/mine_record/"},{"categories":["内部"],"content":"请阐述在你的工作中，技术产生了哪些业务价值 作为AE活动技术负责人 在sirius项目中做全面的系统重构，后续持续优化系统，通过缓存前置增加、新增活动、分国家等扩展点的方式，提升了架构稳 定性和扩展性。 同时横向支持了一盘货招商、物流模板升级、盘商盘货、一盘货满包邮、联盟U选、跨店满减！分国家营销等项目，取得不错的业务结果。 反向智能招商项目中，提出自己的建议，通过商家的一次交互，运用消息异步处理机制，实现商品大批量报名，取得业务和技 术的双赢。项目上线后，仅FD频道日同比GMV100%+增长。 开辟新思路，以活动招商域内数据为信息源，从0-＞1搭建招商指南针数据平台，并持续丰富数据指标，为运营提供数据驱动的 系统解决方案，业务方依据数据做出商业决策。 作为AE活动稳定性负责人，制定活动域大促保障SOP，保障18+次大促稳定性项目，活动域内无故障，业务上历次大促GMV年 同比增长20%+。 ","date":"2022-11-04","objectID":"/posts/tech/al/mine_record/:4:1","tags":["内部"],"title":"内部-个人总结","uri":"/posts/tech/al/mine_record/"},{"categories":["内部"],"content":"关于未来，你什么新的规划，能够帮助你所负责的工作继续突破 作为AE活动招商技术负责人，在过去的3年里，持续支持活动招商业务，具备丰富的业务知识 关于未来，希望可以基于过去的经验积累，继续深入理解商家和业务上的真实痛点，通过运用技术的能力，产出系统化的解决 方案，帮助商家和业务降本提效。 国家本地化：通过引入算法推荐、扩展中台系统在国家差异化方面的能力等方式，助力业务的本地化战略。商家体验提升：通过对商家平台和活动招商做体验优化的方式，提升卖家PSAT满意度，为商家降本提效。 数据能力：通过对活动招商的数据做各种维度的量化分析，挖掘数据价值，反哺业务，为业务决策提供数据抓手 价格力：通过包含但不限于控价形式的价格管控手段，保障平台大促商品在同时期全行业中的价格竞争力。 稳定性：在优化系统架构的同时，持续丰富活动平台的监控项，保障系统的稳定性；优化大促保障SOP，持续为业务提供稳定的系统能力。 团建建设：培养新人，打造稳定的活动招商团队。人才引入，培养活动招商的专业人才。 ","date":"2022-11-04","objectID":"/posts/tech/al/mine_record/:4:2","tags":["内部"],"title":"内部-个人总结","uri":"/posts/tech/al/mine_record/"},{"categories":["内部"],"content":"在我们对数据库技术方案设计的时候，我们是否有自己的设计理念或者原则，还是更多的依据自己的直觉去设 计，是否曾经快悔线上发生过的一次低級故障，可能稍微注意点就可以避免，是否想过怎么才能很好的避免，下面 规范的价值正是我们工作的检查清单，需要我们不断从错误中积累有效经验来指导未来的工作。 以下规范在大型互 联网公司经过了充分的验证，尤其适用于并发量大、数据量大的业务场景。 先介绍的是安全规范，因为安全无小事，很多公司都曾经因为自己的数据泄露导致用户的惨痛损失，所有将安全规范放到了第一位。 ","date":"2022-11-02","objectID":"/posts/tech/al/db_design/:0:0","tags":["内部"],"title":"内部-技术同学必会的MySQL设计规约，都是惨痛的教训","uri":"/posts/tech/al/db_design/"},{"categories":["内部"],"content":"1. 安全规范 【强制】禁止在数据库中存储明文密码，需把密码加密后存储 说明：对于加密操作建议由公司的中问件团队基于如mybatis的扩展，提供统—的加密算法及密钥管理，避免每个 业务线单独开发一套，同时也与具体的业务进行了解耦 【强制】禁止在数据库中明文存储用户敏感信息，如手机号等 说明：对于手机号建议公司搭建统一的手机号查询服务，避免在每个业务线单独存储 【强制】禁止开发直接给业务同学导出或者查询涉及到用户敏感信息的数据，如需要需上级领导軍批 【强制】涉及到导出数据功能的操作．如包含敏感字段都需加密或脱敏 【强制】跟数据库交互涉及的敏感数据操作都需有审计日志，必要时要做告警 【强制】对连接数据库的1P需设置白名单功能，杜绝非法P接入 【强制】对重要sql（如订单信息的查询）的访问频率或次数要做历史趋势监控，及时发现异常行为 【推荐】线上连接数据库的用户名、密码建议定期进行更换 ","date":"2022-11-02","objectID":"/posts/tech/al/db_design/:1:0","tags":["内部"],"title":"内部-技术同学必会的MySQL设计规约，都是惨痛的教训","uri":"/posts/tech/al/db_design/"},{"categories":["内部"],"content":"2. 基础规范 【推荐】尽量不在数据库做运算，复杂运算需移到业务应用里完成 【推荐】拒绝大sq语句、拒绝大事务、拒绝大批量，可转化到业务端完成 说明：大批量操作可能会造成严重的主从延迟，binlog日志为row格式会市生大量的日志 【推荐】避免使用存储过程、触发器、西数等，容易造成业务逻辅与DB耦合 说明：数据库擅长存储与索引。 要解放数据库CPU，将计算转移到服务层．也具备更好的扩展性 【强制】数据表．数据字段必须加入中文注释 说明：后续维护的同学看到后才清楚表是干什么用的 【强制】不在数据库中存储图片，文件等大数据 说明：大文件和图片需要储在文件系统 【推荐】对于程序连接数据库账号，遵循权限最小原则 【推荐】数据库设计时，需要问下自己是否对以后的扩展性进行了考虑 【推荐】 使用 pt-query-digest 定期分析slow query log并进行优化 【推荐】使用内网域名而不是ip连接数据库 【推荐】如果数据量或数据增长在前期规划时就较大，那么在设计评审时就应加入分表策略 【推荐】要求所有研发SQL关键字全部是小写，每个词只允许有一个空格 ","date":"2022-11-02","objectID":"/posts/tech/al/db_design/:2:0","tags":["内部"],"title":"内部-技术同学必会的MySQL设计规约，都是惨痛的教训","uri":"/posts/tech/al/db_design/"},{"categories":["内部"],"content":"3. 命名规范 【强制】库名、表名、字段名要小写，下划线风格，不超过32个字符，必幼见名知意，建议使用名词而不是动 词，词义与业务、产品线等相关联，禁止拼音英文混用 【强制】 普通索引命名格式：idx_表名_索弓!字段名(如果以首个宇段名为素号1有至个，可以加上第二个字段 名，太长可以考虑缩写），唯一索引1命名格式：uk_表名_索引字段名（索引!名必须全部小写，长度太长可以利用缩写），主键索引1命名：pk_字段名 【强制】库名、表名、宇段名禁止使用MySQL保留字 【强制】临时库表名必须以tmp为前缀，并以日期为后缀 【强制】备份库表必须以bak为前缀，并以日期为后缀 【推荐】用HASH进行散表，表名后缀使用16进制数，下标从0开始 【推荐】按日期时间分表需符合YYYYIMMIIDDJIHH)格式 【推荐】散表如果使用md5 （或者类似的hash算法）进行散表，表名后綴使用16进制，比如user_ff 【推荐】使用CRC32求余（或者类似的算术算法）进行散表，表名后缀使用数宇，数字必须从0开始并等宽，比如散100张表．后绿人00-gg 【推荐】使用时间散表，表名后缀必须使用特定格式，比如按日散表user_20110209 按月散表user_ 201102 [强制】 表达是与否概念的字段．使用 is_ xxx 的方式进行命名 ","date":"2022-11-02","objectID":"/posts/tech/al/db_design/:3:0","tags":["内部"],"title":"内部-技术同学必会的MySQL设计规约，都是惨痛的教训","uri":"/posts/tech/al/db_design/"},{"categories":["内部"],"content":"4.库设计规范 【推荐】数据库使用innoDB存储引擎 说明：支持事务、行级锁、并发性能更好、CPU及内存缓存页优化使得资源利用率更高 【推荐】数据库和表的宇符集统一使用UTF8 说明：ut8号称万国码，其无需转码、无乱码风险且节省空问。若是有字段需要存储emoj表情之类的，则将表或7i2Rutf8mb4, utf8mb4T≥utf8. 【推荐】不同业务，使用不同的数据库，避免互相影响 【强制】所有线上业务库均必须搭建MHA高可用架构，避免单点问题 ","date":"2022-11-02","objectID":"/posts/tech/al/db_design/:4:0","tags":["内部"],"title":"内部-技术同学必会的MySQL设计规约，都是惨痛的教训","uri":"/posts/tech/al/db_design/"},{"categories":["内部"],"content":"5.表设计规范 [推荐]建表规范示例 CREATE TABLE `student info` `id' int (11) unsigned NOT NULL AUTO_INCREMENT COMMENT `` `stu_name` varchar (10) NOT NULL DEFAULT \"* COMMENT 'RER', `stu score` smallint (5) unsigned NOT NULL DEFAULT 'O' COMMENT `` `stu_num` int (11) NOT NULL COMMENT `` `gmt_create' timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT `` `gmt modified' timestamp NOT NULL DEFAULT CURRENT_ TIMESTAMP ON UPDATE CURRENT TIMESTAMP `status` tinvint (4) DEFAULT '1' COMMENT PRIMARY KEY (`id`), UNIQUE KEY 'uk _student_ info_stu num' ('stu_num') USING BTREE, KEY 'idx student_info _stu_name' ('stu_name' ) USING BTREE ) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='' 【强制】禁止使用外键，如果有外键完整性约束，需要应用程序控制 【强制】每个innodb 表必须有一个主键 说明：Innodb 是一种索号组织表，其数据存储的逻辑顺序和索引的顺序是相同的。每张表可以有多个索引，但表 的存储顺序只能有一种，Innodb 是按照主键索引的顺序来组织表的，因此不要使用更新频繁的列如UUID、MD5、 HASH和字符串列作为主键，这些列无法保证数据的顺序增长，主键建议使用自增D 值。 【推荐】单表列数目最好小于50 【强制】禁止使用分区表 说明：分区表在物理上表现为多个文件，在逻辑上表现为一个表，蓮慎选择分区键，跨分区查询效率可能更低，建 议采用物理分表的方式管理大数据 【推荐】拆分大字段和访问频率低的字段，分离冷热数据 了， 〔推荐】采用合适的分库分表策略，例如千库十表、十库百表等(建议表大小控制在2G) 【推荐】单表不超过50个 int字段；不超过20个char字段，不超过2个text字段 【推荐】表默认设置创建时间戳和更改时间戳字段 【推荐】日志类型的表可以考虑按创建时间水平切割，定期归档历史数据 【强制】禁止使用order by rand 说明：order by rand0会为表增加一个伪列，然后用rand(函数为每一行数据计算出rand0值，基于该行排序，这 通常都会生成磁盘上的临时表，因此效率非常低。 【参考】可以结合使用hash、rangew lookup table进行散表 【推荐】每张表数据量建议控制在50oW以下，超过5oow可以使用历史数据归档或分库分表来实现（500万行 并不是MysQL数据库的限制。过大对于修改表结构，备份，恢复都会有很大问题。MysQL没有对存储有限制，取 決于存储设置和文件系统) 【强制】禁止在表中建立预留字段 说明：预留字段的命名很难做到见名识义，预留字段无法确认存储的数据类型，所以无法选择合适的类型：对预留 字段类型的修改，会对表进行锁定 ","date":"2022-11-02","objectID":"/posts/tech/al/db_design/:5:0","tags":["内部"],"title":"内部-技术同学必会的MySQL设计规约，都是惨痛的教训","uri":"/posts/tech/al/db_design/"},{"categories":["内部"],"content":"6.字段设计规范 【强制】必须把宇段定义为NOT NULL并且提供默认值 说明：NULL字段很难查询优化，NULL字段的素引需要额外空间，NULL字段的复合索引l无效 【强制】禁止使用ENUM、可使用TINYINT代替 【强制】禁止使用TEXT、BLOB类型(如果表的记录数在万级以下可以考虑) 【强制】必须使用varchar(20)存储手机号 【强制】禁止使用小数存储国币、使用“分“作为单位，这样数据库里就是整数了 【强制】用DECIMAL代替FLOAT 和DOUBLE存储精确浮点数 【推荐】使用UNSIGNED存储非负整数 说明：同样的字节数，存储的数值范围更大 【推荐】建议使用INT UNSIGNED存储IPV4 说明：用UNSINGED INT存储P地址占用4字节，CHAR(15)则占用15字节。另外，计算机处理整数类型比字符串类 K. (AINT UNSIGNED TECHAR(15)774#IPV4tttit. #iMVSQLtinet ntoaflinet aton#’## 化。IPv6地址目前没有转化西数，需要使用DECIMAL或两个BIGINT来存储。例如： SELECT INET_ATON(‘192.168.172.3’): 3232279555 SELECT INET NTOA(3232279555); 192.168.172.3 【推荐】字段长度尽量按实际需要进行分配，不要随意分配一个很大的容量 [推荐】核心表字段数量尽可能地少，有大字段要考虑拆分 【推荐】适当考虑一些反范式的表设计，增加元余字段，减少JOIN 【推荐】资金字段考虑统一*100处理成整型，避免使用decimal浮点类型存储 【推荐】使用VARBINARY存储大小写敏感的变长宇符串或二进制内容 说明：VARBINARY默认区分大小写，没有字符集概念，速度快 【参考】INT类型固定占用4字节存储 说明：INT(4)仅代表显示宇符宽度为4位，不代表存储长度。数值类型括号后面的数字只是表示宽度而跟存储范国 没有关系，比如INT(3)默认显示3位，空格补齐，超出时正常显示，Python、Java客户端等不具备这个功能 [参考]区分 datetime 和 timestamp 说明：存储年使用YEAR类型、存储日期使用DATE类型、存储时间(精确到秒）建议 使用丁MESTAMP类型 datetime 和 timestamp 都是精确到秒，优先选择 timestamp，因为timestamp只有4个字节，而 datetime8个字节，同时 timestamp具有自动赋值以及自动更新的特性； 补充：如何使用TIMESTAMP的自动赋值属性？ 【推荐】将大字段、访问频率低的字段拆分到单独的表中存储．分陽冷热数据 说明：有利于有效利用缓存，防止读入无用的冷数据，较公磁盛。．周时保证热数据常驻內存提高高缓存命中率 【参考】 VARCHAR(N)，N表示的是宇符数不是字节数，比如VARCHAF(255)，可以最大可存储255个汉宇， 需要根据实际的宽度来选择N 【参考】 VARCHAR(N)，N尽可 能小，因为MySQL—个表中所有的VAFCHAR宇段最大长度是65535个字节， 进行排序和创建临时表一类的内存操作时，会使用N的长度申请内存。 【推荐】varchar(n)，n\u003e5000时，使用BLOB类型 【推荐】使用短数据类型，比如取值范围为0~80时，使用 tinyint unsigned 【强制】存储状态，性别等，用TINYINT 【强制】所有存储相同数据的列名和列类型必须一致（在多个表中的宇段如user_id，它们类型必须一致) 【推荐】优先选择符合存储需要的最小数据类型 24【推荐】如果存储的宇符串长度几乎相等，使用 char 定长字符串类型 ","date":"2022-11-02","objectID":"/posts/tech/al/db_design/:6:0","tags":["内部"],"title":"内部-技术同学必会的MySQL设计规约，都是惨痛的教训","uri":"/posts/tech/al/db_design/"},{"categories":["内部"],"content":"7.索引设计规范 【推荐】单表索引建议控制在5个以内 说明：索引1可以增加查询效率，但同样也会降低插入和更新的效率，甚至有些情况下会降低查询效率，所以不是越 多越好 【强制】禁止在更新十分频繁，区分度不高的属性上建立索引 【强制】建立组合索引必须把区分度高的字段放在前面 【推荐】对宇符串使用索引，如果宇符串定义长度超过128的，可以考虑前綴索引 【强制】表必须有主键，并且是auto_increment及not nul的，根据表的实际情况定义无符号的 tinyint,smallint,int,bigint 【强制】禁止更新频繁的列作为主键 【强制】禁止字符串列作为主键 【强制】禁止UUID MD5 HASH这些作为主键(数值太离散了) 【推荐】默认使用非空的唯一键作为主键 【推荐】主键建议选择自增或发号器 【推荐】核心SQL优先考虑覆盖索引 【参考】避免冗余和重复索引 【参考】索引1要综合评估数据密度和分布以及考虑查询和更新比例 [强制】不在索引1列进行数学运算和西数运算 [推荐】研发要经常使用explain，如果发现索引选择性差，必须要学会使用hint 【推荐】能使用唯一索引就要使用唯一索引，提高查询效率 【推荐】多条字段重复的语句，要修改语句条件字段的顺序，为其建立一条联合索引，减少索引数量 【强制】索引字段要保证不为NULL，考虑default value进去。NULL也是占空间，而且NULL非常影响索引的 查询效率 【强制】新建的唯一索引不能和主键重复 【推荐】尽量不使用外键、外键用来保护参照完整性，可在业务端实现 说明：避免对父表和子表的操作会相互影响，降低可用性 【强制】字符串不应做主键 【强制】表必须有无符号int型自增主键，对应表中id字段 说明：必须得有主键的原因：采用RBR模式复制，无主键的表州除，会导致备库夯佳 ；使用自增的原因： 数据写入可以提高插入性能，避免page分裂，减少表碎片 【推荐】对长度过长的VARCHAR字段建立索引时， 添加orc32或者MD5 Hash字段，对Hash字段建立索引 【推荐】where条件中的非等值条件，(IN、 BETWEEN、 \u003c、\u003c=、＞、＞=）会导致后面的条件使用不了索引 【推荐】索引!字段的顺序需要考虑字段值去重之后的个数，个数多的放在前面 【推荐】 ORDER BY, GROUP BY, DISTINCT的字段需要添加在索引的后面 【参考】合理创建联合索引（避免冗余），如(a,b,c)相当于(a) (a,b) (a.b,c) 【推荐】复合索号1中的宇段数建议不超过5个 【强制】不在选择性低的列上建立索号，例如\"性别\"“状态\"“类型 【推荐】对于单独条件如果走不了索引，可以使用force-index强制指定索引 【强制】禁止给表中的每一列都建立 单独的素引 【推荐】在varchar字段上建立索引时，必须指定素引1长度，没必要对全字段建立索引，根据实际文本区分度决定索引长度即可 ","date":"2022-11-02","objectID":"/posts/tech/al/db_design/:7:0","tags":["内部"],"title":"内部-技术同学必会的MySQL设计规约，都是惨痛的教训","uri":"/posts/tech/al/db_design/"},{"categories":["内部"],"content":"8.SQL使用规范 【强制】禁止使用SELECT *，只获取必要的字段，需要显示说明列属性 说明：按需获取可以减少网络带宽消耗，能有效利用覆盖索引，表结构变更对程序基本无影响。 【强制】禁止使用INSERT INTO tLxXX VALUES(xxX)，必须显示指定插入的列属性 【强制】WHERE条件中必须使用合适的类型，避免MSQL进行隐式类型转化 说明：因为MySQL进行隐式类型转化之后，可能会将索引字段类型转化成-号右边值的类型，导致使用不到索引1， 原因和避免在索引字段中使用西数是类似的，例子 select uid from t_ user where phone=15855550101 (phone 为 varchat 类型，此时查询中使用数宇查询，会导致索引失效） 【强制】禁止在WHERE条件的属性上使用函数或者表达式 【强制】禁止负向查询，以及%开头的模糊查询 【强制】应用程序必须捕获SQL异常，并有相应处理 【推荐】sql语句尽可能简单大的sal想办法拆成小的sql语句 说明：简单的SQL容易使用到MVSQL的querycache、减少锁表时间特别是MVISAM、可以使用三核epu 【推荐】 事务要简单，整个事务的时间长度不要大长 【强制】避免在数据库中进行数学运算或者西数运算(MySQL不擅长数学运算和逻辑判断，也容易将业务逻辑和 DB耦合在一起) 【推荐】sql中使用到OR的改写为用N( (or的效率没有i的效率高） 【参考】SQL语句中N包含的值不应过多，里面数字的个数建议控制在1000个以肉 【推荐】limit分页注意效率。Limt越大，效率越低。可以改写limit 说明：改写例子： 1）改写方法一 延迟回表写法 select xx,xx from t t1, (select id from t where …. limit 10000,10) t2 where t1.id = t2.id 2)改写方法二 select id from t limit 10000, 10; 应该改写为 =\u003e select id from t where id \u003e 10000 limit 10; 【推荐】尽量用union all 代替 union 【参考】避免使用大表JON 【推荐】对数据的更新要打散后批量更新，不要一次更新太三数据 【推荐】使用合理的SQL语句减少与数据库的交互次数 【参考】注意使用性能分析工具 Sql explain / showprofile / mysqisla 【推荐】能不用NOT IN就不用NOT IN，坑大多了，会把空和NULL给查出来 【推荐】 关于分页查询，程序里建议合理使用分 页来提高效率，limit、offset较大要配合子查询使用 【强制】禁止在数据库中跑大查询 【强制】禁止单条SQL语句同时更新多个表 [推荐] 统计表中记录行数使用 cout(), 而不是count(primary_key) 和 count(1) 说明： count()回统计值为NULL的行，而count(列名)此列值为NULL的行 [推荐] INSERT语句使用batch提交，(INSERT INTO tableVALUES0.0.0…..)，values的个数不应过多 [推荐】获取大量数据时，建议分批次获取数据，每次获取数据少于2000条，结果集应小于1M [推荐】 在做开发时建议使用数据库框架(如mybatis)或prepared statement，可以提升性能并遊免SQL注入 【强制】禁止跨库查询 （为数据迁移和分库分表留出余地，降低耩合度，降低风险） 【推荐】尽量避免使用子查询，可以把子查询优化为join操作（子查询的结果集无法使用索引，子查询会产生 临时表操作，如果子查询数据量大会影响效率，消耗过多的CPU及1O资源) [强制】超过三个表禁止 join。( 需要 join 的宇段，数据类型必须绝对一致；多表关联查询时，保证被关联的宇段需要有索引1。即使双表 join 也要注意表索引1SQL 性能。） 【推荐】sQL 性能优化的目标：至少要达到 range 级别，要求是ref 级别，如果可以是 consts最好 【推荐】尽量不要使用物理删除（即直接删除，如果要州除的话提前做好备份），而是使用逻辑删除，使用字段delete flac做逻辑删除，类型为tinyint，0表示未删除，1表示己删除 [强制】在代码中写分页查询逻辑时，若count为0。应直接返回，避免执行后面的分页语句 【强制】程序连接不同的数据库要使用不同的账号 【推荐】使用 ISNULL（来判断是否为 NULL 值 ","date":"2022-11-02","objectID":"/posts/tech/al/db_design/:8:0","tags":["内部"],"title":"内部-技术同学必会的MySQL设计规约，都是惨痛的教训","uri":"/posts/tech/al/db_design/"},{"categories":["内部"],"content":"9.行为规范 【强制】禁止使用应用程序配置文件内的帐号手工访问线上数据库 [强制】禁止非DBA对线上数据库进行写操作，修改线上数据需要提交工单，由DBA执行，提交的SQL语句必须 经过测试 【强制】禁止在线上做数据库压力测试 【强制】禁止从测试、开发环境直连线上数据库 【强制】禁止在主库进行后台统计操作，避免影响业务，可以在离线从库上执行后台統计 ","date":"2022-11-02","objectID":"/posts/tech/al/db_design/:9:0","tags":["内部"],"title":"内部-技术同学必会的MySQL设计规约，都是惨痛的教训","uri":"/posts/tech/al/db_design/"},{"categories":["内部"],"content":"10.流程规范 【强制】所有的建表操作需要提前告知该表法及的查询sa1 【强制〕所有的建表需要确定建立哪些索号后才可以建表上线 【强制】所有的改表结构，加索引操作都需要将法及到所改表的查询-。发出来告知DBA等相关人员 【强制】在建新表加字段之前，要求至少要提前3天邮件出来，给dba们评估，优化和审核的时间 【强制】批量导入，导出数据需要DBA进行审查，并在执行过程中观察服务 【强制】禁止有super权限的应用程序账号存在 (强制】推广活动或上线新功能必须提前通知DBA进行流量评估 【强制〕不在业务高峰期批量更新．查询数据库 【强制】隔离线上线下环境（开发测试程序禁止访问线上数据库) 【强制】在对大表做表结构变更时，如修改字段属性会造成锁表，并会造成从库延迟，从而影响线上业务，必须在凌晨后业务低峰期执行，另统一用工具pt-online-schema-Change避免锁表且降低延迟执行时间 【强制】核心业务数据库变更需在凌晨执行 【推荐】汇总库开启Audit审计日志功能，出现问题时方可追溯 【强制】给业务方开权限时，密码要用MD5加密，至少16位。权限如没有特殊要求，均为select查询权限，并做库表级限制 【推荐】如果出现业务部门人为误操作导致数据丢失，需要恢复数据，请在第一时间通知DBA，并提供准确时间，误操作语句等重要线索 【强制】批量更新数据，如update,delete 操作，需要DBA进行审查，并在执行过程中观察服务 【强制】业务部门程序出现bug等影响数据库服务的问题，请及时通知DBA便于维护服务稳定 【强制】线上数据库的变更操作必须提供对应的回滚方案 【强制】批量清洗数据，需要开发和DBA共同进行审查，应避开业务高峰期时段执行，并在执行过程中观察服务状态 【强制】数据订正如删除和修改记录时，要先 select，确认无误才能执行更新语句，避免出现误删除 ","date":"2022-11-02","objectID":"/posts/tech/al/db_design/:10:0","tags":["内部"],"title":"内部-技术同学必会的MySQL设计规约，都是惨痛的教训","uri":"/posts/tech/al/db_design/"},{"categories":["内部"],"content":"如果我是一线主管 如果我是一线技术主管，可能曾经是团队综合实力最强的，被时间支配不能再每天写代码，但团队各种挑战依旧在； 如果我是一线技术主管，每周也要写周报，每年也要写绩效，想晋升、加薪、人生巅峰云云； 如果我是一线技术主管，团队有五、六个人还好，十几个人的团队的话会希望有人可以站出来帮我; ","date":"2022-11-02","objectID":"/posts/tech/al/tobeleader/:1:0","tags":["内部"],"title":"内部-如果我是一线主管","uri":"/posts/tech/al/tobeleader/"},{"categories":["内部"],"content":"不抱怨 如果我是一线技术主管，我不会喜欢团队喜欢抱怨的同学 我每天也很忙，听一个人抱怨会花时问 一个人抱怨了，自然是有问题的，需要花一定的时间梳理出问题，需要及时给出解决方案，甚至要安抚对方情绪 一个喜欢抱怨的人会影响整个团队的士气 其实大部分开发抱怨的工作内容很相似，无非是自己做的业务是一堆尿，谁谁谁就是不配合我做某事，PD提了无理的需求 大促中我们的后端主管说过句很好理解的话，看到大促这么多问题很激动，这很好，问题越多机会才越 大，如果都是稳定健壮的系统、完善的流程、合作良好的团队，要大促 PM 千什么呢？ 如果是机会的话很多情况下没什么必要抱怨，那真的就是有问题还不能说了吗？ ","date":"2022-11-02","objectID":"/posts/tech/al/tobeleader/:2:0","tags":["内部"],"title":"内部-如果我是一线主管","uri":"/posts/tech/al/tobeleader/"},{"categories":["内部"],"content":"向上管理 恰恰相反，如果我是一线主管，我会迫切希望团队有问题一定要说，甚至没有问题仅仅有想法也要说，但主要是反馈的方式 ","date":"2022-11-02","objectID":"/posts/tech/al/tobeleader/:3:0","tags":["内部"],"title":"内部-如果我是一线主管","uri":"/posts/tech/al/tobeleader/"},{"categories":["内部"],"content":"高效 如果我是一线主管，我更希望团队和我交流的方式是让我做选择题、判断题，而不是问答题、思考题 ","date":"2022-11-02","objectID":"/posts/tech/al/tobeleader/:3:1","tags":["内部"],"title":"内部-如果我是一线主管","uri":"/posts/tech/al/tobeleader/"},{"categories":["内部"],"content":"主动 一个十几人的团队主管很难有精力面面俱到，了解所有人每天的细节，给大家找出合适方向和机会，甚至认真读完每个人的周报都要用一个下午，很难做到你有一个不错想法的时候主管恰好找你聊聊，如果我是—线主管，我更希望团队同学主动找我聊 废话这么多，其实看看向上管理的一些理论知识就会有豁然开朗的感觉，知乎上 很接地气的总结 作为领导他们既要有全局决策的能力，杰出的领导魅力，还要有大量一线数据 客户反馈、团以底层真实 信息、行业趋势分析与总结。很多点不是他一个人能搞定的，除去那些工作上的support， 有时候领导也会 出现信息失察、决策失误的情况，所以向上管理的必要性就出现了。 及时定期总结工作进展、数据、部门问题、行业键信息，以清晰文档的方式递交上级，并同时附上下 阶段计划及问题解决办法 提身而出替上级解决困扰他己久的难题 对于明显有错的重要决策，给出合理分析建议，反馈给领导 以培训、 分享、个人交流等不同方式，“教”领导一些东西 想顺便说一下高质量周报的必要性，很多同学的周报极其敷衍，就是一周的流水账，发送出来都是浪费自 己和收件人的时间，团队不会有人认真读完所有人的周报，取決于周报的质量 个人习惯粗略浏览组内所有人周报（周报有 highlights 多重要），然后会针对有些人的周报设置规则，必 须认真看，遇到不理解的还要过去问，高质量的周报你不主动，圭管都会主动 ","date":"2022-11-02","objectID":"/posts/tech/al/tobeleader/:3:2","tags":["内部"],"title":"内部-如果我是一线主管","uri":"/posts/tech/al/tobeleader/"},{"categories":["内部"],"content":"每天忙不完的业务怎么办 还有一种抱怨的声音是：自己每天很辛苦，想拼命忙完业务后做一些技术的东西，造个轮子什么的，但一个需求还没做完，另外一个需求就安排过来了 如果我是一线主管，我会把团队面临的问题分一下级 重要\u0026紧急，不能按时完成都是失败 重要不紧急，是个很好的机会 技术想法，很好撬动业务的点 简单分析只是业务需求 团队的人可能也有几种特性 能力强，在某领域是专家 能力一般，有潜力，但是非常有积极性 能力一般，主动性一般 其实不用意义说明就知道大部分主管分配任务的思路 重要\u0026紧急的事情只能交给能力强的认去做，意愿有问题也要说服去做，因人成事，能力强多重要 重要不紧急的事情就可以借事修人，如果做得好这个人以后就有信心了，团队多了一员干将，做不好也有能力强的人给保底，不会造成业务问题 技术想法也可以交给有积极性的人做．那么必然占用一些时间，那么这个人手头上无关痛痒的事情只好交给… 实际上按照向上管理的思路，需要主管去分配任务的时候，就已经输了，甚至主管来找你问进度的时候也己经输了 当然每个合格的主管都需要发现、解決团队人才培养的问题，不可能放任问题发生 ","date":"2022-11-02","objectID":"/posts/tech/al/tobeleader/:4:0","tags":["内部"],"title":"内部-如果我是一线主管","uri":"/posts/tech/al/tobeleader/"},{"categories":["内部"],"content":"什么样的人有积极性 能力强的人很好识别，那什么样的人才是有积极性的，看过一个 ^E 快速升 P8 的同学写的文章，他有个很好的习惯 无论大小难易，永远不满足于做出夹指定的事情，一定要给人惊喜 如果我是一线主管，我不会凭空把一件重要的事情就给某个人去做，我会更期望 团队同学来教育我某件事情很重要，想去尝试 在很多微不足道小事情上做出了 惊喜，有理由相信这件更大的事情也可能做出惊喜 ","date":"2022-11-02","objectID":"/posts/tech/al/tobeleader/:4:1","tags":["内部"],"title":"内部-如果我是一线主管","uri":"/posts/tech/al/tobeleader/"},{"categories":["内部"],"content":"我被分配了纯业务事情怎么办 上面也提到了简单分析只是业务需求，简单分析，简单分析，简单分析，在阿里将近五年见了太多事在人为的案例，每个人身边肯定也有不少这样的案例 我们以为自己在做业务，很多时候是因为两个误区 这不是技术项目 没有什么所谓的技木项目，所有的技术项目除非显而易见，否则肯定脱胎于业务，只有业务一线的同学才 可以抽象出来，做业务需求不是坏事情，拿着完成任务的心态做业务才是最要命的 没目标 所有做的事情都要契合自己的目标，而自己的目标大部分时候应该和团队目标 match，今天让我开发一个 前端组件，我要看到的是这个需求反应了我营销体系对某个分类能力的缺失，需求归纳到我营销可视化体 系完善的目标中，在阿里这种人才济济的环境中目标不清晰的人和咸鱼没什么区别 ","date":"2022-11-02","objectID":"/posts/tech/al/tobeleader/:4:2","tags":["内部"],"title":"内部-如果我是一线主管","uri":"/posts/tech/al/tobeleader/"},{"categories":["内部"],"content":"怎样才算业务负责人 很多小伙伴己经是实际的业务负责人，和三、四个小伙伴一块解决特定业务领域问题，但尴尬的是级别相 同，在分配任务的时候会不好意思，觉得对方也有自己的\"技术项目“要做，我得求他把这个业务需求做一下 这种其实不算真正的业务负责人，如果业务负责人仅仅是分配任务，那么任何人辛苦一些都可以做。业务 负责人的核心特质应该有一条是了解业务的发展、引1导相关人个人目标 这样可以把业务需求转换成每个人目标中的一环，和上面提到的自己做事情思路是一样的，无非写代码的 那个人不自己。其实即使主管也不可能命令团队成员去做某事，那样团队早晚散伙 如果我是一线技术主管，我希望团队的业务负责人时刻在两个方面提醒自己 可衡量：很多时候说不出怎么衡量是因为对事情仅仅是简单直觉，没有经过逻辑推导 体系化：当解决的问题足够复杂的时候，散点的创新不会有決定性的影响，层次的划分可以让方案更可 靠、全面，也能让人看到阶段性的成果，容易得到更多的资源的支持 ","date":"2022-11-02","objectID":"/posts/tech/al/tobeleader/:4:3","tags":["内部"],"title":"内部-如果我是一线主管","uri":"/posts/tech/al/tobeleader/"},{"categories":["内部"],"content":"CR 有感 前段时间参与了xx代码 Code Review，开始前大家有些不安，觉得代码水平很难评判，详细研究了各个评分纬度，但实际 Review 下来发现评判特别简单，大家给的分数高度一致，总结下自己的感受： 功夫在日常，代码质量很难刷 最基础的规范都不注意会让评委对后续的 Review 内容带有挑战心态，一屋不扫，何以扫天下 注意小细节优化的同学一般整体代码规范性会很高 相对于发起一个重构的项目，重构在日常是个非常可贵的品质，很关项目需要重构，正是因为日常没有做好 Code Review，导致代码腐化，团队效能下降 清理无用代码、主动升级依赖、使用新特性 等让人印象深刻 README 质量高的项目，代码质量通常不会差，对自己的作品在意会体现在方方面面 代码质量分布通常会团队化，不要指望个别优秀的同学带动团队的整体水平提升; 与Code Review，技术文化需要主管以身作则 自己在团队 Review 前端代码总结了几类常见的问题 ","date":"2022-11-02","objectID":"/posts/tech/tools/code/:1:0","tags":["内部"],"title":"内部-Code规范","uri":"/posts/tech/tools/code/"},{"categories":["内部"],"content":"规范类问题 无意义的commit message； 建议所有同学了解一下看看 commit message 规范。 ","date":"2022-11-02","objectID":"/posts/tech/tools/code/:1:1","tags":["内部"],"title":"内部-Code规范","uri":"/posts/tech/tools/code/"},{"categories":["内部"],"content":"无用和缺省的依赖 mvn dependency:analyze ","date":"2022-11-02","objectID":"/posts/tech/tools/code/:1:2","tags":["内部"],"title":"内部-Code规范","uri":"/posts/tech/tools/code/"},{"categories":["内部"],"content":"git commit message 格式 ‹type\u003e ( \u003c scope \u003e ) : ‹subject\u003e ","date":"2022-11-02","objectID":"/posts/tech/tools/code/:2:0","tags":["内部"],"title":"内部-Code规范","uri":"/posts/tech/tools/code/"},{"categories":["内部"],"content":"type(必须） 用于说明git commit的类别，只允许使用下面的标识 feat: 新功能 (feature) fix/to：修复bug，可以是QA发现的BUG，也可以是研发自己发现的BUG fix：产生diff并自动修复此问题。适合于一次提交直接修复问题(可以和Aone bug关联） to：只产生dif不自动修复此问题。适合于多次提交。最终修复问题提交时使用fix(可以和Aone bug关联） docs: 文档 (documentation) style：格式（不影响代码运行的变动） refactor：重构（即不是新增功能，也不是修改bug的代码变动） pert： 优化相关，比如提升性能、体验 test：增加测试 chore：构建过程或辅助工具的变动 revert：回滚到上一个版本 merge: 代码合并 sync: 同步主线或分支的Bug ","date":"2022-11-02","objectID":"/posts/tech/tools/code/:2:1","tags":["内部"],"title":"内部-Code规范","uri":"/posts/tech/tools/code/"},{"categories":["内部"],"content":"scope(可选) scope用于说明 commit 影响的范围，比如数据层、控制层、视图层等等，视项目不同而不同。 如果你的修改影响了不止一个scope，你可以使用*代替。 ","date":"2022-11-02","objectID":"/posts/tech/tools/code/:2:2","tags":["内部"],"title":"内部-Code规范","uri":"/posts/tech/tools/code/"},{"categories":["内部"],"content":"subject(必选) subject是commit目的的简短描述，不超过50个字符。 建议使用中文(中国人用中文描述问题能更清楚一些） 结尾不加句号或其他标点符号 根据以上规范git commit message 将是如下的格式： fix(DA0): 活动查询缺少子活动类型属性 feat (Controller): 活动查询接口开发 以上就是我们梳理的git commit规范，那么我们这样规范git commit到底有哪些好处呢？ 便于程序员对提交历史进行追湖，了解发生了什么情况 一旦约束了commit message，意味着我们将慎重的进行每一次提交，不能再一股脑的把各种各样的改动都放在一个git commit里面，这样一来整个代码改动的历史也将更加清晰 格式化的commit message才可用于自动化输出 change log ","date":"2022-11-02","objectID":"/posts/tech/tools/code/:2:3","tags":["内部"],"title":"内部-Code规范","uri":"/posts/tech/tools/code/"},{"categories":["内部"],"content":"Code Review的一些想法 ","date":"2022-11-02","objectID":"/posts/tech/tools/code/:3:0","tags":["内部"],"title":"内部-Code规范","uri":"/posts/tech/tools/code/"},{"categories":["内部"],"content":"1. 统一认知 Code Review 不是判定 Coding 水平高低，只要频度够任何人都不会尴尬 CR 是互相帮助的过程，但同时也是互相学习的过程，因此发起 CR 尽量抄送相关同学 CR 不只是为了发现有问题的代码，更重要的意义是集思广益写出更好的代码，对待可以 work 但有瑕疵的代 码要警惕破窗效应 通过 CR 要让所有人了解团队代码规范，学习更优秀的代码书写；同时发现团队通用问题，优化工具、流程 ","date":"2022-11-02","objectID":"/posts/tech/tools/code/:3:1","tags":["内部"],"title":"内部-Code规范","uri":"/posts/tech/tools/code/"},{"categories":["内部"],"content":"2. Code Review 作用 统一团队编码规范 提升团队代码质量 分享项目知识，了解团队技术变更、发展 统一团队技术价值观，构建更好的软件、更好的团队 ","date":"2022-11-02","objectID":"/posts/tech/tools/code/:3:2","tags":["内部"],"title":"内部-Code规范","uri":"/posts/tech/tools/code/"},{"categories":["内部"],"content":"3. Code Review 关注点 3.1 可读性 ＆ 可维护性 文件位置 \u0026命名，变量使用、空格 or tab 等是否遵从了团队的统一规范？ 宇段、变量、参数、方法、类的命名是否真实反映它们所代表的事物？ 我是否可以通过读代码理解它做了什么？ 错误信息、异常分支是否可被理解？ 不清晰的代码是否被文档、注释或容易理解的测试用例所覆盖？ 3.2 逻辑实现合理 代码是否真的达到了预期的目标？ 代码看上去是否包含不明显的 bug，比如使用错误的变量进行检查？ 是否有自动化测试来确保代码的正确性，测试的代码是否真的可以验证代码达到了协定的需求？ 3.3 是否考虑过？ 是否需要满足相关监管需求？ 是否需要创建公共文档或修改现存的帮助文档？ 是否有会在生产环境中导致应用停止运行的明显错误？ 代码是否会错误地指向测试环境？ 是否存在应在真实服务中移除的硬编码代码？ 对性能的需求是什么？ 是否考虑了安全问题？ ","date":"2022-11-02","objectID":"/posts/tech/tools/code/:3:3","tags":["内部"],"title":"内部-Code规范","uri":"/posts/tech/tools/code/"},{"categories":["内部"],"content":"4. Code Review 之后 互相学习，见贤思齐，见不贤而内自省 抽象共性问题，找出解决方案，让团队变的更好 典型实践 形成规范：阿里巴巴 Java 开发手册 自动校验工具； ","date":"2022-11-02","objectID":"/posts/tech/tools/code/:3:4","tags":["内部"],"title":"内部-Code规范","uri":"/posts/tech/tools/code/"},{"categories":["内部"],"content":"多希望入职时候就知道的 ","date":"2022-11-02","objectID":"/posts/tech/al/work-advice/:1:0","tags":["内部"],"title":"内部-Work Advice","uri":"/posts/tech/al/work-advice/"},{"categories":["内部"],"content":"成长的捷径 谦逊的态度是对的，但不要把“我是新人\"作为心理安全线 技术博客写一篇大概需要两周左右，但可能是最快的成长方式 一定要读两本书：金宇塔原理、高效能人士的七个习惯（这本书名宇像成功学，实际讲的是如何塑造性格) 多问是什么、为什么，然后解决问题，试图绕过的问题永远会在下个路口等着你 不用过于计较一时的得失，在公平的环境中，吃亏是福不是鸡汤 不要把自己定位成前端、后端、测试等角色，先把自己定位成业务域的工程师，做这个业务域的问题终结者 好奇和热爱是成长最大的捷径，长期主义者会认同自己的工作价值，甚至要高于组织当下给的认同 ","date":"2022-11-02","objectID":"/posts/tech/al/work-advice/:1:1","tags":["内部"],"title":"内部-Work Advice","uri":"/posts/tech/al/work-advice/"},{"categories":["内部"],"content":"功夫在日常 每行代码要代表自己当下的最高水平，你觉得无所谓的小细节，有可能就是在晋升场上杀死你的暗箭 双周报不是工作日志流水账，不要被时间推着走，最起码要知道下次双周报里会有什么（小目标驱动） 觉得日常都是琐碎工作、不技术、给师兄打杂等，可以尝试对手头事情做一下分类，想象成每个分类都是个小格子，这些格子连起来的终点就是自己的目标，这样每天不再是机械的做需求，而是有规划的填格子、 为目标努力，甚至会给自己加需求，因为自己看清楚了要去哪里 日常的言行举止是能力的显微镜，大部分人可能意识不到，自己的强大和虚弱是那么的明显，不存在蒙混过关 ","date":"2022-11-02","objectID":"/posts/tech/al/work-advice/:1:2","tags":["内部"],"title":"内部-Work Advice","uri":"/posts/tech/al/work-advice/"},{"categories":["内部"],"content":"学会被管理 上级、主管是泛指，开发对口的 PD主管等也在范围内 不要传播负面情绪，不要总是抱怨 对上级不卑不亢更容易获得尊重，但不要当众反驳对方观点，分歧私下沟通 好好做向上管理，尤其是对齐预期，沟通绩效出现 Surprise 双方其实都有责任，但倒霉的是自己 尽量站在主管角度想问题 这样能理解很多过去感觉匪夷所思的决策 不要在意谁执行、功劳是谁的等，主管信任的重要性远远高于这些 不要把这个原则理解为唯上，这种最让人不齿 ","date":"2022-11-02","objectID":"/posts/tech/al/work-advice/:1:3","tags":["内部"],"title":"内部-Work Advice","uri":"/posts/tech/al/work-advice/"},{"categories":["内部"],"content":"思维转换 定义问题是个高阶能力，尽早形成 发现问题 -\u003e 定义问题 -\u003e 解決问题 -\u003e 消灭问题的思维闭环 定事情价值导向，做事情结果导向，讲事情问题导向 讲不清楚，大概率不是因为自己是实干型，而是没想清楚，在晋升场更加明显 当一个人擅长解决某一场景的问题的时候，时间越久也许越离不开这个场景（被人贴上一个标签很难，撕掉一个标签更难） ","date":"2022-11-02","objectID":"/posts/tech/al/work-advice/:1:4","tags":["内部"],"title":"内部-Work Advice","uri":"/posts/tech/al/work-advice/"},{"categories":["内部"],"content":"栓住情绪 学会控制情绪，没人会认真听一个愤怒的人在说什么 再委屈、再愤怒也要保持理智，不要让自己成为需要被哄着的那种人 伤害我们最深的既不是别人的所作所为，也不是自己犯的错误，而是我们对错误的回应 ","date":"2022-11-02","objectID":"/posts/tech/al/work-advice/:1:5","tags":["内部"],"title":"内部-Work Advice","uri":"/posts/tech/al/work-advice/"},{"categories":["内部"],"content":"成为 Leader Manager 有下属，Leader 有追随者，管理者不需要很多，但人人都可以是 Leader 不要在任何场合对人做负面评价，片面认知下的评价可能不准确，不经意的传播会给对方带来极大的困扰 让你信服、愿意追随的人不是职务上的 Manager ，而是在帮助自己的那个人，自己想服众的话道理一样 困难时候不要否定自己的队友，多给及时的、正向的反馈 Leader 应该让自己遇到的每个人都感觉自己很重要、被需要 ","date":"2022-11-02","objectID":"/posts/tech/al/work-advice/:1:6","tags":["内部"],"title":"内部-Work Advice","uri":"/posts/tech/al/work-advice/"},{"categories":["生活"],"content":"沟通的技巧 沟通-换位思考 ","date":"2022-11-01","objectID":"/posts/life/interesting/:1:0","tags":["图片"],"title":"一些引人深思的图片","uri":"/posts/life/interesting/"},{"categories":["生活"],"content":"视角 视角 ","date":"2022-11-01","objectID":"/posts/life/interesting/:2:0","tags":["图片"],"title":"一些引人深思的图片","uri":"/posts/life/interesting/"},{"categories":["架构设计"],"content":"《那些年，为了进阿里背过的面试题》 ","date":"2022-10-27","objectID":"/posts/tech/al/design-os/:1:0","tags":["架构设计"],"title":"功能设计场景","uri":"/posts/tech/al/design-os/"},{"categories":["架构设计"],"content":"秒杀架构设计[大数据与高并发] ","date":"2022-10-27","objectID":"/posts/tech/al/design-os/:2:0","tags":["架构设计"],"title":"功能设计场景","uri":"/posts/tech/al/design-os/"},{"categories":["架构设计"],"content":"业务介绍 什么是秒杀？通俗一点讲就是网络商家为促销等目的组织的网上限时抢购活动 比如说京东秒杀，就是一种定时定量秒杀，在规定的时间内，无论商品是否秒杀完牛，该场次的秒杀活动 都会结束。这种秒杀，对时问不是特别严格，只要下手快点，秒中的概率还是比较大的。 淘宝以前就做过一元抢购，一般都是限量 1件商品，同时价格低到「令人发齿」，这种秒杀一般都在开始 时间 1到3 秒内就已经抢光了，参与这个秒杀一般都是看运气的，不必太强求 ","date":"2022-10-27","objectID":"/posts/tech/al/design-os/:2:1","tags":["架构设计"],"title":"功能设计场景","uri":"/posts/tech/al/design-os/"},{"categories":["架构设计"],"content":"业务特点 瞬时并发量大 秒杀时会有大量用户在同一时间进行抢购； 网站瞬时并发访问量激增； 有可能10 倍，甚至 100 倍以上都有。 库存少 访问请求数量远远大于库存数量； 只有少部分用户能够秒杀成功； 一般秒杀活动商品量很少，这就导致了只有极少量用户能成功购买到。 业务简单 业务流程比较简单； 下单减库存； 一般都是下订单、扣库存、支付订单。 ","date":"2022-10-27","objectID":"/posts/tech/al/design-os/:2:2","tags":["架构设计"],"title":"功能设计场景","uri":"/posts/tech/al/design-os/"},{"categories":["架构设计"],"content":"技术难点 对现有业务冲击 高并发应用负载高 突然增加网络与服务带宽； 直接下单； 控制商品页面购买按钮点亮； 下单前置检查； 现有业务的冲击 秒杀是营销活动中的一种，如果和其他营销活动应用部署在同一服务器上，肯定会对现有其他活动造成冲击，极端情况下可能导致整个电商系统服务宕机。 直接下订单 下单页面是一个正常的 URL 地址，需要控制在秒杀开始前，不能下订单，只能浏览对应活动商品的信息。简单来说，需要 Disable 订单按钮。 页面流量突增 秒杀活动开始前后，会有很多用户请求对应商品页面，会造成后台服务器的流量突增，同时对应的网络带宽增加，需要控制商品页面的流量不会对后台服务器、DB、Redis 等组件的造成过大的压力 ","date":"2022-10-27","objectID":"/posts/tech/al/design-os/:2:3","tags":["架构设计"],"title":"功能设计场景","uri":"/posts/tech/al/design-os/"},{"categories":["架构设计"],"content":"架构设计思想 限流 由于活动库存量一般都是很少，对应的只有少部分用户才能秒杀成功。所以我们需要限制大部分用户流量，只准少量用户流量进入后端服务器。 削峰 秒杀开始的那一瞬间，会有大量用户冲击进来，所以在开始时候会有一个瞬间流量峰值。如何把瞬问的流量峰值变得更平缓，是能否成功设计好秒杀系统的关键因素。实现流量削峰填谷,一般的采用缓存和MQ中间件来解决。 异步 秒杀其实可以当做高并发系统来处理，在这个时候，可以考虑从业务上做兼容，将同步的业务，设计成异 步处理的任务，提高网站的整体可用性。 缓存 秒杀系统的瓶颈主要体现在下订单、扣减库存流程中。在这些流程中主要用到 OLTP 的数据库，类似 MySQL、SQLServer、 Oracle。由于数据库底层采用 B+ 树的储存结构，对应我们随机写入与读取的效 率，相对较低。如果我们把部分业务逻辑迁移划内存的缓存或者 Redis 中，会极大的提高并发效率, ","date":"2022-10-27","objectID":"/posts/tech/al/design-os/:2:4","tags":["架构设计"],"title":"功能设计场景","uri":"/posts/tech/al/design-os/"},{"categories":["架构设计"],"content":"整体架构 ","date":"2022-10-27","objectID":"/posts/tech/al/design-os/:2:5","tags":["架构设计"],"title":"功能设计场景","uri":"/posts/tech/al/design-os/"},{"categories":["架构设计"],"content":"客户端优化 客户端优化主要有两个问题： 秒杀页面 秒杀活动开始前，其实就有很多用户访问该页面了。如果这个页面的一些资源，比如 CSS、JS、图片、商 品详情等，都访问后端服务器，甚至 DB 的话，服务肯定会出现不可用的情况。所以一般我们会把这个页 面整体进行静态化，并将页面静态化之后的页面分发到CDN 边缘节点上，起到压力分散的作用。 防止提前下单 防止提前下单主要是在静态化页面中加入一个JS 文件引用，该 JS 文件包含活动是否开始的标记以及开 始时的动态下单页面的 URL 参数。同时，这个 了S 文件是不会被 CDN 系统缓存的，会一直请求后端服 务的，所以这个 JS 文件一定要很小。当活动快开始的时候（比如提前），通过后台接口修改这个 JS文 件使之生效。 ","date":"2022-10-27","objectID":"/posts/tech/al/design-os/:2:6","tags":["架构设计"],"title":"功能设计场景","uri":"/posts/tech/al/design-os/"},{"categories":["架构设计"],"content":"API 接入层优化 客户端优化，对于不是搞计算机方面的用户还是可以防止住的。但是稍有一定网络基础的用户就起不到作 用了，因此服务端也需要加些对应控制，不能信任客户端的任何操作。一般控制分为 2大类： 限制用户维度访问频率 针对同一个用户（ Userid 维度），做页面级别缓存，单元时间内的请求，统一走缓存，返回同一个页 面。 限制商品维度访问频率 大量请求同时间段查询同一个商品时，可以做页面级别缓存，不管下回是谁来访问，只要是这个页面就直 接返回。 ","date":"2022-10-27","objectID":"/posts/tech/al/design-os/:2:7","tags":["架构设计"],"title":"功能设计场景","uri":"/posts/tech/al/design-os/"},{"categories":["架构设计"],"content":"SOA 服务层优化 上面两层只能限制异常用户访问，如果秒杀活动运营的比较好，很多用户都参加了，就会造成系统压力过 大甚至宕机，因此需要后端流量控制。 对于后端系统的控制可以通过消息队列、异步处理、提高并发等方式解决。对于超过系统水位线的请求， 直接采取 「Fail-Fast」原则，拒绝掉。 ","date":"2022-10-27","objectID":"/posts/tech/al/design-os/:2:8","tags":["架构设计"],"title":"功能设计场景","uri":"/posts/tech/al/design-os/"},{"categories":["架构设计"],"content":"秒杀整体流程图 秒杀系统核心在于层层过滤，逐渐递减瞬时访问压力，減少最终对数据库的冲击。通过上面流程图就会发 现压力最大的地方在哪里？ MQ 排队服务，只要 MQ 排人服务顶佳，后面下订单与扣减库存的压力都是自己能控制的，根据数据库的 压力，可以定制化创建订单消费者的数量，避免出现消费者数据量过多，导致数据库压力过大或者直接宕机。 库存服务专门为秒杀的商品提供库存管理，实现提前锁定库存，避免超卖的现象。同时，通过超时处理任 务发现已抢到商品，但末付款的订单，并在规定付款时间后，处理这些订单，将恢复订单商品对应的库存 量。 ","date":"2022-10-27","objectID":"/posts/tech/al/design-os/:2:9","tags":["架构设计"],"title":"功能设计场景","uri":"/posts/tech/al/design-os/"},{"categories":["架构设计"],"content":"总结 核心思想：层层过滤 尽量将请求拦截在上游，降低下游的压力 充分利用缓存与消息队列，提高请求处理速度以及削峰填谷的作用 ","date":"2022-10-27","objectID":"/posts/tech/al/design-os/:2:10","tags":["架构设计"],"title":"功能设计场景","uri":"/posts/tech/al/design-os/"},{"categories":["内部"],"content":"架构学习整理 ","date":"2022-10-25","objectID":"/posts/tech/al/learning2/:0:0","tags":["内部"],"title":"内部-架构学习整理","uri":"/posts/tech/al/learning2/"},{"categories":["内部"],"content":"1.当我们在谈架构时，我们谈的是什么？ 首先，架构是一个抽象词语，100 个人谈架构可能会有 101种答案 个人看到最简洁的说法就是：架构=构件＋交互。其实它没有一个标准，这里我们不纠结名词概念， 在现代企业里，可根据从业务需求到系统实现的不同需要分为：业务架构、应用架构。数据架构、技术架构。也被称为 TOGAF4A架构 被普遍定义的四大架构领域 图 业务架构：比如前台、中台、后台、基础支撑 应用架构：比如商品、 交易、合同、优惠、资金等各个域的应用 技术架构：比如高可用、高性能、安全生产B/S、C/S 微服务．分布式 数据架构：比如数据存储方式（读写分离、分布式存储、数据的生产与消费方式) 今天，我们要谈的是「技术架构」，而且是偏后端的技木架构，前端会稍微带一下 注：笔者在后端架构上的经验不算多（来阿里之前做过三年的 NET 开发，但仪限开 wincovs 应用开数据分离架构的设 计和部署，以及稍微尝试过 memCached lucence 等美机架构的中间件）对二分布式架构的经验是比较少的。此文 笔者最近在学习架构过程中的一些笔记，并非实战分享，如以下技大论点有错误欢迎红正 ","date":"2022-10-25","objectID":"/posts/tech/al/learning2/:1:0","tags":["内部"],"title":"内部-架构学习整理","uri":"/posts/tech/al/learning2/"},{"categories":["内部"],"content":"1.1架构与框架的区别？ 框架的英文是 Framework. 架构的英文是 Architecture 框架关注的是\"规范”，架构关注的是\"结构” 软件框架 (Software framework）通常指的是为了实现某个业界标准或完成特定基本任务的软件组件规范，也指为了实现某个软件组件规范时，提供规范所要求之基础功能的软件产品。 问：MVC是架构还是框架？ ","date":"2022-10-25","objectID":"/posts/tech/al/learning2/:1:1","tags":["内部"],"title":"内部-架构学习整理","uri":"/posts/tech/al/learning2/"},{"categories":["内部"],"content":"2.架构设计的核心目的 几个架构设计的误区 “因为架构很重要，所以要做架构设计\" “每个系统都萝做架构设计” 公司流程要求系统开发过程中必须有架构设计” “为了高性能、高可用、可扩展，所以要做架构设计” “淘宝的架构是这么做的，我们也要这么做” “微服务现在很流行，我们的架构应该使用微服务架构” “架构是需要专门的架构师来做的” 架构设计的主要目的是为了解決软件复杂度带来的问题 ","date":"2022-10-25","objectID":"/posts/tech/al/learning2/:2:0","tags":["内部"],"title":"内部-架构学习整理","uri":"/posts/tech/al/learning2/"},{"categories":["内部"],"content":"2.1 复杂度来源：高性能 硬件性能：单机性能、集群性能、终端性能 网络性能：带宽、地域、稳定 算法性能：任务分配、轮训、渲染 性能衡量术语：吞吐量 (TPS)、 QPS、并发数、响应时间 (RT)、秒开率等 ","date":"2022-10-25","objectID":"/posts/tech/al/learning2/:2:1","tags":["内部"],"title":"内部-架构学习整理","uri":"/posts/tech/al/learning2/"},{"categories":["内部"],"content":"2.2复杂度来源：高可用 高可用本质上都是通过“元余\"来实现高可用，说白了就是『加机器』 计算高可用：难点在\"无中断”的计算服务 存储高可用：难点在：如何规避数据不一致 高可用衡量术语：N个9（可用性 99.9999%）.1-5-10等 思考一不，高可用看起都是后端的东西，这个概念放在前端，我们有哪些需要注意的地方？ ","date":"2022-10-25","objectID":"/posts/tech/al/learning2/:2:2","tags":["内部"],"title":"内部-架构学习整理","uri":"/posts/tech/al/learning2/"},{"categories":["内部"],"content":"2.3 复杂度来源：可扩展 预测变化 既然是预测，都存在出错的可能性 依赖经验 深入组织、业务 应对变化 使用成熟技术 经验依赖 面向对象（6 大设计原则） 设计模式 （GoF 23 设计模式） ","date":"2022-10-25","objectID":"/posts/tech/al/learning2/:2:3","tags":["内部"],"title":"内部-架构学习整理","uri":"/posts/tech/al/learning2/"},{"categories":["内部"],"content":"2.4 复杂度来源：低成本 规模扩大-＞需要创新、自研 -＞开源 小优化带来大提升 ","date":"2022-10-25","objectID":"/posts/tech/al/learning2/:2:4","tags":["内部"],"title":"内部-架构学习整理","uri":"/posts/tech/al/learning2/"},{"categories":["内部"],"content":"2.5 复杂度来源：安全 功能安全（防小偷) 比如我们常见的 xSS、 XSRF 攻击 架构安全（防强盗） 比如我们常见的 DDoS 攻击 ","date":"2022-10-25","objectID":"/posts/tech/al/learning2/:2:5","tags":["内部"],"title":"内部-架构学习整理","uri":"/posts/tech/al/learning2/"},{"categories":["内部"],"content":"2.6 复杂度来源：规模 系统规模 系统模块越来越多，导致复杂度提升 人员规模 人员规模的变化，需要协同的分支越来越多 这两个因素导致看不懂、改不动、不敢改、 修不了的困境 ","date":"2022-10-25","objectID":"/posts/tech/al/learning2/:2:6","tags":["内部"],"title":"内部-架构学习整理","uri":"/posts/tech/al/learning2/"},{"categories":["内部"],"content":"3. 架构原则 ","date":"2022-10-25","objectID":"/posts/tech/al/learning2/:3:0","tags":["内部"],"title":"内部-架构学习整理","uri":"/posts/tech/al/learning2/"},{"categories":["内部"],"content":"3.1 合适原则 业界领先的方案其实都是\"逼\"出来的！不要一开始就要造一座罗马帝国。军记一个原则：「合适优于领先」 合适当下和可预测的业务情况 合适当下团队规模 合适当下技术成熱情况 ","date":"2022-10-25","objectID":"/posts/tech/al/learning2/:3:1","tags":["内部"],"title":"内部-架构学习整理","uri":"/posts/tech/al/learning2/"},{"categories":["内部"],"content":"3.2简单原则 组件越多，就越有可能其中某个组件出现故障，从而导致系统故障 “复杂”在制造领域代 表先进，在建筑领域代表领先，但在软件领域，却恰恰相反，代表的是“问题”。 ","date":"2022-10-25","objectID":"/posts/tech/al/learning2/:3:2","tags":["内部"],"title":"内部-架构学习整理","uri":"/posts/tech/al/learning2/"},{"categories":["内部"],"content":"3.3 可演进原则 演进是指架构上的一些变化，比如当业务发生变化时，架构要扩展、重构，甚至重写； 代码也许会重写，但有价值的经验、教训、逻辑、设计等（类似生物体内的基因）却可以在新架构中延续。 ","date":"2022-10-25","objectID":"/posts/tech/al/learning2/:3:3","tags":["内部"],"title":"内部-架构学习整理","uri":"/posts/tech/al/learning2/"},{"categories":["内部"],"content":"3.4 可持续原则 演进是指架构上的一些变化，而持续性针对的是开发人员的变化 敢于修正架构中的错误部分 技能水平的持续改进 应用的持续改进 设计能力的持续提升 人员变化带来的持续投入风险控制等 ","date":"2022-10-25","objectID":"/posts/tech/al/learning2/:3:4","tags":["内部"],"title":"内部-架构学习整理","uri":"/posts/tech/al/learning2/"},{"categories":["内部"],"content":"4.识别复杂度和优先级 构建复杂度的来源清单 一高性能、可用性、扩展性、安全、低成本、规模等。 结合需求、技术、团队、资源等对上述复杂度逐一分析是否需要？是否关键？ 从功能需求的未来变更幅度等方面去考虑架构的扩展性，延续性。 按照上述的分析结论，得到复杂度按照优先级的排序清单，越是排在前面的复杂度，就越关键，就越优先解决。 ","date":"2022-10-25","objectID":"/posts/tech/al/learning2/:4:0","tags":["内部"],"title":"内部-架构学习整理","uri":"/posts/tech/al/learning2/"},{"categories":["内部"],"content":"5. 评估和设计备选方案 业务变化：如一旦业务发生不可预知的变化，比如架构调整，方向调整，需求调整，如何应对？ 人员变化：如一旦人员发声变动、裁员、架构如何正常演化？ 三方因素：如开源框架不可用之后，用什么方案替代？ ","date":"2022-10-25","objectID":"/posts/tech/al/learning2/:5:0","tags":["内部"],"title":"内部-架构学习整理","uri":"/posts/tech/al/learning2/"},{"categories":["内部"],"content":"6. 解决业务复杂度的三种架构模式 高性能、高可用、可扩展 ","date":"2022-10-25","objectID":"/posts/tech/al/learning2/:6:0","tags":["内部"],"title":"内部-架构学习整理","uri":"/posts/tech/al/learning2/"},{"categories":["内部"],"content":"6.1 高性能架构模式 6.1.1高性能之读写分离 考虑复制延迟 考虑分配机制 6.1.2 高性能之负载均衡 DNS 负载均衡 F5 硬件负载均衡 Nginx 反向代理 6.1.3高性能之分库分表 业务分库 分表 水平/垂直拆分 6.1.4 高性能之缓存 将可能重复使用的数据放到内存中， 一次生成、多次使用，避免每次使用都去访问存储系统，技术典型代表：Memcache、Redis 和Tair。要考虑以下几点： 失效：应用程序先从cache取数据，没有得到，则从数据 库中取数据，成功店，放到缀存中 命中：应用程序从cache中取数据．取到后返回 更新：先把数据存到数据库中，成功后．再让缓存失效 缓存穿透问题，未命中考虑采用多级缓存 分级缓存，比如粉丝100W以上的明星缓存 100份 缓存雪崩，性能急剧下降是否会有风险 6.1.5 高性能之 Nosql 是关系型数据库的一个补充 K-V存储：解决关系数据库无法存储数据结构的问题，以 Redis 为代表。 文档数据库：解决关系数据库强 schema 约束的问题，以 MongoDB 为代表。 列式数据库：解决关系数据库大数据场景下的 V0 问题，以 HBase 为代表。 全文搜索引擎：解决关系数据库的全文搜索性能问题，以 Elastiasearch 为代表。 ","date":"2022-10-25","objectID":"/posts/tech/al/learning2/:6:1","tags":["内部"],"title":"内部-架构学习整理","uri":"/posts/tech/al/learning2/"},{"categories":["内部"],"content":"6.2 高可用架构模式 CAP 原理：在一个分布式系统(指互相连接并共享数据的节点的集合）中，当涉及读写操作时，只能保证一致性 (Consistence）、可用性 (Availability)、分区容错性 (Partition Tolerance）三者中的两个，另外一个必须被牺牲。这也 是我们做架构升级为什么一定要停机的核心原因。 CAP CAP 一致性（Consistency） 对于客户端的每次读操作，要么读到的是最新的数据，要么读取失败。换句话说，一致性是站在分布式系统的角度，对访问本系统的客户端的一种承诺：要么我给您返回一个错误，要么我给你返回绝对一致的最新数据，不难看出，其强调的是数据正确。 可用性（Availability） 任何客户端的请求都能得到响应数据，不会出现响应错误。换句话说，可用性是站在分布式系统的角度，对访问本系统的客户的另一种承诺：我一定会给您返回数据，不会给你返回错误，但不保证数据最新，强调的是不出错。 分区容错性（Partition tolerance）由于分布式系统通过网络进行通信，网络是不可靠的。当任意数量的消息丢失或延迟到达时，系统仍会继续提供服务，不会挂掉。换句话说，分区容忍性是站在分布式系统的角度，对访问本系统的客户端的再一种承诺：我会一直运行，不管我的内部出现何种数据同步问题，强调的是不挂掉。 容错性：网络通信肯定有失败的可能 一致性：一旦通信失败，一致性就无法保证 。可用性：要保证一致性，就要牺牲某个区域的可用性 高可用架构的 FMEA 方法论 (Failure Mode and Effects Analysis, 故障模式与影响分析)： 给出初始的架构设计图 2．假设架构中某个部件发生故障 分析此故障对系统功能造成的影响 根据分析结果，判断架构是否需要进行优化 6.2.1高可用之计算 主备 冷备：备机不启动 温备、备机启动但不提供服务 主从 从机负责部分计算，需要任务分配器 集群 对称集群，每个集群是一个完整的计算单元 非对称集群，每个集群的角色不同，需要更复杂的任务分配机制 还记得 ACP 认证时候的频繁出现的「弹性伸缩 (Auto Scaling)』吗? 6.2.2高可用之存储 双机架构（就是两台机器） 主备复制 主从复制 主备/主从双机切换 主主 数据集群（多台机器组成的其中一个业务单元，我们也叫单元化) 多台机器组合在一起形成一个统一的系统 数据集中集群，理解为1主多备或者1主多从，需要考虑每个主机状态检测，如何分配。技术代表 ZooKeeper 数据分散集群，每台服务器都是其中一员，负责读写，需要有一个角色来负责执行数据分配算法，技术代表 Hadoop.Hbase 数据分区（我们也叫地域和可用区） 将数据按照一定的规则进行分区，不同分区分布在不同的地理位置上 集中式，找同一个备胎 互备式，相互做备胎 独立式、各找各备胎 思考一下，计算高可用与存储高可用的异同？ 6.2.3 高可用之异地多活（我们也叫单元化部署） 类似于\"不要把鸡蛋都放在同一篮子里”；多活就是指不同地理位置上的系统都能够提供业务服务，这里的\"活〞是活动、活跃 的意思。 标准 正常情况下，用户无论访问哪一个地点的业务系统，都能够得到正确的业务服务 某个地方业务异常的时候，用户访问其他地方正常的业务系统，能够得到正确的业务服务。 代价 系统复杂度会发生质的变化，需要设计复杂的异地多活架构 成本会上升，毕竟要多在一个或者多个机房搭建独立的一套业务系统。 异地多活的类型 同城异区 跨城异地 跨国异地 ","date":"2022-10-25","objectID":"/posts/tech/al/learning2/:6:2","tags":["内部"],"title":"内部-架构学习整理","uri":"/posts/tech/al/learning2/"},{"categories":["内部"],"content":"6.3 可扩展架构模式 可扩展架构基本思想：拆＋编排！ 面向流程拆分和编排：将整个业务流程拆分为几个阶段，每个阶段作为一部分。比如：分层架构．流程编排 面向服务拆分和编排：将系統提供的服务拆分，每个服务作为一部分。比如：SOA．微服务、服务编排 面向功能拆分和编排：将系统提供的功能拆分，每个功能作为一部分。比如：微内核架构、规则编排 6.3.1 (Layered Architecture) 开放接口层：可直接封装 Service 方法暴露成 RPC 接口；通过 web封装成http 接口;进行 网关安全控制、流量控制等 终端显示层：各个端的模板渲染并执行显示的层。当前主要是 Velocity 渲染，JS 渲染，JSP 渲染，移动端展示等 web层：主要是对访问控制进行转发，各类基本参数校验，或者不复用的业务简单处理等 Service 层：相对具体的业务逻辑服务层 Manager 层：通用业务处理层 1）对第三方平台封装的层，预处理返回结果及转化异常信息； 2）对Service 层通用能力的下沉，如缓存方案、中间件通用处理; 3)与DAO层交互，对多个DAO的组合复用 DAO层：数据访问层，与底层 My SQL、Oracle、Hbase 进行数据交互 外部接口或第三方平台：包括其它部门 RPC 开放接口，基础平台，其它公司的 HTTP 接口 6.3.2 微内核架构 (microkernel architecture) 内核 (core）通常只包含系统运行的最小功能。插件则是互相独立的，插件之问的通信，应该减少到最低，避免出现互相依赖的问题。 我们常见的采用微内核架构的有 Vue JQuery ernt Babel WebPack 6.3.3 SOA (microservices architecture) 把系统按照实际业务，拆分成刚刚好大小的，合适的、独立部署的模块，每个模块之间相互独立。模块之问是松轉合的。 6.3.4 微服务 SOA 思想的一种实现 更细粒度的 SOA 微服务是去掉 ESB 后的 SOA 去中心化（ESB） 的服务架构 微服务的弊端：本质上就是服务的一种分布式部署，增加了协同、联调、调用链路的成本 微服务的服务发现与注册中心与 ESB 的区别2 6.3.5 管道架构 (Pipeline Architecture) 管道就像生产流水线上的传送带，过滤器就像每一道工序上的机器。管道负 责数据的传递，原始数据通过管道传送给第一个 过滤器，第一个过滤器处理完成之后，再通过管道把处理结果传送给下一个过滤器，重复这个过程直到处理结束，最终得到 需要的结果数据 我们常见的来用管道架构的有： KOA Dawn Gulp ","date":"2022-10-25","objectID":"/posts/tech/al/learning2/:6:3","tags":["内部"],"title":"内部-架构学习整理","uri":"/posts/tech/al/learning2/"},{"categories":["内部"],"content":"7.架构产出物有哪些？ 架构图（必须） 迭代计划（必须） 技术栈\u0026选型（必须） 示例代码 部署策略 测试策路 分工人员（必须） 附架构评审模板 ","date":"2022-10-25","objectID":"/posts/tech/al/learning2/:7:0","tags":["内部"],"title":"内部-架构学习整理","uri":"/posts/tech/al/learning2/"},{"categories":["内部"],"content":"8.淘宝架构演化案例 部分摘自《淘宝技术这十年》 03年．买来的电商网站（美国的个人网站 LAMP PHPAuction),一个月上线，简单原则 03年底，Mysal 撑不住，买 Oracle 合适原则 04年开始，PHP 热切换到 Java，开启一系列架构升级演化原则、高性能合适原则 member1.taobao.com的故事 MVC框架 struts1.x 多人协作很弱，自研webx（—指） 系统划分越来越多，自研分布式 RPC 服务框架，自研 HSF（小邪） 分库分表查询的麻烦，自研DBRoute（行癫）到现在的TDDL Apache 性能扛不住，发起 Tengine（叔度) 商品图片越来越多，自研TFS (Taobao File System) 商品信息和用户信息的膨胜，自创的Key-Value缓存系统一Tair（合井自多隆的TDBM、TBStore ) 搭建 CDN（正明） 淘宝旺旺 （直接采用 B2B 贸易通) 07年开始，国内第一个前端团队 高性能 前后端分离 YUI 自研前段框架(TBra, Kissy) TMS、斑马 -all in (H5€, Weex, Rax. Kraken) 08-09年五彩石项目将一个单一的电商系统拆分成商品、交易、会员等各个中心，沉淀出共享中心 高可用高性能 09年开始，去 IOE (IBM、Oracel、 EMC) 演化原则降成本、创新 15 年中台架构提出，18 年星环发布（业务架构） 规模化成本 18年 一路向北 演化原则、规模化成本 19 年，核心系统上云，和客户在同一架飞机上 ","date":"2022-10-25","objectID":"/posts/tech/al/learning2/:8:0","tags":["内部"],"title":"内部-架构学习整理","uri":"/posts/tech/al/learning2/"},{"categories":["内部"],"content":"9. 来看看我们接触过的前端一些架构 组件化架构 多页应用架构 单页应用架构 前后端分离架构 微前端架构（南天门、费用中心) 微内核 (BuvCore) 4RR% (CommonBuy. CPQ) Hybrid App 架构（阿里云 App、淘宝、支付宝、钉钉) PWA Web 应用架构 跨端渲染架构(Weex、小程序) 回顾我们的两个架构改造 一路向北 高可用高性能 单元化部署 高可用 思考：为什么要一路向北，以及一路向北的挑战有哪业？ ","date":"2022-10-25","objectID":"/posts/tech/al/learning2/:9:0","tags":["内部"],"title":"内部-架构学习整理","uri":"/posts/tech/al/learning2/"},{"categories":["内部"],"content":"10. 技术架构的下一站一 云原生 学习中，下回分解！ ","date":"2022-10-25","objectID":"/posts/tech/al/learning2/:10:0","tags":["内部"],"title":"内部-架构学习整理","uri":"/posts/tech/al/learning2/"},{"categories":["内部"],"content":"新人出师标准 熟悉团队对应的业务，以及业务相关的人和项目 熟悉团队，理解其文化和规则，并在熟悉过程中对其遇到的问题进行完善、改进和沉淀。 主动参加一个团队活动、公共基础建设 遇到问题主动沟通、积极、正能量 完成师兄分配的学习任务 技能上达到与对应层级要求的最低标准 P5能够指导下完成复杂任务，或独立完成任务。 P6能够协同团队完成复杂的任务。 P7能够独立带领产品或业务向前发展，独立承担架构规划，建设以及调优。 P8能够发现问题定义问题并基于问题开展工作。 ","date":"2022-10-25","objectID":"/posts/tech/al/advicetonew/:1:0","tags":["内部"],"title":"技术牛人给新人的学习建议","uri":"/posts/tech/al/advicetonew/"},{"categories":["内部"],"content":"小作业 给大家作一次自己的技术历程的分享 到ATA发一篇技术文章 重构一个小模块到\"Elegant” 的级别 降低10%-20%的维护工作/重复劳动 驳回或改进一个产品提出来的需求 给团队作一次自己的对于淘宝中间件的学习技术的分享 到ATA发一篇技术文章在工作中把设计模式灵活应用 每个月读一本技术相关的书 争取给自己实现的每个服务提供单元测试用例 考虑一下自己设计实现12306的车票购买库存管理方式 确定自己技术发展方向 ","date":"2022-10-25","objectID":"/posts/tech/al/advicetonew/:2:0","tags":["内部"],"title":"技术牛人给新人的学习建议","uri":"/posts/tech/al/advicetonew/"},{"categories":["内部"],"content":"尝试在一年内做以下事情 学会翻墙井搭建自己的网站： 去stackoverflow.com上回答10个问题； 在ATA上发一篇技术文章 了解淘宝网站是如何支撑秒杀的： 了解支撑双11这样的大促都做了什么； 尝试做一件非工作职责范围，对团队或公司业务有帮助的事； 尝试给涉及的或感兴趣的开源软件提交1个patch 初步判断自己希望发展的方向。 ","date":"2022-10-25","objectID":"/posts/tech/al/advicetonew/:3:0","tags":["内部"],"title":"技术牛人给新人的学习建议","uri":"/posts/tech/al/advicetonew/"},{"categories":["内部"],"content":"技术留题 了解一下开放平台，尝试写个淘宝开放平台的小应用（ 无线端更好） 每个Q团队内部可以做一次技术分享（工作沉淀） a.整个大团队的技术框架的了解和分享 b. 所负责模块的技术分享， C.深入了解一个自己日常工作使用的淘宝内部中间件，做一次分享（可以是框架结构，也可以是一个模块的代码实现） 专注一门语言，把今年的语言学习能力提升设定可量化的目标并付诸实施 ","date":"2022-10-25","objectID":"/posts/tech/al/advicetonew/:4:0","tags":["内部"],"title":"技术牛人给新人的学习建议","uri":"/posts/tech/al/advicetonew/"},{"categories":["内部"],"content":"小挑战 在项目中对一段核心代码进行优化，分析优化后的效率 了解项目的部署方式，网络拓扑结构 阅读nginx的源码 尝试用erlang，或者g0写一个基于coroutine的服务器 ","date":"2022-10-25","objectID":"/posts/tech/al/advicetonew/:5:0","tags":["内部"],"title":"技术牛人给新人的学习建议","uri":"/posts/tech/al/advicetonew/"},{"categories":["内部"],"content":"在1~2年内完成 至少深度阅读公司一个框架源码 至少写一篇技术文章发表到ata或者外部杂志向团队内 至少分享一个技术话题 至少精通-个工貝/框架/某一技术 要形成一个技术爱好 前两年工作最好996（可选） ","date":"2022-10-25","objectID":"/posts/tech/al/advicetonew/:6:0","tags":["内部"],"title":"技术牛人给新人的学习建议","uri":"/posts/tech/al/advicetonew/"},{"categories":["内部"],"content":"这两年的学习建议 写20篇技术博客 玩透一个开源软件井加入自己的想法 做一件你认为极客的事情 在团队做一次技术分享 想清楚并计划好在5年内自己要变成什么样子 ","date":"2022-10-25","objectID":"/posts/tech/al/advicetonew/:7:0","tags":["内部"],"title":"技术牛人给新人的学习建议","uri":"/posts/tech/al/advicetonew/"},{"categories":["内部"],"content":"几个建议 一星期内 记住团队每个成员的花名； 完成第一个Bug修复： 半年内 了解清楚所在团队负责的业务系统： 完成第一次新功能上线； 发一篇技术文章在ATA; 一年內 成为团队主力开发 ","date":"2022-10-25","objectID":"/posts/tech/al/advicetonew/:7:1","tags":["内部"],"title":"技术牛人给新人的学习建议","uri":"/posts/tech/al/advicetonew/"},{"categories":["内部"],"content":"代码阅读 框架: Spring, Webx 中间件 开源项目：Lva, Musal, Nginx 对一天中做的每件事问个为什么。 深思身边至少了个人的思维策略的不同。 写篇有自己想法的博客。 读一个优秀开源库的源代码 写一个小工具代码，把它优化到极致。 写个main测下你正在用的某个库的性能。 ","date":"2022-10-25","objectID":"/posts/tech/al/advicetonew/:8:0","tags":["内部"],"title":"技术牛人给新人的学习建议","uri":"/posts/tech/al/advicetonew/"},{"categories":["内部"],"content":"Homework 做一件帮团队提升研发效率的事 做一次跨因队的技术分享 做一个脱离阿里技术体系的项目 ","date":"2022-10-25","objectID":"/posts/tech/al/advicetonew/:9:0","tags":["内部"],"title":"技术牛人给新人的学习建议","uri":"/posts/tech/al/advicetonew/"},{"categories":["内部"],"content":"程序员最重要的八种软技能 ","date":"2022-10-25","objectID":"/posts/tech/al/softskill/:0:0","tags":["内部"],"title":"内部-程序员最重要的八种软技能","uri":"/posts/tech/al/softskill/"},{"categories":["内部"],"content":"前言 笔者带团队的六年中，发现程序员们在职场都有一个共同的困扰，好像写代码都没什么问题了，日常工作基本上都是应付业务需求的开发，好像找不到其他的更大的附加价值了。我应该找一些什么样的发力点才能让我的价值更突出呢？ 笔者以为这就是典型的硬技能，当下看似没有什么问题了，紧紧卡在了暖气能上。所以，做个小分享，聊聊程序员的软技能。 注意，今天讲的软技能(不等于)心灵鸡汤，都是实实在在要学的技能。也不代表笔者精通了这些软技能，也是自己的个人心得与学习梳理，与大家做个分享，一起学习。 ","date":"2022-10-25","objectID":"/posts/tech/al/softskill/:1:0","tags":["内部"],"title":"内部-程序员最重要的八种软技能","uri":"/posts/tech/al/softskill/"},{"categories":["内部"],"content":"什么是软技能？ 所谓软技能，就是相对于硬技能而言的技能。对于程序员来说，硬技能就是计算机专业技术能力，软技能则是专业之外的所有技能，包括职业规划能力、处理人际关系能力、专业态度、做事的方式和方法等。 ","date":"2022-10-25","objectID":"/posts/tech/al/softskill/:2:0","tags":["内部"],"title":"内部-程序员最重要的八种软技能","uri":"/posts/tech/al/softskill/"},{"categories":["内部"],"content":"软技能的重要性。 《哈佛商业评论》的一项研究指出，对2000家公司调查后发现，比起硬技能，公司更看重员工的通用能力，这里的通用能力等于硬技能加软技能。所以说，软技能的重要性一点也不必用技能的。笔者认为，很多初入职场的同学有一个非常错误的观点，就是软技能好像也没那么重要，貌似是可有可无的。程序员就应该更注重硬实力，硬实力才是我们吃饭的手艺。很多时候，我们的硬实力、技术水平已经完全能够胜任每一个编码需求，我们向上发展的瓶颈可能恰好就是那一些看起来虚无缥缈却无比重要的软技能。 硬技能通常比软技能更容易定义和评估，但软技能更多涉及行为或思想，也就是个性特征和认知能力更难评估。但是他们不管在任何行业、工种都适用，不管什么行业什么工种都能随身携带，学好可以受益终身。 ","date":"2022-10-25","objectID":"/posts/tech/al/softskill/:3:0","tags":["内部"],"title":"内部-程序员最重要的八种软技能","uri":"/posts/tech/al/softskill/"},{"categories":["内部"],"content":"工作中需要哪些软件能？ 比如时间管理、沟通、学习方法、工作方法、价值观、价值观、人际交往、逻辑思考、领导力等等，这些加起来可能几天都说不完。这里面很多软技能是因人而异的，比如学习方法、领导力等，所以今天的分享主要比例一些，笔者认为非常重要，每一个人都要知道且运用到工作中的八种软技能。 ","date":"2022-10-25","objectID":"/posts/tech/al/softskill/:4:0","tags":["内部"],"title":"内部-程序员最重要的八种软技能","uri":"/posts/tech/al/softskill/"},{"categories":["内部"],"content":"程序员最重要的八种软技能 ","date":"2022-10-25","objectID":"/posts/tech/al/softskill/:5:0","tags":["内部"],"title":"内部-程序员最重要的八种软技能","uri":"/posts/tech/al/softskill/"},{"categories":["内部"],"content":"1 人际交往能力 有一本书叫做《软技能-代码之外的生存指南》，不知道大家都看过没？这本书最先提到的软技能就是人际交往，笔者也认为这是程序员的软技能上最缺失的。 ","date":"2022-10-25","objectID":"/posts/tech/al/softskill/:6:0","tags":["内部"],"title":"内部-程序员最重要的八种软技能","uri":"/posts/tech/al/softskill/"},{"categories":["内部"],"content":"1.1 不要只是埋头写代码。 程序员遇到的所有的需求都来自于人，使用软件的是人，上下游沟通的是人，而埋头写下能够让计算机执行的代码，只是我们工作目的中的一个环节而已。写一手好的代码是我们的基本技能，但是过于埋头写好代码，却忽略了人与人之间的连接，这往往会带来更大的问题，比如信任感、亲切感的丢失对工作协同的影响。与人打交道是我们的基本职场技能，这跟我们上学时的语数外是一样的，一旦偏科严重，想考一个好成绩就很难了。当然了，除非你是北大韦神这种神级人物自带光芒。 ","date":"2022-10-25","objectID":"/posts/tech/al/softskill/:6:1","tags":["内部"],"title":"内部-程序员最重要的八种软技能","uri":"/posts/tech/al/softskill/"},{"categories":["内部"],"content":"1.2 主动与人打交道 《能力陷阱》一书中有一段话记忆深刻，许多人认为人际网络本质是虚伪的，认为是在利用别人认为带有目的性的人际交往让自己变得虚伪、不干净，像舔狗，从而拒绝在舒适区域以外建立人际关系。大家觉得这段话对吗？其实是不对的，当你抱折双赢的思维去沟通，就不会有这种负担了。 能力陷阱中还有一个非常核心的观点，大意就是当一个人擅长解决某一场景的问题的时候，时间越久，也许越离不开这个场景，也许这一生就定格在这个场景里面出不来了，可能一辈子都是个程序员。特别是对于管理者来说，管理者要做一个连接器，自己部门跟外部部门之间的连接起。走出去是走出能力陷阱的第一步。 LinkedIn的创始人德霍夫曼发现，当你在职业上要寻求帮助时，最远不会超过三度，即我们通常只需要通过两个人就能与其他人取得联系。但是，我们并未能统考地利用这些关系，因为我们大多数人都没有意识到我们的人际关系网络力量到底有多强大。 管理者培训里有一句很经典的话“脸皮薄，容易耽误事”。 ","date":"2022-10-25","objectID":"/posts/tech/al/softskill/:6:2","tags":["内部"],"title":"内部-程序员最重要的八种软技能","uri":"/posts/tech/al/softskill/"},{"categories":["内部"],"content":"1.3 别独自用餐 有一本非常畅销的书叫做《别独自用餐》，核心观点也是论证社交的重要性，如何建立自己的人脉圈子。如果你不知道如何建立自己的人脉圈子，不妨从工作日的午餐开始，试着主动约人吃饭。一段时间以后，你会发现自己的圈子以及获取的信息跟以往有很大的不同。记得之前听到过一个公司的段子，公司及九级以上的大佬，如果人不在工位或会议中，那一定在园区的咖啡厅。层级越高，资源信息的梦想就变得尤其重要。把用餐时间利用起来是一个很好的点子。 ","date":"2022-10-25","objectID":"/posts/tech/al/softskill/:6:3","tags":["内部"],"title":"内部-程序员最重要的八种软技能","uri":"/posts/tech/al/softskill/"},{"categories":["内部"],"content":"1.4 换位思考 学会倾听，关注他人感受，具备同理心。 在跟人打交道或沟通之前，换位思考一下，如果你是对方想听到什么或看到什么，时常锻炼换位思考的思维，时间长了会发现非常有用。如果不知道对方是如何思考的，那就不要说话，倾听即可。 举个例子，我们常常会为了视觉还原问题而烦恼，设计同学找到我们解决像素级别问题的时候，我们往往是不是会烦躁？功能中开发不完，哪有精力去还原视觉，常常就会不耐烦的沟通。这个时候换位思考一下，他的设计作品最后做出来不是他想要的，他自己会不会有落差？这是他的工作职责，我们只需要站在他的角度思考，给他一个合适的解决时间即可。 在我们工作中，我认为换位思考就是要有服务思维，处处设身处地为别人着想。 ","date":"2022-10-25","objectID":"/posts/tech/al/softskill/:6:4","tags":["内部"],"title":"内部-程序员最重要的八种软技能","uri":"/posts/tech/al/softskill/"},{"categories":["内部"],"content":"2. 结构化思维能力 结构化思维是一种从无序到有序，从混乱到清晰的思维能力，可以帮助我们快速加工处理繁杂的信息，提炼要点，从而更加清晰的表达。这个话题很大，我们只说关键的两个点 ","date":"2022-10-25","objectID":"/posts/tech/al/softskill/:7:0","tags":["内部"],"title":"内部-程序员最重要的八种软技能","uri":"/posts/tech/al/softskill/"},{"categories":["内部"],"content":"2.1 概念不能多 有研究证明，人类短期记忆的容量大概在七个左右，范围是五到九个，所以尽量不要超过七个概念或项目。这在演讲过沟通中也非常重要 ","date":"2022-10-25","objectID":"/posts/tech/al/softskill/:7:1","tags":["内部"],"title":"内部-程序员最重要的八种软技能","uri":"/posts/tech/al/softskill/"},{"categories":["内部"],"content":"2.2 有逻辑关系 大脑容易记住有逻辑关系的事物。逻辑关系分为纵向逻辑关系和纵向逻辑关系。 纵向逻辑关系。演绎逻辑、归纳逻辑 横向逻辑关系，时间顺序、空间顺序、程度顺序。 金字塔原理，麦肯锡40年经典培训教材《金字塔原理》每个职场人都必须看，就不多介绍了。 ","date":"2022-10-25","objectID":"/posts/tech/al/softskill/:7:2","tags":["内部"],"title":"内部-程序员最重要的八种软技能","uri":"/posts/tech/al/softskill/"},{"categories":["内部"],"content":"2.3 黄金圈法则（What、How、Why） 很多时候我们都知道What和How，但是不知道Why（或者说没有仔细思考Why），就容易陷入到成长瓶颈。黄金圈法则也是一个经典的学习的三部曲， 第一what，是什么， 第二how，如何实现 第三Why？为什么是这样（而不是另外的样子？） 举个例子 我们接到一个功能需求，先思考可能的本质，（为什么有这个需求），再去思考怎么做，别停留在what（一个产品需求）how（怎么做），而没有why。 我们知道一个技术框架怎么用，做什么用呢？但是知道他底层原理和为什么这么设计的人并不多。 我们要做架构迁移，比如一路向北，有没有去理解的why，为什么要去做这件事情？ ","date":"2022-10-25","objectID":"/posts/tech/al/softskill/:7:3","tags":["内部"],"title":"内部-程序员最重要的八种软技能","uri":"/posts/tech/al/softskill/"},{"categories":["内部"],"content":"3. 沟通能力 ","date":"2022-10-25","objectID":"/posts/tech/al/softskill/:8:0","tags":["内部"],"title":"内部-程序员最重要的八种软技能","uri":"/posts/tech/al/softskill/"},{"categories":["内部"],"content":"3.1、上下斜杠平级之间的沟通 记得刚带团队上侠客行课程的时候，老师说过一句话，至今记忆犹新，向上沟通要有胆量，平行沟通要有肺骨，向下沟通要有心干。这句话背后的思考我已经记不得太多，只能重新理解一下， 向上沟通要有胆量。 通常我们对上级沟通方面有几个常见的误区，比如 和上级能不聊就不聊， 他太忙了，我可能会打扰他， 我只要做好上级交代给我的事情就好了， 有事她会来找我的， 拿捏不好，该不该和上级苗的分寸和尺度， 我很难领会到上级的意图。 平行沟通要有肺腑 双赢思维:沟通的目的能够对对方是有意义的，而不是站在主观的利益上去沟通 放下面子:你不服我，我不服你，相互避让，多一事不如少一事的态度是横向沟通最大的障碍。 向下沟通要有心干 要有事人为人的态度。员工不是机器，是需要情感输入的. 不能对人不对事，不能围绕人的某个标签来做事的。 评判批评员工要有讲究，批评是不要打击人。之前看到过一个如何批评员工的a批评三部法，也称为发展性反馈。 ","date":"2022-10-25","objectID":"/posts/tech/al/softskill/:8:1","tags":["内部"],"title":"内部-程序员最重要的八种软技能","uri":"/posts/tech/al/softskill/"},{"categories":["内部"],"content":"3.2 沟通中的非暴力 在日常沟通中，暴力沟通其实无处不在，比如，你这个做的不太好，这让我很不满意，这个需求实现不了，你不爱我了吗？你懂我意思吗？等等让人很难回复的对话。思考一下这些话都有什么样的问题？ 非暴力沟通一书中提到了经典的表达框架： 观察-\u003e感受-\u003e需要-\u003e请求 对应的还有一个倾听框架。 倾听-\u003e体会-\u003e反馈 《非暴力沟通》一书，每个职场人必读，强力推荐，就不在文中多岁数了。 ","date":"2022-10-25","objectID":"/posts/tech/al/softskill/:8:2","tags":["内部"],"title":"内部-程序员最重要的八种软技能","uri":"/posts/tech/al/softskill/"},{"categories":["内部"],"content":"3.3 沟通中的结构化 重要的事情说三点，比如三个论据，三个论点，三个观点，三个好处等等。最简单的结构化表达 先说结论，再说过程和原因，然后再说结论。这也是用好三点这个好的结构化工具， 说清楚了XY黄金圈法则。笔者遇到过好多类似的对话，都是不带歪的，这让人感觉无法回答的对话，比如： 申请一个紧急发布，麻烦审批下，X业务线上有这个。（具体是什么bug？带来什么影响？） x项目比较赶，这周末可能要申请下加班，（哪个项目不赶？为什么你的这么特殊？） 有没有资源支持下X需求？（没有资源的原因是什么？） 这个问题老板说下周一定要上(老板有没有说为什么？为什么是下周？） 只讲how或what不讲why，是一个非常典型的表达问题。 理解了why，才有可能做到知行合一刘润《底层逻辑》 ","date":"2022-10-25","objectID":"/posts/tech/al/softskill/:8:3","tags":["内部"],"title":"内部-程序员最重要的八种软技能","uri":"/posts/tech/al/softskill/"},{"categories":["内部"],"content":"3.4说话的方式简单点[这里] 举一下面两段话，你看得懂吗？【无效描述案例】 对于现在这个业务，暂时还没有跑通一个模型，毕竟基础业务逻辑没有形成闭环，更别说做成生态了。我们还在夯实基础的阶段，好好打磨一下我们的产品，最终形成一套组合拳打法，才能有效赋能生态圈，最终反哺整个经济体。– 网络上被命名的阿里味语言 过去我们主要依靠推荐技术赋予的信息分发能力，挂钩联动多个产品自研，实现深度共建，形成组合拳，打造内容生态闭环，以此赋能客户用户创造价值。未来我们要增加横向不同场景价值，延长服务链路。同时动身满足用户需求，借助人类年龄的自然势能，在小中青多个年龄用户深度渗透。。 互联网黑话、空洞大词，以及各种让人听不懂的专业术语，这些在前几年已经在互联网社区备受诟病了。我们记住，说话尽量接地气就好。 ","date":"2022-10-25","objectID":"/posts/tech/al/softskill/:8:4","tags":["内部"],"title":"内部-程序员最重要的八种软技能","uri":"/posts/tech/al/softskill/"},{"categories":["内部"],"content":"3.5 改掉那些不好的口头禅 每个人都有自己的口头禅，很多时候无意识的就会说出来，如果觉得自己有口头禅，不妨思考下口头禅会不会有一些暴力因素，比如以下左边这些都可以有更好的改进 我X、TMD -\u003e null 能你懂我意思吗？-\u003e 不知道我表达清楚了没.. 我和你说实话 -\u003e 我内心真实的想法是，我的直觉是… 我之前就说过XXX-\u003e 之前我们有过一次这样的沟通，结论是 这个逻辑不对 -\u003e 我的观点跟你不一样，我认为应该是这样的… 我觉得你应该 -\u003e 我的建议是… ","date":"2022-10-25","objectID":"/posts/tech/al/softskill/:8:5","tags":["内部"],"title":"内部-程序员最重要的八种软技能","uri":"/posts/tech/al/softskill/"},{"categories":["内部"],"content":"4.写作能力 ","date":"2022-10-25","objectID":"/posts/tech/al/softskill/:9:0","tags":["内部"],"title":"内部-程序员最重要的八种软技能","uri":"/posts/tech/al/softskill/"},{"categories":["内部"],"content":"4.1 排版 良好的写作能力，这对于程序员这个高学历群体来说都不是问题，但是我发现很多同学写出来的文章，设计、文档等都没有一个良好的结构以及排版，良好的节奏和排版可以让人读起来更愉悦和理解，强烈大家按照《中文排版指北-github》来排版。 ","date":"2022-10-25","objectID":"/posts/tech/al/softskill/:9:1","tags":["内部"],"title":"内部-程序员最重要的八种软技能","uri":"/posts/tech/al/softskill/"},{"categories":["内部"],"content":"4.2 结构化的写作 写文章之前先列出大纲与却右侧的大纲或思维导图都很是很好的工具。自己先读完大纲，换位思考下，看看是否易懂。好的骨架可以牵着读者的思路走，推荐**《金字塔原理》**这本书。 ","date":"2022-10-25","objectID":"/posts/tech/al/softskill/:9:2","tags":["内部"],"title":"内部-程序员最重要的八种软技能","uri":"/posts/tech/al/softskill/"},{"categories":["内部"],"content":"4.3周到斜杠月报的表达 很多同学，写周报或月报的时候，大部分都是流水，这是最典型的应付型报告。 笔者认为，周月报有两层，以自己梳理和总结，让其他人看到自己的思考和总结，如果全部都是流水账，就失去了总结的意义了。总之就是没有思考的周报是没有灵魂的。 ","date":"2022-10-25","objectID":"/posts/tech/al/softskill/:9:3","tags":["内部"],"title":"内部-程序员最重要的八种软技能","uri":"/posts/tech/al/softskill/"},{"categories":["内部"],"content":"5.自我营销能力 ","date":"2022-10-25","objectID":"/posts/tech/al/softskill/:10:0","tags":["内部"],"title":"内部-程序员最重要的八种软技能","uri":"/posts/tech/al/softskill/"},{"categories":["内部"],"content":"5.1 为什么要自我营销 一线演员与歌手的硬实力真的比酒吧歌手和18线配角强吗？明星发微博只是想分享自己的动态吗？笔者认为核心是要提升影响力。 ","date":"2022-10-25","objectID":"/posts/tech/al/softskill/:10:1","tags":["内部"],"title":"内部-程序员最重要的八种软技能","uri":"/posts/tech/al/softskill/"},{"categories":["内部"],"content":"5.2 影响力的两种分类 之前看过两种不同的职场影响力，职权影响力与非职权影响力，分别由不同的因素组成: 职权影响力 传统因素：下级对于上级有一种天然的服从感，层级高比层级低的天然有影想力。 职位因素：从组织架构的角度，由于更高级别职位的人有一种敬畏和尊崇感。 资历因素：有资历的人在人们的眼中是更值得敬重的，比如新员工对老员工的尊敬 非职权影响力。以下几个都会影响他人的非职权因素 人品和品格 历史表现 专业能力 亲和力。 因为职权影响力需要时间的积累，所以对于大多数需要提升影响力的人来说，非职权影响力更需要关注。 ","date":"2022-10-25","objectID":"/posts/tech/al/softskill/:10:2","tags":["内部"],"title":"内部-程序员最重要的八种软技能","uri":"/posts/tech/al/softskill/"},{"categories":["内部"],"content":"5.3 提升影响力的几种方式 ATA(内部技术社区): 把思考和成果都记录和沉淀下来分享给更多的人。 分享会:多参与分享会，无论大小，都是提升影响力的机会，但切记要在不影响工作进程的条件下. 技术会议 碎片化讨论: 碎片化讨论有助于及时思考的表达，但不要为了发生而发生。 ","date":"2022-10-25","objectID":"/posts/tech/al/softskill/:10:3","tags":["内部"],"title":"内部-程序员最重要的八种软技能","uri":"/posts/tech/al/softskill/"},{"categories":["内部"],"content":"5.4 文章写完别忘记推广 群发(团队、部门..) 周报/月报中附带宣传 认识的同行/同事(大牛、翰林院推荐等) 找技术运营推广 ","date":"2022-10-25","objectID":"/posts/tech/al/softskill/:10:4","tags":["内部"],"title":"内部-程序员最重要的八种软技能","uri":"/posts/tech/al/softskill/"},{"categories":["内部"],"content":"6.演讲能力 不知道大家发现没有，等级高的同学演讲能力通常都不会差。而好的演讲水平不是天生的，需要我们不断的进行学习和训练。一场好的演讲通常由以下几部分组成： 提前了解听众的诉求：针对面向的群体类型以及听众的诉求来设计这一次的演讲 好的开场是成功的一半，开场可以来一些小互动以及调研等等，把听众的思绪带进到分享主题里来 好的内容结构：参考结构化思维的内容。 ppt只是配角，把结构内容呈现到PPT上，切忌不要把一个好的演讲全部归功到PPT上。 把控好整体节奏：思考如何让听众跟着你的思路走，一旦跟不上就算不上好的演讲 趣味性的互动：合适的情况下可以来一些互动，避免单向输入带来的乏味机。 肢体语言：好的肢体语言可以让声音控制流利的表达，抑扬顿挫的表达会让人更能接受你的信息。 收尾时强调重点：分写文章的中心思想，类似把听众的思绪拉倒中心思想上来。 有一个演讲法则，称为10-20-30法则，具体来说就是幻灯片不要超过10张，演讲时间不要超过20分钟，字体大小不要小于30号。 ","date":"2022-10-25","objectID":"/posts/tech/al/softskill/:11:0","tags":["内部"],"title":"内部-程序员最重要的八种软技能","uri":"/posts/tech/al/softskill/"},{"categories":["内部"],"content":"7.团队协同能力 在工作中，我们基本上都会遇到团队内部协同，跨团队协同以及跨部门协同的情况，特别是到了一定的层级做项目管理，团队管理之后，协同与领导能力更为重要，我们也称为借人成事的能力。这里我们要学习很多协同领导相关的能力，比如： 项目管理（预期、过程、质量、风险）：项目管理也是一个比较专业，每个程序员必学。 开好会，当需要协同的角色越多，开会的效率就变得尤其重要。在大厂有多少程序员的时间是花在了开会上半部分？建议参考集团内部的高效会议指南 复好盘：柳传志在《我的复盘方法论》中都说到，在这些年管理工作和自我成长中，复盘最令我受益了，可见富含对人成长的重要性。这里推荐一本书，叫做《复盘+把经验转化为能力》 做到事事有回应，件件有着落、凡事有交代：做一个靠谱的职场人三个最重要的要素 诚信：说到做到，提升信任感 保持正能量：多传递一些正能量，谣言与八卦在职场中常常被人津津乐道，但往往也会影响我们的职业发展 严以律己，宽以待人：领导者必备 领导力方面，重点推荐《冯唐.成事》一书 ","date":"2022-10-25","objectID":"/posts/tech/al/softskill/:12:0","tags":["内部"],"title":"内部-程序员最重要的八种软技能","uri":"/posts/tech/al/softskill/"},{"categories":["内部"],"content":"8.抗压能力 人的一生中不可能不会遇到压力和挫折，抗压能力的高低会影响我们的生活与工作，抗压能力越高，我们越容易适应当下的环境，所以说提高抗压能力是非常有必要的。这里可以给一些提升抗压能力的建议，也是我个人在工作之外会经常保持的习惯： 培养兴趣爱好：把兴趣爱好作为自己的灵魂伴侣 有三五好友可以交流与倾诉：遇到压力和挫折的时候，身边如果有人能够相互鼓励，压力会小很多。 保证充足的睡眠：很多时候我们遇到压力和挫折的时候会失眠，但我们尽量在挫折不出现的时候就保证充足的睡眠的习惯。压力来的时候不至于影响太大，压力越大越无法入睡，会进入一个恶性循环（这里没有理论做支撑，自己的感受）。 保持运动习惯：保持对自己兴趣的运动习惯，和三五好友打球，充足睡眠自然来。 ","date":"2022-10-25","objectID":"/posts/tech/al/softskill/:13:0","tags":["内部"],"title":"内部-程序员最重要的八种软技能","uri":"/posts/tech/al/softskill/"},{"categories":["内部"],"content":"最后 笔者以为这八种基础软技能在程序员的工作中相比其他软技能都更为重要，希望能够对你有一些启发。人生职业的道路上还有非常多的软技能，比如养生、理财、素质，价值观等等，下次有机会再一起探讨，谢谢。 ","date":"2022-10-25","objectID":"/posts/tech/al/softskill/:14:0","tags":["内部"],"title":"内部-程序员最重要的八种软技能","uri":"/posts/tech/al/softskill/"},{"categories":["todo"],"content":" 常用设计模式 demo； Spring DB mybatis -\u003e 的 《学徒》-纪录片- 面试 ","date":"2022-10-25","objectID":"/posts/tech/todo/:0:0","tags":["todo"],"title":"Todo","uri":"/posts/tech/todo/"},{"categories":["内部"],"content":"有感于近期来身边发生了各种变化。有老朋友的离开、团队调整、公司的变革….，在不同场合也听多过很多同学的困惑，我内心也是五味杂陈。过往的一幕幕时不时会在脑海中浮现，趁着这次余威未消，以过往16年的经验说说自己的一些感悟。希望给大家一点点的参考。 接下来我会循着工作经历。分三个关键时段、热门的关键词，讲讲不同时期遇到的困难和收获。 ","date":"2022-10-24","objectID":"/posts/tech/al/growup/:0:0","tags":["内部"],"title":"内部-成长的烦恼-个人经历","uri":"/posts/tech/al/growup/"},{"categories":["内部"],"content":"入职公司的前五年 ","date":"2022-10-24","objectID":"/posts/tech/al/growup/:1:0","tags":["内部"],"title":"内部-成长的烦恼-个人经历","uri":"/posts/tech/al/growup/"},{"categories":["内部"],"content":"拥抱变化 换过10位主管，经历过雅虎、集团、b2b、淘宝、一淘等多次组织架构，工作地点从北京切换到了杭州，工作内容也切换过很多赛道。好在大部分团队调整是部门级别，经历多了也觉得正常，哪里需要哪里搬。跟业务一起拼过累过，有成功也有失败。会因为帮助改善产品、算法、运营同学的工作而高兴，也会因为工作能力不符合预期沮丧。有在深夜想通bug时的兴奋，也彻夜通宵加班后的憔悴。是的，这家公司一直是个坑，可能只是时候未到。 ","date":"2022-10-24","objectID":"/posts/tech/al/growup/:1:1","tags":["内部"],"title":"内部-成长的烦恼-个人经历","uri":"/posts/tech/al/growup/"},{"categories":["内部"],"content":"绩效3.25 在没有经历过3.25，人生还不完整的年代。我毅然扛起来大旗。在一个重点项目中，由于代码质量的问题。项目delay了两个月。雪上加霜的是，年初制定KPI时，承诺了过多任务。由于这次意外，最终没有落地。当时遇到的困难是程序偶尔会core dump一次，要持续不断压测一周以上才有概率复现，而且每次出异常时，程序栈还不一样。代码符号又被优化的所剩无几。最终是靠写了一组测试用例，分离框架和业务代码才定位出来，原来是合作伙伴在代码中引入一个线程不安全的库。 这也是我第一次非常正式的停下来。自己对计算机知识的无知，明白了手头的工作是没办法深入理解技术的事实，于是我给自己定了一个学习计划。之后的日子中我不断的得到这个行为的滋养和正反馈。 ","date":"2022-10-24","objectID":"/posts/tech/al/growup/:1:2","tags":["内部"],"title":"内部-成长的烦恼-个人经历","uri":"/posts/tech/al/growup/"},{"categories":["内部"],"content":"晋升 从p4到p6，从这个时候是主管说了算。看起来就像熬资历。好处是少很多糟心事，坏处是说不清楚到底为啥晋升，到底是因为工作熟练了？还是对业务有贡献？亦或是技术实力变强了？对职业生涯的思考。那时是比较糊涂的，考虑的最多的是”快乐生活“，另外公司环境也比较“恶劣”，一来是没有师兄。未来是主管换的勤。成长的主要途径取决于分配到什么任务。 后来赶上了公司头一次晋升答辩机制，老板鼓励信任，让我参加。结果意外p7通过了。场面也是相当尴尬。收获超出期望！自然是喜出望外，结果带来的是长期的迷失和不知所措。 ","date":"2022-10-24","objectID":"/posts/tech/al/growup/:1:3","tags":["内部"],"title":"内部-成长的烦恼-个人经历","uri":"/posts/tech/al/growup/"},{"categories":["内部"],"content":"五年陈 除了五年陈戒指上的字母错了闹心外，印象比较深的是那句老话，大意是\"公司和我互不相欠了，要走就可以走” 当年还真没想走，不过后来马老师又号称要给社会输出十年陈的“人才”，以致于每次周年都要跟这句话较劲，到底要不要输出… ","date":"2022-10-24","objectID":"/posts/tech/al/growup/:1:4","tags":["内部"],"title":"内部-成长的烦恼-个人经历","uri":"/posts/tech/al/growup/"},{"categories":["内部"],"content":"小结 多年以后我回想，当年真的是很傻很天真，一张白纸被阿里的价值观蹂躏得体无完肤，让身边的人远远地都能嗅出那股\"臭臭\"的阿里味儿。这是怎么发生的？年少无知当然是一方面，更多的我觉得是公司的氛围：业务持续的疯涨、阿里价值观的独特性、马老师的魔力。 那时候穷得叮当响，周国的人也富得不明显，买得起房的凤毛麟角，有车的更少(10万以内的手动挡就很不错了)， 老板吃的也很普通，而且心里真心觉得做的事情是能逐步改变世界的，你不是去去众生中对人类毫无责献的，想努力工作，不幸负这个时代。反观现在已经很不一样了，小康走进了千家万户，工作作为饭碗的属性越来越弱，当公司神迹氛国退却的时候，原来习以为常的东西变得如此不合时宜、如此让人手足无措。 ","date":"2022-10-24","objectID":"/posts/tech/al/growup/:1:5","tags":["内部"],"title":"内部-成长的烦恼-个人经历","uri":"/posts/tech/al/growup/"},{"categories":["内部"],"content":"稳步夯实发展的六年 这期问干过很多鑫事，也被很多人启发，有那么一刹那感觉自己好像责任感更强了，像是“岁月这把杀猪刀\"留下的痕迹。挑几件小故事给大家分享下： ","date":"2022-10-24","objectID":"/posts/tech/al/growup/:2:0","tags":["内部"],"title":"内部-成长的烦恼-个人经历","uri":"/posts/tech/al/growup/"},{"categories":["内部"],"content":"故事- 那个时候刚晋升P7，自信心爆棚，渴望搞一些新东西，完全不清楚与一个优秀的P7差距有多大。做了一个类似全链路trace的一个项目，原理上就是基于TLS实现了一种跨语言的公共库，但真正上线的时候，落地的场景非常有限。事后想想主要有几个原因： 像这种覆盖面广的项目，开发完成跟上线完成的距离是十万八千里，如何迭代过去没有计划好 因功能有限，不是很能打动业方，不配合意，愿也不高。没法双赢的时候进退维艰. 缺少对长期发展和迭代路径的思考，对后续的技术挑战也没有准备。挥费劲时没有后手 现在看起来这些问题都是非常稚嫩，以前人的素质好差。但像这种习惯了单打独斗，搞不定跨团队协作的同学很多，归结成自己有问题却很少。程序员类似的“偏见“还有很多，比如把说话技巧理解成沟通能力、搞好关系理解成团队合作、积极跟领导交流理解成爱拍马屁、有困难咬牙顶住完全不让老板知道理解成能力强、PFT写不好/归结为软件不熟悉…当然，吃过亏以后，很多会内化成经验。 为讨论方便，简单地把这些能力归入到软技能。就我观察下来，软技能对程序员产出的影响要比技术实力本身大(很多时候)，而且软技能很方便迂移到其他场景，学起来也更容易，因为多数情况下只是个思考角度的问题。反观不重视这一块的同学，经常在各种项目中重蹈覆辙，影响自己的产出的同时还会觉得环境太糟糕. ","date":"2022-10-24","objectID":"/posts/tech/al/growup/:2:1","tags":["内部"],"title":"内部-成长的烦恼-个人经历","uri":"/posts/tech/al/growup/"},{"categories":["内部"],"content":"故事二 真正混到P8是因为后来心态平稳下来，开始千一些基础琐碎的事情，从代码质量入手，逐步把散落在各处的业务插件代码合并，重构成框架，深入理解业务、性能优化，再平台化推平，并持续重复打磨这一个过程，取得了客户和自己的双赢。那是种非常千净纯粹的体验，就是程序员操心代码本身。再后来我开始带团队，把这一风气一直延续着，从C++系列、代码重构系列等团队一齐读过很多经典书籍，聚焦在如何把代码写好。真实效果或许不好评判，但我受益很多，更加相信工作中的这种慢变量并将这种习惯一直保持到现在，特别是手机如此发达的今天， 碎片化阅读真的非常方便。 ","date":"2022-10-24","objectID":"/posts/tech/al/growup/:2:2","tags":["内部"],"title":"内部-成长的烦恼-个人经历","uri":"/posts/tech/al/growup/"},{"categories":["内部"],"content":"故事三 正当我以为一切岁月静好的时候，我带领的团队被撸了，热火朝天的项目也被叫停，去负责一个名气更大的模块 （搜索引擎HA3)。虽然一直想做这一块儿，但把称得上用心经营的园队拆得七零八落的时候，心里还是非常难受，是多年以后回首仍然会觉得不舒服的那种难受，但这次的遭遇确实让我明白了很多“道理 比起营造更好的团队氛国，营造更大的团队成长空间更重要 关心你负责的事情是必须的，但应时不时抬头看看你老板关心的事情，要主动创造趋势和变化 带团队工作在平时，多一些铺垫，少一些意外 要明白哪些是你可以带走的，哪些是你留给公司的 到新团队后，面对的是一个目标非常明确的事情，有10年历史的、数十万行代码的重构升级，与之一起的还有近3000个本身就很难成功的集成测试用例需要修复。或许是激情被点燃，居然眉头都没有级一下，团队几个人没日没夜加班了半年多，终于赶在双11前搞定了。有时候我经常感恩身边一直有贵人相助，要不是这些靠谱的小伙伴，怎么会陪我一起疯。好在成功是一剂良药，这件事给了团队无比坚定的信心，以全手在后来数次更大重构中，没有啃不下来的硬骨头，得益于团队成员们前赴后继、坚持不懈的努力，我也跟一直跟着沾光。 随着年纪越来越大，对带团队也有越多的敬畏，对借事修人、成就他人有了更多体悟，也开始学习其他人的经验， 因为你会发现身边总是不乏这样那样聪明的人，他们做更少的事情，取得更大的成绩。战木上的勤奋弥补不了战路上的懒情，不带团队也一样，每个人都应该经常跳出来，琢磨something bigger than yourself。 ","date":"2022-10-24","objectID":"/posts/tech/al/growup/:2:3","tags":["内部"],"title":"内部-成长的烦恼-个人经历","uri":"/posts/tech/al/growup/"},{"categories":["内部"],"content":"从工作中走出来的五年 感谢你坚持阅读到了现在，是不是还算正能量，后面内容会更乏味点，不过好在快结束了，加油！ 跟很多阿里人一样，在这前后的若干年里，公司发生了太多太多的事情。阿里上市了，有一批老员工一夜暴富，名义上当然也包括我这种当年的小P(是的，狗屎运)；公司强敌环伺，硝烟四起，折腾不死的敌人越来越强大，哪怕是我们海内外广纳英才，价值观升级成*非凡人干非凡事”，也只能从长计议;“国城”般的人来人往，1日伤末愈又添新愁，HR/行政使出史无前例的暖心 套餐，CEO祭出果汁会，无奈又碰上毕业潮。 这期间我也不止一次感觉要离开这家公司，像是马老师在召唤，但由于胆小没有成功，并想出很多方案挽留自己而且在号这篇文章期问就总结出了一套“精神胜利法”的组合拳，从行业趋势、工作策略扩展到人生您考，以致于它们看起来那么怪，那么不协调。如果你更好的方法破局，也欢迎批评指正. ","date":"2022-10-24","objectID":"/posts/tech/al/growup/:3:0","tags":["内部"],"title":"内部-成长的烦恼-个人经历","uri":"/posts/tech/al/growup/"},{"categories":["内部"],"content":"识时务者为俊杰 不管是从宏观的中美局势、平台经济的治理，到行业的增速放缓，高质量发展的阶段要求、互联网演变成下半场的角力，无不清晰地表明，增长下行是常态。从公司微观角度来看，抓经营责任制优化成本、提倡技术素养发展并重，也是在大势下的自然选择，精细化运作是底色。当前的格局就好比煤炭对于中国能源、淘宝对于阿里营收，份额缩小是趋势，但本身也还有很多机会。在这里大放欣词主要是用来提醒诸位看官，做选择应尽可能顺势而为， 市场供求关系不得不考虑，认识自己的需求、熟悉自己的特点，谋定而后动。有好地方，贤臣择君而伺，良禽择木而栖：没好地方，深挖洞，广积粮，厚积薄发。 ","date":"2022-10-24","objectID":"/posts/tech/al/growup/:3:1","tags":["内部"],"title":"内部-成长的烦恼-个人经历","uri":"/posts/tech/al/growup/"},{"categories":["内部"],"content":"不被公司所定义 阿里这几年通过不断的锤炼，给业界贡献了一套不错的技术层级评估标准，并达到了与世界接轨的程度。这套标准的硬伤是不能细化到评估每一项工作，需要因地制宜做一些实例化，所以当亡成文后就死掉了，真正的话语权落在评估人手里，特别是在每两个层级问的灰色区域。大多数阿里人都会至次踏入这个区间，成功了皆大欢喜，失败了万念俱灰，我也失败过，还没有找到破解的灵丹妙药，这种无力感貌似只能独自排道。但如果跳出公司看职业技能要求，你会发现评估标准里面大多是对结果的盖棺定论，平常这么做事情容易功利，到真正被评估的时候也很难心平气和， 层级能带来很多优越感，但技术人都能超越层级，佩服真正有实力的程序员。《大国工匠》里面对工匠精神的描述特别好：执着专注、精益求精、一丝不苟、追求卓越。程序员很多时候是个手艺活，需要在实践中不断磨练，但眼高手低是个普遍情况，特别是代码越写越少的时候。好的工匠首先是会用工具，然后是不断打磨、创造新的更趁手工具， 我看到身边很多优秀的同学，都是擅于使用各种奇技淫巧，会想各种办法开发新工具提升团队整体研发效率，而且总是将系统逼近极限，找到一个个突破的新方向。于我自己，比较喜欢的一个思维模型就是1/10/100，用来寻找新的工具和突破口，实际操作上大体如下：针对一个具体的问题的解法，设想扩大某一维度规模到10倍、100倍， 思考对应的瓶颈是在哪里，需要什么粒度的分析工具，最终的方案本质上是个什么东西。这里的维度可以是我们场景的流量、数据量、延迟、用户数之类的。如果你对工作有迷茫、困惑，不妨试试玩玩这个游戏，体验不被手头工作限制的感觉。 通常技术人只要持之以恒地打磨自己的技术，在时间周期比较宽裕、软技能没有硬伤的情况下，晋升过程还是主导在自己手中的。但放眼到整个职业生涯，技术的重要性会逐步降低，而且大多数人都会有多段工作经验，如何沉淀可迁移的能力，完成更好地工作衔接和领域拓展更加关键。在阿里混得好不好，有时候影响没真没想象中那么大， 更多的时候我们要的是找到一条足够长、可持续积累的坡道。 ","date":"2022-10-24","objectID":"/posts/tech/al/growup/:3:2","tags":["内部"],"title":"内部-成长的烦恼-个人经历","uri":"/posts/tech/al/growup/"},{"categories":["内部"],"content":"与自己和社会和解 工作中再多的问题，最终归结起来都是人生意义实现的问题。有很多次我都觉得发展已经到瓶颈，人生就这样了： 有时候特别想做点事情，在历史上留下一点点痕迹；也时常觉得应该为这一代程序员探索一条可持续发展的路径真实情况是我什么也没干，因为再多的烦恼睡一觉就好了。 在阿里有两门课我收获比较大，一个是《choice》，一个是《功守道》，前者让我明白“承认自己的不足是多么美妙的体验”，后者让我明白“每一个优秀的人都曾付出过你不知道的努力”。它们让我在欲望和能力不匹配的时候总是能找到最终的解释权，哪怕明天还需要再解释一次。 从人类对于宇宙演化作用的视角来看，人所做的任何事情都毫无价值，哪怕连人是否有独立的自由意志现在都无法证明。从这点上，人生意义没有客观标准，每个人都只是在尝试给出自己的解，不用为自己的浵小而难过，学会跟自己和社会和解真的很有用。 ","date":"2022-10-24","objectID":"/posts/tech/al/growup/:3:3","tags":["内部"],"title":"内部-成长的烦恼-个人经历","uri":"/posts/tech/al/growup/"},{"categories":["内部"],"content":"后记 当我写完这些内心一下子平和了下来，深感这些很个人的经验充满了错误和片面，我也不知道还会维持这些观点多久，因为我比想象中的还要善变。希望你把本文当做一派胡言、 一派胡言、一派胡言，听说有个倒霉的家伙曾经是那么活过就行。 “快乐工作”真的很难发生，成长需要在不断的挑战中习得，如果觉得苦了累了，那可能只是成长中的烦恼而已，珍惜自己，与君共勉！ ","date":"2022-10-24","objectID":"/posts/tech/al/growup/:4:0","tags":["内部"],"title":"内部-成长的烦恼-个人经历","uri":"/posts/tech/al/growup/"},{"categories":["Java","内部"],"content":"一、踩坑经历 在使用JDK8中的stream大家肯定不陌生，而且在处理集合（list、map）的时候用起来很爽，更爽的是可以通过 ParallelStream 进行并行操作，充分压榨cpu的性能。同时也可以简化多线程代码的书写，用起来是真的香。但是很多时候印证了一句话，当你没有深刻理解一个框架的时候，用的时候很爽。踩坑的时候就更爽。具体的代码简化如下： //分批查询信息 List\u003cLong\u003e activityIds = activityIds.stream().distinct().collect(Collectors.toList()); List\u003cList\u003cLong\u003e\u003e idPartitions = ListUtils.partition(activityIds, 10); AtomicLong atomicLong = new AtomicLong(System.currentTimeMillis()); partition.parallelStream().forEach(ids -\u003e { AtomicLong start = new AtomicLong(System.currentTimeMillis()); //查询二方接口 //hsf invoke service.invoke(...); traceLog(\"query size\" + activityIds, start); }); 上述代码中实际的流程是，活动id批次请求二方接口，然后获取数据进行拼装。看似没有什么问题，但在一段时间内，频频出现接口超时的问题，各种排查，开始以为二方接口的时间问题。 后来通过各种定位，发现主要是在idPartitions.size大于200的时候，会出现超时问题，主要原因是由于 这种 parallelStream 是整个java进程共用一个 ForkJoinPool, 换句话说项目中很多 parallelStream 的地方会共用这个线程池，包括gc线程。所以一旦代码中用的地方多了。在同时运行的时候，自然会出现超时等待/超时问题。所以有必要对相关知识做一个整体的梳理，避免后续继续犯错。 ","date":"2022-10-24","objectID":"/posts/tech/al/parallelstream/:1:0","tags":["多线程","ParallelStream"],"title":"内部-Java ParallelStream 踩坑记录","uri":"/posts/tech/al/parallelstream/"},{"categories":["Java","内部"],"content":"二、预备知识1：意义关于并行和并发的概念 首先,在多线程并发编程中，有两个绕不开的术语并行和并发。很多同学可能对两者的区别不是很清楚，这里简单解释一下。 并行 指两个事件在同一个时间点同时发生，多核CPU提供了硬件上在同一个时间点同时执行两个指令的可能性。 并发 指两个事件在同一个时间段一起发生，硬件上单核cpu如果在同时运行多个任务（事件），就会在不同的时间点执行。不同任务的指令，但是在同一个时间点只能执行一个任务的一条指令。 综上所述，并行+并发可以更好的压榨cpu的性能。 ","date":"2022-10-24","objectID":"/posts/tech/al/parallelstream/:2:0","tags":["多线程","ParallelStream"],"title":"内部-Java ParallelStream 踩坑记录","uri":"/posts/tech/al/parallelstream/"},{"categories":["Java","内部"],"content":"三、预备知识2：线程池概念 线程池引出: 随着服务器硬件cpu核数越来越多，利用多线程技术以压榨cpu的性能，更加高效的运行程序。所以，多线程技术运用的越来越广泛。但是由于线程的创建和销毁都涉及到系统调用。比较消耗系统资源。所以就引入了线程池技术。避免频繁的线程创建和销毁。 javase提供了一个工具，可以为我们创建一个线程池,其本质就是new一个 ThreadPoolExecutor 对象。进入源码可以看到，就是new 各种 ThreadPoolExecutor, 且很多时候 Executor 提供的方法会有很多局限和不可控因素。 所以一般来说，我们可以自己来创建线程池。 线程池原理： public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue\u003cRunnable\u003e workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler){...} corePoolSize ：线程池的核心线程数，说白了就是即便是线程池里没有任何任务，也会有 corePoolSize 个线程在候着等待任务； maximumPoolSize ：最大线程数，不管你提交多少任务。线程池里最多工作线程数就是 maximumPoolSize； keepAliveTime ：线程的存活时间。当线程池里的线程数大于 corePoolSize 时，如果等了keepAliveTime 时长还没有任务可执行，则线程退出。 unit ：这个用来指定 keepAliveTime 的单位。比如秒 TimeUnit.SECONDES. workQueue : 一个阻塞队列，提交的任务将会被放到这个队列里。 threadFactory ：线程工厂，用来创建线程，主要是为了给线程起名字，默认工厂的线程名字：pool-1-thread-3. handler : 拒绝策略，当线程池里，线程被耗尽。且队列也满了的时候会调用。 具体的执行流程图如下： ","date":"2022-10-24","objectID":"/posts/tech/al/parallelstream/:3:0","tags":["多线程","ParallelStream"],"title":"内部-Java ParallelStream 踩坑记录","uri":"/posts/tech/al/parallelstream/"},{"categories":["Java","内部"],"content":"四、预备知识3 JDK自带的forkjoin线程池 可以通过 parallelStream 的源码发现 parallel Stream 底层是将任务进行了切分，最终将任物传递给了jdk8自带的 \"全局\"ForkJoinPool 线程池。在 Fork-Join 中。比如一个拥有4个线程的ForkJoinPool线程池，有一个任务队列，一个大的任务切分出的子任务会提交到线程池的任务队列中，4个线程从任务队列中获取任务执行。哪个线程执行的任务快，哪个线程执行的任务就多。 只有队列中没有任务线程是空闲的。这就是工作窃取。 可以通过下图更好的理解，这种分而治之的思想。 关键问题: 如果直接使用 parallelStream().foreach()，会默认使用全局的 ForkJoinPool，而这样就会导致当前程序很多地方共用同一个线程池，包括GC相关操作在内。所以一旦任务队列中满了之后，就会出现阻塞的情况，导致整个程序的只要当前使用 ForkJoinPool 地方都会出现问题！ ","date":"2022-10-24","objectID":"/posts/tech/al/parallelstream/:4:0","tags":["多线程","ParallelStream"],"title":"内部-Java ParallelStream 踩坑记录","uri":"/posts/tech/al/parallelstream/"},{"categories":["Java","内部"],"content":"五、如何合理的使用parallelStream 结合上述的问题，需要注意几点： parallelStream()中 foreach() 操作尽量保证是线程安全的 很多人在用惯了流式处理之后，很多for循环，都会直接使用流式foreach()，实际上这样不一定是合理的。如果只是简单的for循环，确实没有必要使用流式处理，因为流底层，封装了很多流式处理的复杂逻辑。从性能上来讲不占优。 parallelStream()中 foreach() 不要直接使用默认的线程池 ForkJoinPool customerPool = new ForkJoinPool(n); customerPool.submit(() -\u003e { lists.parallelStream().forEach(ids -\u003e { ... }); }).get(); parallelStream() 使用的时候尽量避免耗时操作 如果遇到耗时的操作。或者大量IO的操作，或者有线程sleep的操作，一定要避免使用并行流。 ","date":"2022-10-24","objectID":"/posts/tech/al/parallelstream/:5:0","tags":["多线程","ParallelStream"],"title":"内部-Java ParallelStream 踩坑记录","uri":"/posts/tech/al/parallelstream/"},{"categories":["Java","内部"],"content":"参考 https://juejin.cn/post/6996586542932164645 ","date":"2022-10-24","objectID":"/posts/tech/al/parallelstream/:6:0","tags":["多线程","ParallelStream"],"title":"内部-Java ParallelStream 踩坑记录","uri":"/posts/tech/al/parallelstream/"},{"categories":["生活"],"content":"当幸福来敲门 看过N遍的电影，记忆最深刻的台词： 当人们做不到一些事情的时候，他们就会对你说你也同样不能。 不要让别人告诉你，你不能做什么。 只要有梦想，就要去追求。 那些做不到的人总要告诉你，你也不行。 想要什么就得去努力，去追求。 克里斯用尽全部积蓄买下了高科技治疗仪，到处向医院推销，可是价格高昂，接受的人不多。就算他多努力都无法提供一个良好的生活环境给妻儿，妻子最终选择离开家。从此他带着儿子相依为命。克里斯好不容易争取回来一个股票投资公司实习的机会，就算没有报酬，成功机会只有百分之五，他仍努力奋斗，儿子是他的力量。他受尽白眼，与儿子躲在地铁站里的公共厕所里，住在教堂的收容所里…… 他坚信，幸福明天就会来临 ","date":"2022-10-07","objectID":"/posts/life/movie/inspriemovies/:1:0","tags":["电影"],"title":"情绪低落时，可以看下这些电影，自我治愈","uri":"/posts/life/movie/inspriemovies/"},{"categories":["生活"],"content":"垫底辣妹 高中女孩工藤沙耶加终日和小姐妹们吃喝玩乐，学习掉到了全年级倒数第一也毫不为意。温柔勤苦的妈妈为女儿的未来焦虑万分，因此将沙耶加送到了坪田所开办的补习班。经过水平测试，沙耶加实际只有小学四年级的水平，不过开朗自信的坪田不以为意，他以特有的方式打开女孩的心防，两人很快成为好朋友。在坪田的帮助下，沙耶加对学习的态度逐渐浓厚，后来更立下了考取庆应大学的宏愿。 电影改编自真实故事，主题不算新颖，一部差生的逆袭史，却打动人心，正如电影中所说“不管周围人怎么说你不行，充满自信地继续说出你的梦想的力量，不怕嘲讽和失败，勇于挑战梦想的力量，对我来说是多么耀眼。” ","date":"2022-10-07","objectID":"/posts/life/movie/inspriemovies/:2:0","tags":["电影"],"title":"情绪低落时，可以看下这些电影，自我治愈","uri":"/posts/life/movie/inspriemovies/"},{"categories":["生活"],"content":"风雨哈佛路 《风雨哈佛路》是一部催人警醒的励志电影。 影片介绍了一位生长在纽约的女孩丽兹经历人生的艰辛和辛酸，凭借自己的努力，最终走进了最高学府的经历。 丽兹出生在美国的贫民窟里，父母酗酒吸毒，母亲患上了精神分裂症。贫穷的丽兹需要出去乞讨，流浪在城市的角落，生活的苦难似乎无穷无尽。 随着慢慢成长，丽兹知道，只有读书成才方能改变自身命运，走出泥潭般的现况。她从老师那里争取到一张试卷，漂亮的完成答卷，争取到了读书的机会。她千方百计申请哈佛的全额奖学金，面试时候连一件像样的衣服也没有。然而，贫困并没有止住丽兹前进的决心，在她的人生里面，从不退缩的奋斗是永恒主题。 ","date":"2022-10-07","objectID":"/posts/life/movie/inspriemovies/:3:0","tags":["电影"],"title":"情绪低落时，可以看下这些电影，自我治愈","uri":"/posts/life/movie/inspriemovies/"},{"categories":["生活"],"content":"追梦赤子心 这是一部改编自丹尼尔· 鲁迪真人真事的励志电影，电影讲述了身材瘦小的鲁迪通过不懈努力，进入梦想中的圣母大学橄榄球队，并最终由替补变为正选队员的故事 。 《追梦赤子心》被认为是美国励志片的典范之作，赞扬了努力奋斗与信念坚定的美好品质。男主人公鲁迪传达了“只要努力，就能获得成功”的奋进精神，经过时间的见证，使这部电影的标题已经成为了一个代名词，代表着那些战胜偏见、勇往直前的赤子之心。 ","date":"2022-10-07","objectID":"/posts/life/movie/inspriemovies/:4:0","tags":["电影"],"title":"情绪低落时，可以看下这些电影，自我治愈","uri":"/posts/life/movie/inspriemovies/"},{"categories":["生活"],"content":"叫我第一名 电影改编自根据布拉德•科恩的真实故事改编，是一部自传类励志电影，影片讲述了叙述患有妥瑞氏症的男孩努力达到成为老师的梦想，并且克服病症的故事。 布莱德患有先天性的妥瑞氏症，这种严重的痉挛疾病，导致他无法控制地扭动脖子和发出奇怪的声音。而这种怪异的行为，更是让他从小不被老师和同学理解。 大学毕业后，布莱德秉持着每个学生都值得被教导的愿望决定当老师，为了找到一个愿意接受自己的学校，他不抛弃梦想，不放弃信念，默默努力着。最后，经过了大约25所学校的面试后，终于梦想成真。 ","date":"2022-10-07","objectID":"/posts/life/movie/inspriemovies/:5:0","tags":["电影"],"title":"情绪低落时，可以看下这些电影，自我治愈","uri":"/posts/life/movie/inspriemovies/"},{"categories":["生活"],"content":"那些最伟大的比赛 故事发生在20世纪之初，高尔夫球还只是英国贵族和绅士们的游戏，底层人民没有资格染指其中，它无疑是身份和权力的象征。少年弗朗西斯·奥密特出身平民家庭，读书之余他经常担任球童贴补家用。在这一过程中，对高尔夫球的热爱悄悄在他的心中生根发芽。他勤奋努力，且天资聪颖，渐渐成长为一名出色的业余选手。1913年，弗朗西斯有幸参加绅士云集的公开赛，它不仅有机会与自己的偶像哈里·瓦顿正面对决，还将成为改写高尔夫球史的重要人物…… ","date":"2022-10-07","objectID":"/posts/life/movie/inspriemovies/:6:0","tags":["电影"],"title":"情绪低落时，可以看下这些电影，自我治愈","uri":"/posts/life/movie/inspriemovies/"},{"categories":["生活"],"content":"决战冰河 根据真人真事改编的雪地历险故事，时代背景是第一次世界大战发生期间的1917年。主人公威尔的父亲死于一次事故，留下威尔照看整个家。由于需要钱来上大学以及照料父亲在南达科他州的农场，威尔决定去温尼伯(加拿大城市)参加一次在圣保罗(美国明尼苏达州首府)举行的雪橇犬马拉松比赛。在一个叫奈德的人的帮助下，少年威尔克服了生理和心理上的挑战。比赛中，凭着他的勇气在报纸媒体上开始出名。全长五百多英哩，威尔一路历经暴风雪和冰河的恶劣地形考验，终于还是到达目标。 ","date":"2022-10-07","objectID":"/posts/life/movie/inspriemovies/:7:0","tags":["电影"],"title":"情绪低落时，可以看下这些电影，自我治愈","uri":"/posts/life/movie/inspriemovies/"},{"categories":["生活"],"content":"永不放弃 如果你是一个有脑瘫病史的人，如果你永远无法站直，走起路来一跛一跛的，一只手只能永远地反背在身后，连打领带、系鞋带、扣袖口这样的事都需要别人的帮助才行，如果你完全可以凭借救济金生活，你还会出去工作并且梦想着做一个自食其力的人吗？ 故事的主人公比尔就是这样一位残障人士，他患有先天性脑瘫，但比尔并不甘心成为一个失败者，他希望能通过自己的努力，在生命中获得成功。从1955年起，他开始尝试做上门推销员，起初他四处碰壁，并且经常遭到“正常人”的白眼。但是，他并不气馁，继续着自己的事业…… ","date":"2022-10-07","objectID":"/posts/life/movie/inspriemovies/:8:0","tags":["电影"],"title":"情绪低落时，可以看下这些电影，自我治愈","uri":"/posts/life/movie/inspriemovies/"},{"categories":["生活"],"content":"听见天堂 当上帝为你关上一扇门时，往往他会为你打开另一扇。意大利男孩米克虽然出身在穷乡僻壤，但他从小就梦想成一流的电影大师，只因他是那么的热爱电影。然而上帝跟他开了一个最残酷的玩笑，米克玩弄一支来复枪时不幸走火，从此他只能淹没在巨大的黑暗当中。这一度令米克感到沮丧万分，仿佛活着已没有了动力。然而盲校的老师的一番话让米克豁然开朗，为什么音乐家在演奏时会闭上眼睛，因为那样音符会蜕变，变的更有力量。于是，米克选择了用耳朵代替眼睛，去记录他生活的点点滴滴。 这时，我们才发现：原来，不仅可以看见天堂，还可以听见天堂。 ","date":"2022-10-07","objectID":"/posts/life/movie/inspriemovies/:9:0","tags":["电影"],"title":"情绪低落时，可以看下这些电影，自我治愈","uri":"/posts/life/movie/inspriemovies/"},{"categories":["生活"],"content":"练腿的好处 提升人体心肺功能 深蹲练习中，可以训练到人体200多块肌肉，耗能很多，能很好地锻炼并提升人体心肺功能。当然，心肺功能的提高不是靠一两次深蹲就可以完成的，必须要长期坚持练腿才有效果。 ","date":"2022-09-11","objectID":"/posts/life/fitness/fitness/:1:0","tags":["健身"],"title":"Fitness","uri":"/posts/life/fitness/fitness/"},{"categories":["生活"],"content":"促进肌肉生长 研究表明，将练腿纳入到训练计划中时，肌肉确实长得更快。各项研究都显示出，深蹲和硬拉 能让你释放出比做其它动作更多的增肌关联类激素（生长激素、睾丸酮），从而加速肌肉的生长，不仅仅只是针对腿部，对全身肌肉都是有好处的。 ","date":"2022-09-11","objectID":"/posts/life/fitness/fitness/:1:1","tags":["健身"],"title":"Fitness","uri":"/posts/life/fitness/fitness/"},{"categories":["生活"],"content":"提升身体协调性 腿部肌肉占了全身肌肉群的60%，练腿强化下肢力量，可以提升你身体的协调性。例如最近吕良伟强烈推荐的的扎马步，其实就是为了练腿，腰马合一，加强全身的核心力量。 ","date":"2022-09-11","objectID":"/posts/life/fitness/fitness/:1:2","tags":["健身"],"title":"Fitness","uri":"/posts/life/fitness/fitness/"},{"categories":["生活"],"content":"防止衰老 人老腿先老。同样都是老年人，大名鼎鼎的深蹲博士，46时还能深蹲1014磅，现在他60多岁了，仍然像年轻人一样强壮健康。 ","date":"2022-09-11","objectID":"/posts/life/fitness/fitness/:1:3","tags":["健身"],"title":"Fitness","uri":"/posts/life/fitness/fitness/"},{"categories":["生活"],"content":"深蹲刺激性激素 腿部肌肉的训练，可以增长人体的睾丸素水平，男人要想壮阳，练腿吧！ ","date":"2022-09-11","objectID":"/posts/life/fitness/fitness/:1:4","tags":["健身"],"title":"Fitness","uri":"/posts/life/fitness/fitness/"},{"categories":["生活"],"content":"一套腿部训练动作 ","date":"2022-09-11","objectID":"/posts/life/fitness/fitness/:2:0","tags":["健身"],"title":"Fitness","uri":"/posts/life/fitness/fitness/"},{"categories":["生活"],"content":"1、徒手深蹲 10-20次*1-3组 动作要领： 双脚分开略宽与肩，脚尖向外延展。 屈髋下蹲至大腿与地面平行，手臂水平向前伸直，掌心向下，膝盖与脚尖方向一致。 ","date":"2022-09-11","objectID":"/posts/life/fitness/fitness/:2:1","tags":["健身"],"title":"Fitness","uri":"/posts/life/fitness/fitness/"},{"categories":["生活"],"content":"2、保加利亚深蹲 10-20次*1-3组 动作要领： 左侧单腿站立，右脚脚面搭在椅子边缘，双手叉腰，腰背挺直。 左腿屈膝下蹲，直至大腿与地面平行，膝盖不超过脚尖。臀部收缩，脚后跟发力抬起。 重复另一侧。 ","date":"2022-09-11","objectID":"/posts/life/fitness/fitness/:2:2","tags":["健身"],"title":"Fitness","uri":"/posts/life/fitness/fitness/"},{"categories":["生活"],"content":"3、箭步蹲 10-20次*1-3组 动作要领： 双脚脚尖向前，右腿后撤，臀部垂直下坐，左腿膝盖不超过脚尖，保持腰背挺直，略作停顿后匀速还原。 重复另一侧。 ","date":"2022-09-11","objectID":"/posts/life/fitness/fitness/:2:3","tags":["健身"],"title":"Fitness","uri":"/posts/life/fitness/fitness/"},{"categories":["生活"],"content":"4、相扑深蹲 10-20次*1-3组 动作要领： 双手抱拳，双肩两倍宽于肩，脚尖斜向外打开，腰背挺直。 屈膝下蹲，臀部后坐，膝盖与脚尖方向一致，蹲至大腿水平，略作停顿后还原。 ","date":"2022-09-11","objectID":"/posts/life/fitness/fitness/:2:4","tags":["健身"],"title":"Fitness","uri":"/posts/life/fitness/fitness/"},{"categories":["生活"],"content":"5、原地深蹲跳 10-20次*1-3组 动作要领： 练习时双手放在体前，收紧腰腹部。 集中腿部的力量蹬地向上跳起。 还原下落时保持膝盖弯曲。 ","date":"2022-09-11","objectID":"/posts/life/fitness/fitness/:2:5","tags":["健身"],"title":"Fitness","uri":"/posts/life/fitness/fitness/"},{"categories":["生活"],"content":"6、杠铃硬拉 3-4组*10-20次 动作要领： 自然站立，双脚与肩同宽。双手握住杠铃，腰腹收紧，腰背挺直。 身体缓缓向下至与地面平行，膝关节微屈。略作停顿后，伸髋将杠铃贴住小腿拉起。 ","date":"2022-09-11","objectID":"/posts/life/fitness/fitness/:2:6","tags":["健身"],"title":"Fitness","uri":"/posts/life/fitness/fitness/"},{"categories":["生活"],"content":"7、哑铃硬拉 3-4组*10-20次 动作要领： 自然站立，双脚与肩同宽，腰背挺直，双手握住哑铃，拳心向内。俯身后坐，下沉肩部，下背部绷紧挺直。 至肘部略高于膝盖后，臀部发力，缓慢还原。全程小臂保持竖直向下，膝盖不超过脚尖。 ","date":"2022-09-11","objectID":"/posts/life/fitness/fitness/:2:7","tags":["健身"],"title":"Fitness","uri":"/posts/life/fitness/fitness/"},{"categories":["生活"],"content":"每天抽点时间练习 你也可以拥有完美腿型！ ","date":"2022-09-11","objectID":"/posts/life/fitness/fitness/:3:0","tags":["健身"],"title":"Fitness","uri":"/posts/life/fitness/fitness/"},{"categories":["leetcode"],"content":"1-容易-两数之和 1-容易-两数之和 给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标。 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。 你可以按任意顺序返回答案。 class Solution { public int[] twoSum(int[] nums, int target) { Map\u003cInteger/*value*/, Integer/*index*/\u003e map = new HashMap\u003c\u003e(); for (int i = 0; i \u003c nums.length; i++) { if (map.containsKey(target - nums[i])) { return new int[]{map.get(target - nums[i]), i}; } // map.put(nums[i], i); 一定放到if后面，不然就会可能存在 mums[i]+i=target, i是自己 map.put(nums[i], i); } return null; } } ","date":"2022-09-10","objectID":"/posts/tech/leetcode/collect/:1:0","tags":["综合","leetcode"],"title":"算法-搜集","uri":"/posts/tech/leetcode/collect/"},{"categories":["leetcode"],"content":"2-中等-两数相加 2-中等-两数相加 给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。 请你将两个数相加，并以相同形式返回一个表示和的链表。 你可以假设除了数字 0 之外，这两个数都不会以 0 开头。 /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { //定义一个新联表伪指针，用来指向头指针，返回结果 ListNode prev = new ListNode(0); //定义一个进位数的指针，用来存储当两数之和大于10的时候， int carry = 0; //定义一个可移动的指针，用来指向存储两个数之和的位置 ListNode cur = prev; //当l1 不等于null或l2 不等于空时，就进入循环 while (l1 != null || l2 != null) { //如果l1 不等于null时，就取他的值，等于null时，就赋值0，保持两个链表具有相同的位数 int x = l1 != null ? l1.val : 0; //如果l1 不等于null时，就取他的值，等于null时，就赋值0，保持两个链表具有相同的位数 int y = l2 != null ? l2.val : 0; //将两个链表的值，进行相加，并加上进位数 int sum = x + y + carry; //计算进位数 carry = sum / 10; //计算两个数的和，此时排除超过10的请况（大于10，取余数） sum = sum % 10; //将求和数赋值给新链表的节点， //注意这个时候不能直接将sum赋值给cur.next = sum。这时候会报，类型不匹配。 //所以这个时候要创一个新的节点，将值赋予节点 cur.next = new ListNode(sum); //将新链表的节点后移 cur = cur.next; //当链表l1不等于null的时候，将l1 的节点后移 if (l1 != null) { l1 = l1.next; } //当链表l2 不等于null的时候，将l2的节点后移 if (l2 != null) { l2 = l2.next; } } //如果最后两个数，相加的时候有进位数的时候，就将进位数，赋予链表的新节点。 //两数相加最多小于20，所以的的值最大只能时1 if (carry == 1) { cur.next = new ListNode(carry); } //返回链表的头节点 return prev.next; } } ","date":"2022-09-10","objectID":"/posts/tech/leetcode/collect/:2:0","tags":["综合","leetcode"],"title":"算法-搜集","uri":"/posts/tech/leetcode/collect/"},{"categories":["leetcode"],"content":"3-中等-无重复字符的最长子串 3-中等-无重复字符的最长子串 给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。 class Solution { /** * 滑动窗口 */ public int lengthOfLongestSubstring(String s) { Map\u003cCharacter, Integer\u003e windowMap = new HashMap\u003c\u003e(); int left = 0, right = 0; int max = 0; while (right \u003c s.length()) { // c 是将移入窗口的字符 char c = s.charAt(right); // 扩大窗口 right++; // 判断左侧窗口是否要收缩 [注意此处为 p.length()] windowMap.put(c, windowMap.getOrDefault(c, 0) + 1); while (windowMap.get(c) \u003e 1) { // d 是将移出窗口的字符 char d = s.charAt(left); // 缩小窗口 left++; // 进行窗口内数据的一系列更新 windowMap.put(d, windowMap.getOrDefault(d, 0) - 1); } max = Math.max(max, right - left); } return max; } // public int lengthOfLongestSubstring(String s) { // int ans = 0; // int len = s.length(); // Map\u003cCharacter, Integer\u003e map = new HashMap\u003c\u003e(); // for (int i = 0, j = 0; j \u003c len; j++) { // //判断这个字母是否在map中。 // if(map.containsKey(s.charAt(j))) { // //如果在，说明重复了，需要移动i了，将i移动到 s.charAt(j) 这个字母的下一位。 // //因为map中的key字母可以重复，所以，查找最大的i保证了i是在最右边。 // i = Math.max(map.get(s.charAt(j)), i); // } // //如果不再，说明这位也是字符串的字母，需要加一。 // ans = Math.max(ans, j-i+1); // //将键值对写入map，key是字母，位置是value。不用管重复的问题，只需要移动i到合适的位置即可。 // map.put(s.charAt(j), j+1); // } // return ans; // } } ","date":"2022-09-10","objectID":"/posts/tech/leetcode/collect/:3:0","tags":["综合","leetcode"],"title":"算法-搜集","uri":"/posts/tech/leetcode/collect/"},{"categories":["leetcode"],"content":"5-中等-最长的回文子串 5-中等-最长的回文子串 给你一个字符串 s，找到 s 中最长的回文子串。 class Solution { /** * 中心扩展算法 * 找到以 s[i] 为中心的回文串 * 找到以 s[i] 和 s[i+1] 为中心的回文串 * 更新答案 */ public String longestPalindrome(String s) { String maxStr = \"\"; for (int i = 0; i \u003c s.length(); i++) { // 以 s[i] 为中心的最长回文子串 String tmp = queryLongStr(s, i, i); maxStr = maxStr.length() \u003e tmp.length() ? maxStr : tmp; // 以 s[i] 和 s[i+1] 为中心的最长回文子串 tmp = queryLongStr(s, i, i + 1); maxStr = maxStr.length() \u003e tmp.length() ? maxStr : tmp; } return maxStr; } // 在 s 中寻找以 s[l] 和 s[r] 为中心的最长回文串 public String queryLongStr(String s, int l, int r) { // 防止索引越界 while (l \u003e= 0 \u0026\u0026 r \u003c s.length() \u0026\u0026 s.charAt(l) == s.charAt(r)) { // 双指针，向两边展开 l--; r++; } // 返回以 s[l] 和 s[r] 为中心的最长回文串 return s.substring(l + 1, r); } } ","date":"2022-09-10","objectID":"/posts/tech/leetcode/collect/:4:0","tags":["综合","leetcode"],"title":"算法-搜集","uri":"/posts/tech/leetcode/collect/"},{"categories":["leetcode"],"content":"7-中等-整数反转 7-中等-整数反转 给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。 如果反转后整数超过 32 位的有符号整数的范围 [−231, 231 − 1] ，就返回 0。 假设环境不允许存储 64 位整数（有符号或无符号）。 class Solution { public int reverse(int x) { int result = 0; while (x != 0) { //边界值判定，防止integer溢出 if (result \u003e Integer.MAX_VALUE / 10 || result \u003c Integer.MIN_VALUE / 10) { return 0; } int n = x % 10; result = result * 10 + n; x = x / 10; } return result; } } ","date":"2022-09-10","objectID":"/posts/tech/leetcode/collect/:5:0","tags":["综合","leetcode"],"title":"算法-搜集","uri":"/posts/tech/leetcode/collect/"},{"categories":["leetcode"],"content":"8-简单-字符串转换整数 (atoi) 8-简单-字符串转换整数 (atoi) 请你来实现一个 myAtoi(string s) 函数，使其能将字符串转换成一个 32 位有符号整数（类似 C/C++ 中的 atoi 函数）。 函数 myAtoi(string s) 的算法如下： 读入字符串并丢弃无用的前导空格 检查下一个字符（假设还未到字符末尾）为正还是负号，读取该字符（如果有）。 确定最终结果是负数还是正数。 如果两者都不存在，则假定结果为正。 读入下一个字符，直到到达下一个非数字字符或到达输入的结尾。字符串的其余部分将被忽略。 将前面步骤读入的这些数字转换为整数（即，“123” -\u003e 123， “0032” -\u003e 32）。如果没有读入数字，则整数为 0 。必要时更改符号（从步骤 2 开始）。 如果整数数超过 32 位有符号整数范围 [−231, 231 − 1] ，需要截断这个整数，使其保持在这个范围内。具体来说，小于 −231 的整数应该被固定为 −231 ，大于 231 − 1 的整数应该被固定为 231 − 1 。 返回整数作为最终结果。 注意： 本题中的空白字符只包括空格字符 ’ ’ 。 除前导空格或数字后的其余字符串外，请勿忽略 任何其他字符。 class Solution { /** * 1.删除开头空白字符 * 2.排除全部为空的极端case * 3.设置符号 * 4.超出integer上下边界处理 */ public int myAtoi(String s) { char[] arrays = s.toCharArray(); int index = 0; // 1、去除前导空格 while (index \u003c arrays.length \u0026\u0026 arrays[index] == ' ') { index++; } // 2、如果已经遍历完成（针对极端用例 \" \"） if (index == arrays.length) { return 0; } //3.判断符号, 如果出现符号字符，仅第 1 个有效，并记录正负 int sign = 1; char firstChar = arrays[index]; if (firstChar == '+') { index++; } else if (firstChar == '-') { sign = -1; index++; } // 4、将后续出现的数字字符进行转换 // 不能使用 long 类型，这是题目说的 int result = 0; while (index \u003c arrays.length) { char currChar = arrays[index]; // 4.1 先判断不合法的情况 如\"+-42\" if (currChar \u003c '0' || currChar \u003e '9') { break; } //integer 边界值判断 if (result \u003e Integer.MAX_VALUE / 10 || (result == Integer.MAX_VALUE / 10 \u0026\u0026 (currChar - '0') \u003e Integer.MAX_VALUE % 10)) { return Integer.MAX_VALUE; } //注意为 -(Integer.MIN_VALUE % 10) 而不是 -Integer.MIN_VALUE % 10 ; 需要加括号 if (result \u003c Integer.MIN_VALUE / 10 || (result == Integer.MIN_VALUE / 10 \u0026\u0026 (currChar - '0') \u003e -(Integer.MIN_VALUE % 10))) { return Integer.MIN_VALUE; } //注意 (currChar-'0') result = result * 10 + (currChar - '0') * sign; index++; } return result; } } ","date":"2022-09-10","objectID":"/posts/tech/leetcode/collect/:6:0","tags":["综合","leetcode"],"title":"算法-搜集","uri":"/posts/tech/leetcode/collect/"},{"categories":["leetcode"],"content":"9-中等-回文数 9-中等-回文数 给你一个整数 x ，如果 x 是一个回文整数，返回 true ；否则，返回 false 。 回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。 例如，121 是回文，而 123 不是。 class Solution { /** * (反转一半数字) 取出后半段数字进行翻转。 * 为了避免数字反转可能导致的溢出问题，为什么不考虑只反转 \\text{int}int 数字的一半？毕竟，如果该数字是回文，其后半部分反转后应该与原始数字的前半部分相同。 * \u003cp\u003e * 这里需要注意的一个点就是由于回文数的位数可奇可偶，所以当它的长度是偶数时，它对折过来应该是相等的；当它的长度是奇数时，那么它对折过来后，有一个的长度需要去掉一位数（除以 10 并取整）。 * \u003cp\u003e * 具体做法如下： * \u003cp\u003e * 每次进行取余操作 （ %10），取出最低的数字：y = x % 10 * 将最低的数字加到取出数的末尾：revertNum = revertNum * 10 + y * 每取一个最低位数字，x 都要自除以 10 * 判断 x 是不是小于 revertNum ，当它小于的时候，说明数字已经对半或者过半了 * 最后，判断奇偶数情况：如果是偶数的话，revertNum 和 x 相等；如果是奇数的话，最中间的数字就在revertNum 的最低位上，将它除以 10 以后应该和 x 相等。 * 链接：https://leetcode.cn/problems/palindrome-number/solution/dong-hua-hui-wen-shu-de-san-chong-jie-fa-fa-jie-ch/ */ public boolean isPalindrome(int x) { // 特殊情况： // 如上所述，当 x \u003c 0 时，x 不是回文数。 // 同样地，如果数字的最后一位是 0，为了使该数字为回文， // 则其第一位数字也应该是 0 // 只有 0 满足这一属性 if (x \u003c 0 || (x != 0 \u0026\u0026 x % 10 == 0)) { return false; } int reverseNum = 0; // 由于整个过程我们不断将原始数字除以 10，然后给反转后的数字乘上 10，所以，当原始数字小于或等于反转后的数字时，就意味着我们已经处理了一半位数的数字了。 while (x \u003e reverseNum) { reverseNum = reverseNum * 10 + x % 10; x /= 10; } // 当数字长度为奇数时，我们可以通过 revertedNumber/10 去除处于中位的数字。 // 例如，当输入为 12321 时，在 while 循环的末尾我们可以得到 x = 12，revertedNumber = 123， // 由于处于中位的数字不影响回文（它总是与自己相等），所以我们可以简单地将其去除。 return x == reverseNum || x == reverseNum / 10; } /** * 简单粗暴，看看就行 (不可取) */ public boolean isPalindrome2(int x) { String compare = (new StringBuilder(x + \"\")).reverse().toString(); return (x + \"\").equals(compare); } } ","date":"2022-09-10","objectID":"/posts/tech/leetcode/collect/:7:0","tags":["综合","leetcode"],"title":"算法-搜集","uri":"/posts/tech/leetcode/collect/"},{"categories":["leetcode"],"content":"11-中等-盛最多水的容器 11-中等-盛最多水的容器 给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。 找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。 返回容器可以储存的最大水量。 说明：你不能倾斜容器。 // 方法1：暴力解法 // 双for循环，时间复杂度o（n方），空间复杂度n； // 耗时严重，废弃； // public int maxArea(int[] height) { // int max = 0; // for (int i = 0; i \u003c height.length; i++) { // for (int j = i+1; j \u003c height.length; j++) { // max = Math.max(max, (j - i) * Math.min(height[i],height[j])); // } // } // return max; // } /** * 双指针法， 源于数学公示 * @param height * @return */ public int maxArea(int[] height) { int l = 0, r = height.length - 1; int result = 0; while (l \u003c r) { int area = (r - l) * Math.min(height[l], height[r]); result = Math.max(result, area); if (height[l] \u003c= height[r]) { l++; } else { r--; } } return result; } ","date":"2022-09-10","objectID":"/posts/tech/leetcode/collect/:8:0","tags":["综合","leetcode"],"title":"算法-搜集","uri":"/posts/tech/leetcode/collect/"},{"categories":["leetcode"],"content":"14-简单-最长公共前缀 14-简单-最长公共前缀 编写一个函数来查找字符串数组中的最长公共前缀。 如果不存在公共前缀，返回空字符串 “\"。 class Solution { /** * 横向扫描 */ public String longestCommonPrefix(String[] strs) { if (strs == null || strs.length == 0) { return \"\"; } //取数组第1个值作为预比较对象 String preStr = strs[0]; //注意此处循环 从1开始； for (int i = 1; i \u003c strs.length; i++) { preStr = compare(strs[i], preStr); if (preStr.length() == 0) { break; } } return preStr; } public String compare(String s1, String s2) { int len = Math.min(s1.length(), s2.length()); int index = 0; while (index \u003c len \u0026\u0026 s1.charAt(index) == s2.charAt(index)) { index++; } return s1.substring(0, index); } } ","date":"2022-09-10","objectID":"/posts/tech/leetcode/collect/:9:0","tags":["综合","leetcode"],"title":"算法-搜集","uri":"/posts/tech/leetcode/collect/"},{"categories":["leetcode"],"content":"19-中等-单链表的倒数第 k 个节点 19-中等-单链表的倒数第 k 个节点 给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。 class Solution { /** * 法1：双指针，单次链表遍历 */ public ListNode removeNthFromEnd(ListNode head, int n) { // 虚拟头结点 ListNode dump = new ListNode(0); //注意此处 dump.next = head; // 删除倒数第 n 个，先找倒数第 n + 1 个节点 [注意此处 为n+1] ListNode objNode = findFromEnd(dump, n + 1); // 删掉倒数第 n 个节点 objNode.next = objNode.next.next; return dump.next; } // 返回链表的倒数第 n 个节点 public ListNode findFromEnd(ListNode head, int n) { ListNode p1 = head; // p1 先走 n 步 for (int i = 0; i \u003c n; i++) { p1 = p1.next; } ListNode p2 = head; // p1 和 p2 同时走 len - k 步 while (p1 != null) { p1 = p1.next; p2 = p2.next; } // p2 现在指向第 len - n + 1 个节点，即倒数第 n 个节点 return p2; } /** * 法2：2次链表遍历； 先循环查询链表总长度，在走到特定节点，操作； */ public ListNode removeNthFromEnd2(ListNode head, int n) { ListNode dummy = new ListNode(0, head); int length = getLength(head); ListNode cur = dummy; for (int i = 1; i \u003c length - n + 1; ++i) { cur = cur.next; } cur.next = cur.next.next; //注意：此处return不能是cur.next，原因？ return dummy.next; // ListNode ans = dummy.next; // return ans; } public int getLength(ListNode head) { int length = 0; while (head != null) { ++length; head = head.next; } return length; } } ","date":"2022-09-10","objectID":"/posts/tech/leetcode/collect/:10:0","tags":["综合","leetcode"],"title":"算法-搜集","uri":"/posts/tech/leetcode/collect/"},{"categories":["leetcode"],"content":"20-简单-有效的括号 20-简单-有效的括号 给定一个只包括 ‘(’，’)’，’{’，’}’，’[’，’]’ 的字符串 s ，判断字符串是否有效。 有效字符串需满足： 左括号必须用相同类型的右括号闭合。 左括号必须以正确的顺序闭合。 每个右括号都有一个对应的相同类型的左括号。 class Solution { public boolean isValid(String s) { Stack\u003cCharacter\u003e stack = new Stack\u003c\u003e(); for (char c : s.toCharArray()) { if (c == '(' || c == '{' || c == '[') { stack.push(c); } else { // 字符 c 是右括号 if (!stack.isEmpty() \u0026\u0026 stack.peek() == queryMatch(c)) { stack.pop(); }else{ // 和最近的左括号不匹配 return false; } } } // 是否所有的左括号都被匹配了 return stack.isEmpty(); } public Character queryMatch(Character c) { if (c == ')') { return '('; } if (c == ']') { return '['; } if (c == '}') { return '{'; } return null; } } ","date":"2022-09-10","objectID":"/posts/tech/leetcode/collect/:11:0","tags":["综合","leetcode"],"title":"算法-搜集","uri":"/posts/tech/leetcode/collect/"},{"categories":["leetcode"],"content":"21-简单-合并两个有序链表 21-简单-合并两个有序链表 将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 class Solution { /** * 法1- 迭代 * 参见讲解 * https://www.bilibili.com/video/BV1pZ4y1Y76v?spm_id_from=333.337.search-card.all.click */ public ListNode mergeTwoLists(ListNode list1, ListNode list2) { //定义新链表作为结果链表，首节点为哑结点，虚拟头结点 ListNode dump = new ListNode(0); //定义新链表的当前节点，也可以理解为尾部节点，作为指针参与和其他数值做比较运算 ListNode cur = dump; while (list1 != null \u0026\u0026 list2 != null) { // 比较 list1 和 list2 两个指针 // 将值较小的的节点接到 cur 指针 if (list2.val \u003e list1.val) { cur.next = list1; list1 = list1.next; } else { cur.next = list2; list2 = list2.next; } // cur 指针不断前进 cur = cur.next; } cur.next = (list1 == null) ? list2 : list1; return dump.next; } } /** * 法2- 递归调用 */ public ListNode mergeTwoLists(ListNode l1, ListNode l2) { if (l1 == null) { return l2; } else if (l2 == null) { return l1; } else if (l1.val \u003c l2.val) { l1.next = mergeTwoLists(l1.next, l2); return l1; } else { l2.next = mergeTwoLists(l1, l2.next); return l2; } } ","date":"2022-09-10","objectID":"/posts/tech/leetcode/collect/:12:0","tags":["综合","leetcode"],"title":"算法-搜集","uri":"/posts/tech/leetcode/collect/"},{"categories":["leetcode"],"content":"23-困难-合并 k 个有序链表 23-困难-合并 k 个有序链表 给你一个链表数组，每个链表都已经按升序排列。 请你将所有链表合并到一个升序链表中，返回合并后的链表。 class Solution { /** * 法1: 使用优先队列合并 */ public ListNode mergeKLists(ListNode[] lists) { if (lists.length == 0) { return null; } //使用排序队列 PriorityQueue\u003cListNode\u003e pq = new PriorityQueue\u003c\u003e(lists.length, (a, b) -\u003e a.val - b.val); for (int i = 0; i \u003c lists.length; i++) { if (lists[i] != null) { pq.add(lists[i]); } } ListNode dump = new ListNode(0); ListNode cur = dump; while (!pq.isEmpty()) { ListNode node = pq.poll(); cur.next = node; cur = cur.next; if (node.next != null) { pq.add(node.next); } } return dump.next; } /** * 法2: 顺序合并 */ public ListNode mergeKLists(ListNode[] lists) { if (lists.length == 0) { return null; } ListNode ans = null; for (int i = 0; i \u003c lists.length; i++) { // mergeTwoLists 参照合并两个有序链表的解法 ans = mergeTwoLists(ans, lists[i]); } return ans; } } ","date":"2022-09-10","objectID":"/posts/tech/leetcode/collect/:13:0","tags":["综合","leetcode"],"title":"算法-搜集","uri":"/posts/tech/leetcode/collect/"},{"categories":["leetcode"],"content":"27-简单-移除元素 27-简单-移除元素 给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。 不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。 元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。 class Solution { /** * 移动完成后， nums[0]-nums[slow-1] 之间不包含val； nums[slow]-nums[nums.Length-1] 之间包含val */ public int removeElement(int[] nums, int val) { int slow = 0 ; int len = nums.length; for (int i = 0; i \u003c len; i++) { if (nums[i] != val) { // nums[slow] = nums[i]; // slow++; //等同于上面 nums[slow++] = nums[i]; } } return slow; } } ","date":"2022-09-10","objectID":"/posts/tech/leetcode/collect/:14:0","tags":["综合","leetcode"],"title":"算法-搜集","uri":"/posts/tech/leetcode/collect/"},{"categories":["leetcode"],"content":"28-简单-实现 strStr() 28-简单-实现 strStr() 给你两个字符串haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串出现的第一个位置（下标从 0 开始）。如果不存在，则返回 -1 。 class Solution { /** * 法1： 朴素解法-匹配-代码优化 */ public int strStr(String haystack, String needle) { int len = haystack.length(); int lengthNeeded = needle.length(); for (int i = 0; i \u003c= len - lengthNeeded; i++) { int a = i; int b = 0; //注意边界判定 b\u003clengthNeeded while (b\u003clengthNeeded \u0026\u0026 haystack.charAt(a) == needle.charAt(b)) { a++; b++; } if (b == lengthNeeded) { return i; } } return -1; } /** * KMP 解法 */ public int strStr2(String haystack, String needle) { } /** * 暴力解法 */ public int strStr3(String haystack, String needle) { if (needle.length() == 0 || needle.length() \u003e haystack.length()) { return -1; } int objLength = needle.length(); int left = 0, right = left + objLength - 1; while (right \u003c haystack.length()) { if (compare(haystack, needle, left, right)) { break; } left++; right = left + objLength - 1; } return left != -1 ? left : -1; } public boolean compare(String haystack, String needle, int start, int end) { int i = 0; boolean result = true; while (start \u003c= end) { if (haystack.charAt(start++) != needle.charAt(i++)) { result = false; break; } } return result; } } ","date":"2022-09-10","objectID":"/posts/tech/leetcode/collect/:15:0","tags":["综合","leetcode"],"title":"算法-搜集","uri":"/posts/tech/leetcode/collect/"},{"categories":["leetcode"],"content":"34-中等-在排序数组中查找元素的第一个和最后一个位置 34-中等-在排序数组中查找元素的第一个和最后一个位置 给你一个按照非递减顺序排列的整数数组 nums，和一个目标值 target。请你找出给定目标值在数组中的开始位置和结束位置。 如果数组中不存在目标值 target，返回 [-1, -1]。 你必须设计并实现时间复杂度为 O(log n) 的算法解决此问题。 class Solution { /** * 先找\u003e=target的第一个 * 再找\u003etarget的第一个 * 我真是这辈子都不想看见这题 */ public int[] searchRange(int[] nums, int target) { //先找\u003e=target的第一个 int l = search(nums, target); //再找\u003etarget的第一个 int r = search(nums, target + 1); if (l == nums.length || nums[l] != target) { return new int[]{-1, -1}; } //注意此处 r-1 return new int[]{l, r - 1}; } /** * 找\u003e=target的第一个 */ public int search(int[] nums, int target) { int l = 0, r = nums.length; while (l \u003c r) { int mid = (r + l) \u003e\u003e 1; if (nums[mid] \u003e= target) r = mid; else l = mid + 1; } return l; } } ","date":"2022-09-10","objectID":"/posts/tech/leetcode/collect/:16:0","tags":["综合","leetcode"],"title":"算法-搜集","uri":"/posts/tech/leetcode/collect/"},{"categories":["leetcode"],"content":"35-简单-搜索插入位置 35-简单-搜索插入位置 给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。 请必须使用时间复杂度为 O(log n) 的算法。 class Solution { public int searchInsert(int[] nums, int target) { int left = 0, right = nums.length - 1; while (left \u003c= right) { // 特别注意，此处需要+left int middle = (right - left) / 2 + left; if (nums[middle] \u003e target) { right = middle - 1; } else if (nums[middle] == target) { return middle; } else if (nums[middle] \u003c target) { left = middle + 1; } } //注意此处：返回值是left，想想为什么？ return left; } } ","date":"2022-09-10","objectID":"/posts/tech/leetcode/collect/:17:0","tags":["综合","leetcode"],"title":"算法-搜集","uri":"/posts/tech/leetcode/collect/"},{"categories":["leetcode"],"content":"66-简单-加一 66-简单-加一 给定一个由 整数 组成的 非空 数组所表示的非负整数，在该数的基础上加一。 最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。 你可以假设除了整数 0 之外，这个整数不会以零开头。 class Solution { /** * 不用纠结某一位是不是9，而应该去判断加1之后是不是0 */ public int[] plusOne(int[] digits) { int len = digits.length; for (int i = len - 1; i \u003e= 0; i--) { //每一位数，加1 digits[i] = (digits[i] + 1) % 10; //若为+1后为0，则进行下一循环，继续+1 if (digits[i] != 0) { return digits; } } //此时，digits内数值已均为0 //对所有为均为9的特殊情况 digits = new int[len + 1]; digits[0] = 1; return digits; } } ","date":"2022-09-10","objectID":"/posts/tech/leetcode/collect/:18:0","tags":["综合","leetcode"],"title":"算法-搜集","uri":"/posts/tech/leetcode/collect/"},{"categories":["leetcode"],"content":"83-简单-删除排序链表中的重复元素 83-简单-删除排序链表中的重复元素 给定一个已排序的链表的头 head ， 删除所有重复的元素，使每个元素只出现一次 。返回 已排序的链表 。 ListNode deleteDuplicates(ListNode head) { if (head == null) return null; ListNode slow = head, fast = head; while (fast != null) { if (fast.val != slow.val) { // nums[slow] = nums[fast]; slow.next = fast; // slow++; slow = slow.next; } // fast++ fast = fast.next; } // 断开与后面重复元素的连接 slow.next = null; return head; } ","date":"2022-09-10","objectID":"/posts/tech/leetcode/collect/:19:0","tags":["综合","leetcode"],"title":"算法-搜集","uri":"/posts/tech/leetcode/collect/"},{"categories":["leetcode"],"content":"86-中等-单链表的分解 86-中等-单链表的分解 给你一个链表的头节点 head 和一个特定值 x ，请你对链表进行分隔，使得所有 小于 x 的节点都出现在 大于或等于 x 的节点之前。 你应当 保留 两个分区中每个节点的初始相对位置。 class Solution { public ListNode partition(ListNode head, int x) { // 存放小于 x 的链表的虚拟头结点 ListNode dump1 = new ListNode(0); // 存放大于等于 x 的链表的虚拟头结点 ListNode dump2 = new ListNode(0); // cur1, cur2 指针负责生成结果链表 ListNode cur1 = dump1; ListNode cur2 = dump2; // 遍历原链表，类似合并两个有序链表的逻辑 // 这里是将一个链表分解成两个链表 while (head != null) { if (head.val \u003c x) { cur1.next = head; cur1 = cur1.next; } else { cur2.next = head; cur2 = cur2.next; } // 断开原链表中的每个节点的 next 指针 ??? 没理解 ！！！ ListNode tmp = head.next; head.next = null; head = tmp; } // 连接两个链表 cur1.next = dump2.next; return dump1.next; } } ","date":"2022-09-10","objectID":"/posts/tech/leetcode/collect/:20:0","tags":["综合","leetcode"],"title":"算法-搜集","uri":"/posts/tech/leetcode/collect/"},{"categories":["leetcode"],"content":"92-中等-反转链表 II 92-中等-反转链表 II 给你单链表的头指针 head 和两个整数 left 和 right ，其中 left \u003c= right 。请你反转从位置 left 到位置 right 的链表节点，返回 反转后的链表 。 1 ","date":"2022-09-10","objectID":"/posts/tech/leetcode/collect/:21:0","tags":["综合","leetcode"],"title":"算法-搜集","uri":"/posts/tech/leetcode/collect/"},{"categories":["leetcode"],"content":"104-简单-二叉树的最大深度 104-简单-二叉树的最大深度 给定一个二叉树，找出其最大深度。 二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。 说明: 叶子节点是指没有子节点的节点。 /** * 递归解法 */ public int maxDepth(TreeNode root) { //当root为0是，则代表tree不存在 if (root == null) { return 0; } // 利用定义，计算左右子树的最大深度 int maxLeft = maxDepth(root.left); int maxRight = maxDepth(root.right); // 整棵树的最大深度等于左右子树的最大深度取最大值， // 然后再加上根节点自己 return Math.max(maxLeft, maxRight) + 1; } ","date":"2022-09-10","objectID":"/posts/tech/leetcode/collect/:22:0","tags":["综合","leetcode"],"title":"算法-搜集","uri":"/posts/tech/leetcode/collect/"},{"categories":["leetcode"],"content":"106-简单-相交链表 106-简单-相交链表 给定一个头结点为 head 的非空单链表，返回链表的中间结点。 如果有两个中间结点，则返回第二个中间结点。 public class Solution { /** * 方法1 ： 双指针 On (a+b) */ public ListNode getIntersectionNode(ListNode headA, ListNode headB) { // p1 指向 A 链表头结点，p2 指向 B 链表头结点 ListNode p1 = headA, p2 = headB; while (p1 != p2) { // p1 走一步，如果走到 A 链表末尾，转到 B 链表 if (p1 == null) { p1 = headB; } else { p1 = p1.next; } // p2 走一步，如果走到 B 链表末尾，转到 A 链表 if (p2 == null) { p2 = headA; } else { p2 = p2.next; } } return p1; } /** * 方法2 哈希 */ public ListNode getIntersectionNode2(ListNode headA, ListNode headB) { Set\u003cListNode\u003e set = new HashSet\u003c\u003e(); ListNode temp = headA; while (temp != null) { set.add(temp); temp = temp.next; } temp = headB; while (temp != null) { if (set.contains(temp)) { return temp; } temp = temp.next; } return null; } } ","date":"2022-09-10","objectID":"/posts/tech/leetcode/collect/:23:0","tags":["综合","leetcode"],"title":"算法-搜集","uri":"/posts/tech/leetcode/collect/"},{"categories":["leetcode"],"content":"114-中等-将二叉树展开为链表 114-中等-将二叉树展开为链表 给你二叉树的根结点 root ，请你将它展开为一个单链表： 展开后的单链表应该同样使用 TreeNode ，其中 right 子指针指向链表中下一个结点，而左子指针始终为 null 。 展开后的单链表应该与二叉树 先序遍历 顺序相同。 class Solution { // 定义：将以 root 为根的树拉平为链表 void flatten(TreeNode root) { // base case if (root == null) return; // 利用定义，把左右子树拉平 flatten(root.left); flatten(root.right); /**** 后序遍历位置 ****/ // 1、左右子树已经被拉平成一条链表 TreeNode left = root.left; TreeNode right = root.right; // 2、将左子树作为右子树 root.left = null; root.right = left; // 3、将原先的右子树接到当前右子树的末端 TreeNode p = root; while (p.right != null) { p = p.right; } p.right = right; } } ","date":"2022-09-10","objectID":"/posts/tech/leetcode/collect/:24:0","tags":["综合","leetcode"],"title":"算法-搜集","uri":"/posts/tech/leetcode/collect/"},{"categories":["leetcode"],"content":"116-中等-填充节点的右侧指针 116-中等-填充节点的右侧指针 给定一个 完美二叉树 ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下： struct Node { int val; Node *left; Node *right; Node *next; } 填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。 初始状态下，所有 next 指针都被设置为 NULL。 来源：力扣（LeetCode） 链接：https://leetcode.cn/problems/populating-next-right-pointers-in-each-node 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 class Solution { /** * 法1：层次遍历 */ public Node connect(Node root) { if (root == null) { return root; } // 初始化队列同时将第一层节点加入队列中，即根节点 Queue\u003cNode\u003e queue = new LinkedList\u003cNode\u003e(); queue.add(root); // 外层的 while 循环迭代的是层数 while (!queue.isEmpty()) { // 记录当前队列大小 int size = queue.size(); // 遍历这一层的所有节点 for (int i = 0; i \u003c size; i++) { // 从队首取出元素 Node node = queue.poll(); // 连接 if (i \u003c size - 1) { node.next = queue.peek(); } // 拓展下一层节点 if (node.left != null) { queue.add(node.left); } if (node.right != null) { queue.add(node.right); } } } // 返回根节点 return root; } /** * 法2：三叉树 解法 * 1. 连接相同父节点的两个子节点 * 2. 连接跨越父节点的两个子节点 */ public Node connect2(Node root) { if (root == null) { return null; } traverse(root.left, root.right); return root; } /** * 三叉树遍历框架 */ public void traverse(Node node1, Node node2) { if (node1 == null || node2 == null) { return; } /**** 前序位置 ****/ // 将传入的两个节点穿起来 node1.next = node2; // 连接相同父节点的两个子节点 traverse(node1.left, node1.right); traverse(node2.left, node2.right); // 连接跨越父节点的两个子节点 traverse(node1.right, node2.left); } } ","date":"2022-09-10","objectID":"/posts/tech/leetcode/collect/:25:0","tags":["综合","leetcode"],"title":"算法-搜集","uri":"/posts/tech/leetcode/collect/"},{"categories":["leetcode"],"content":"125-简单-验证回文串 125-简单-验证回文串 如果在将所有大写字符转换为小写字符、并移除所有非字母数字字符之后，短语正着读和反着读都一样。则可以认为该短语是一个 回文串 。 字母和数字都属于字母数字字符。 给你一个字符串 s，如果它是 回文串 ，返回 true ；否则，返回 false 。 class Solution { /** * 左右双指针 */ public boolean isPalindrome(String s) { int n = s.length(); int left = 0, right = n - 1; while (left \u003c right) { while (left \u003c right \u0026\u0026 !Character.isLetterOrDigit(s.charAt(left))) { ++left; } while (left \u003c right \u0026\u0026 !Character.isLetterOrDigit(s.charAt(right))) { --right; } if (left \u003c right) { if (Character.toLowerCase(s.charAt(left)) != Character.toLowerCase(s.charAt(right))) { return false; } ++left; --right; } } return true; } } ","date":"2022-09-10","objectID":"/posts/tech/leetcode/collect/:26:0","tags":["综合","leetcode"],"title":"算法-搜集","uri":"/posts/tech/leetcode/collect/"},{"categories":["leetcode"],"content":"136-简单-只出现一次的数字 136-简单-只出现一次的数字 给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。 说明： 你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？ class Solution { /** * 使用异或运算，将所有值进行异或 * 异或运算，相异为真，相同为假，所以 a^a = 0 ;0^a = a * 因为异或运算 满足交换律 a^b^a = a^a^b = b 所以数组经过异或运算，单独的值就剩下了 */ public int singleNumber(int[] nums) { int value = 0; for (int num : nums) { //注意异或运算符 value ^= num; } return value; } } ","date":"2022-09-10","objectID":"/posts/tech/leetcode/collect/:27:0","tags":["综合","leetcode"],"title":"算法-搜集","uri":"/posts/tech/leetcode/collect/"},{"categories":["leetcode"],"content":"141-简单-环形链表 141-简单-环形链表 给你一个链表的头节点 head ，判断链表中是否有环。 如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 public class Solution { /** * 法1： 哈希 */ public boolean hasCycle(ListNode head) { Set\u003cListNode\u003e seen = new HashSet\u003cListNode\u003e(); while (head != null) { if (!seen.add(head)) { return true; } head = head.next; } return false; } /** * 法2：双指针 */ public boolean hasCycle2(ListNode head) { if (head == null || head.next == null) { return false; } ListNode slow = head; //注意：此处fast定义 ListNode fast = head.next; //注意：循环条件 while (slow != fast) { //注意：此处判断条件 if (fast == null || fast.next == null) { return false; } slow = slow.next; fast = fast.next.next; } return true; } } ","date":"2022-09-10","objectID":"/posts/tech/leetcode/collect/:28:0","tags":["综合","leetcode"],"title":"算法-搜集","uri":"/posts/tech/leetcode/collect/"},{"categories":["leetcode"],"content":"151-中等-反转字符串中的单词 151-中等-反转字符串中的单词 给你一个字符串 s ，请你反转字符串中 单词 的顺序。 单词 是由非空格字符组成的字符串。s 中使用至少一个空格将字符串中的 单词 分隔开。 返回 单词 顺序颠倒且 单词 之间用单个空格连接的结果字符串。 注意：输入字符串 s中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。 class Solution { /** * 1. 去除多余空格 * 2. 翻转整个字符串 * 3. 逐个按单词再翻转 */ public String reverseWords(String s) { StringBuilder sb = trimSpaces(s); // 翻转字符串 reverse(sb, 0, sb.length() - 1); // 翻转每个单词 reverseEachWord(sb); return sb.toString(); } public StringBuilder trimSpaces(String s) { int left = 0, right = s.length() - 1; // 去掉字符串开头的空白字符，优秀想法 while (s.charAt(left) == ' ') { left++; } // 去掉字符串末尾的空白字符，优秀想法 while (s.charAt(right) == ' ') { right--; } // 将字符串间多余的空白字符去除 StringBuilder sb = new StringBuilder(); while (left \u003c= right) { char c = s.charAt(left); //s.charAt(str.length() - 1) != ' ' 是为了判断 不连续2个空格 if (c != ' ' || sb.charAt(sb.length() - 1) != ' ') { sb.append(c); } //别漏了 left++; } return sb; } public void reverse(StringBuilder sb, int left, int right) { while (left \u003c right) { char tmp = sb.charAt(left); sb.setCharAt(left++, sb.charAt(right)); sb.setCharAt(right--, tmp); } } public void reverseEachWord(StringBuilder sb) { int n = sb.length(); int start = 0, end = 0; while (start \u003c n) { // 循环至单词的末尾 while (end \u003c n \u0026\u0026 sb.charAt(end) != ' ') { ++end; } // 翻转单词 reverse(sb, start, end - 1); // 更新start，去找下一个单词 start = end + 1; ++end; } } } ","date":"2022-09-10","objectID":"/posts/tech/leetcode/collect/:29:0","tags":["综合","leetcode"],"title":"算法-搜集","uri":"/posts/tech/leetcode/collect/"},{"categories":["leetcode"],"content":"155-中等-最小栈 155-中等-最小栈 设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。 实现 MinStack 类: MinStack() 初始化堆栈对象。 void push(int val) 将元素val推入堆栈。 void pop() 删除堆栈顶部的元素。 int top() 获取堆栈顶部的元素。 int getMin() 获取堆栈中的最小元素。 /** * 法1：辅助栈 */ class MinStack { Deque\u003cInteger\u003e xStack; Deque\u003cInteger\u003e minStack; public MinStack() { xStack = new LinkedList\u003cInteger\u003e(); minStack = new LinkedList\u003cInteger\u003e(); minStack.push(Integer.MAX_VALUE); } public void push(int x) { xStack.push(x); //辅助栈，每次都新增数值 minStack.push(Math.min(minStack.peek(), x)); } public void pop() { xStack.pop(); minStack.pop(); } public int top() { return xStack.peek(); } public int getMin() { return minStack.peek(); } } /** * 法2：辅助栈 */ class MinStack { // 记录栈中的所有元素 Stack\u003cInteger\u003e nStack; // 阶段性记录栈中的最小元素 Stack\u003cInteger\u003e mStack; public MinStack() { nStack = new Stack\u003c\u003e(); mStack = new Stack\u003c\u003e(); } public void push(int val) { nStack.push(val); //维护 minStk 栈顶为全栈最小元素 if (mStack.isEmpty() || val \u003c= mStack.peek()) { // 新插入的这个元素就是全栈最小的 mStack.push(val); } } public void pop() { // 比较 Integer 相等 用 equal if (nStack.peek().equals(mStack.peek())) { mStack.pop(); } nStack.pop(); } public int top() { return nStack.peek(); } public int getMin() { // minStk 栈顶为全栈最小元素 return mStack.peek(); } } ","date":"2022-09-10","objectID":"/posts/tech/leetcode/collect/:30:0","tags":["综合","leetcode"],"title":"算法-搜集","uri":"/posts/tech/leetcode/collect/"},{"categories":["leetcode"],"content":"204-中等-计数质数 204-中等-计数质数 给定整数 n ，返回 所有小于非负整数 n 的质数的数量 。 /** * 法1：优化【反向思维】 */ public int countPrimes(int n) { int[] array = new int[n + 2]; for (int i = 2; i \u003c n; ++i) { if (array[i] == 0) { //注意 j += i for (int j = 2 * i; j \u003c n; j += i) { array[j] = 1; } } } int ans = 0; for (int i = 2; i \u003c n; i++) { if (array[i] == 0) { ans++; } } return ans; } /** * 法2：暴力, 超出时间限制 */ public int countPrimes2(int n) { int ans = 0; for (int i = 2; i \u003c n; ++i) { ans += isPrime(i) ? 1 : 0; } return ans; } public boolean isPrime(int x) { for (int i = 2; i * i \u003c= x; ++i) { if (x % i == 0) { return false; } } return true; } ","date":"2022-09-10","objectID":"/posts/tech/leetcode/collect/:31:0","tags":["综合","leetcode"],"title":"算法-搜集","uri":"/posts/tech/leetcode/collect/"},{"categories":["leetcode"],"content":"226-简单-翻转二叉树 226-简单-翻转二叉树 给你一棵二叉树的根节点 root ，翻转这棵二叉树，并返回其根节点。 class Solution { public TreeNode invertTree(TreeNode root) { if(root==null){ return root; } // 1. 利用函数定义，先翻转左右子树 TreeNode leftNode= invertTree(root.left); TreeNode rightNode= invertTree(root.right); // 2. 交换左右子节点 root.left=rightNode; root.right=leftNode; return root; } } ","date":"2022-09-10","objectID":"/posts/tech/leetcode/collect/:32:0","tags":["综合","leetcode"],"title":"算法-搜集","uri":"/posts/tech/leetcode/collect/"},{"categories":["leetcode"],"content":"231-简单-2的幂 231-简单-2的幂 给你一个整数 n，请你判断该整数是否是 2 的幂次方。如果是，返回 true ；否则，返回 false 。 如果存在一个整数 x 使得 n == 2x ，则认为 n 是 2 的幂次方。 class Solution { public boolean isPowerOfTwo(int n) { while (n != 0 \u0026\u0026 n % 2 == 0) { n = n / 2; } return n == 1; } } ","date":"2022-09-10","objectID":"/posts/tech/leetcode/collect/:33:0","tags":["综合","leetcode"],"title":"算法-搜集","uri":"/posts/tech/leetcode/collect/"},{"categories":["leetcode"],"content":"234-简单-回文链表 234-简单-回文链表 给你一个单链表的头节点 head ，请你判断该链表是否为回文链表。如果是，返回 true ；否则，返回 false 。 class Solution { /** * 1. 链表遍历 值存list * 2. 对list 进行左右双指针 回文判断 */ public boolean isPalindrome(ListNode head) { List\u003cInteger\u003e vals =new ArrayList\u003cInteger\u003e(); ListNode dump = head; while(dump!=null){ vals.add(dump.val); //注意此处赋值为 dump.next dump = dump.next; } int left=0, right=vals.size()-1; while(left\u003cright){ if(!vals.get(left).equals(vals.get(right))){ return false; } left++; right--; } return true; } } ","date":"2022-09-10","objectID":"/posts/tech/leetcode/collect/:34:0","tags":["综合","leetcode"],"title":"算法-搜集","uri":"/posts/tech/leetcode/collect/"},{"categories":["leetcode"],"content":"237-中等-删除链表中的节点 237-中等-删除链表中的节点 请编写一个函数，用于 删除单链表中某个特定节点 。在设计函数时需要注意，你无法访问链表的头节点 head ，只能直接访问 要被删除的节点 。 题目数据保证需要删除的节点 不是末尾节点 。 class Solution { public void deleteNode(ListNode node) { node.val = node.next.val; node.next = node.next.next; } } ","date":"2022-09-10","objectID":"/posts/tech/leetcode/collect/:35:0","tags":["综合","leetcode"],"title":"算法-搜集","uri":"/posts/tech/leetcode/collect/"},{"categories":["leetcode"],"content":"238-中等-除自身以外数组的乘积 238-中等-除自身以外数组的乘积 给你一个整数数组 nums，返回 数组 answer ，其中 answer[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积 。 题目数据 保证 数组 nums之中任意元素的全部前缀元素和后缀的乘积都在 32 位 整数范围内。 请不要使用除法，且在 O(n) 时间复杂度内完成此题。 class Solution { public int[] productExceptSelf(int[] nums) { int len = nums.length; // L 和 R 分别表示左右两侧的乘积列表 int[] leftValue = new int[len]; int[] rightValue = new int[len]; int[] result = new int[len]; // L[i] 为索引 i 左侧所有元素的乘积 // 对于索引为 '0' 的元素，因为左侧没有元素，所以 L[0] = 1 leftValue[0] = 1; for (int i = 1; i \u003c len; i++) { leftValue[i] = nums[i-1] * leftValue[i - 1]; } // R[i] 为索引 i 右侧所有元素的乘积 // 对于索引为 'length-1' 的元素，因为右侧没有元素，所以 R[length-1] = 1 rightValue[len-1] = 1; for (int i = len - 2; i \u003e= 0; i--) { rightValue[i] = nums[i + 1] * rightValue[i + 1]; } // 对于索引 i，除 nums[i] 之外其余各元素的乘积就是左侧所有元素的乘积乘以右侧所有元素的乘积 for (int i = 0; i \u003c len; i++) { result[i] = leftValue[i] * rightValue[i]; } return result; } } ","date":"2022-09-10","objectID":"/posts/tech/leetcode/collect/:36:0","tags":["综合","leetcode"],"title":"算法-搜集","uri":"/posts/tech/leetcode/collect/"},{"categories":["leetcode"],"content":"242-简单-有效的字母异位词 242-简单-有效的字母异位词 给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。 注意：若 s 和 t 中每个字符出现的次数都相同，则称 s 和 t 互为字母异位词。 class Solution { /** * 方法1： * 1. 26个英文字母数字长度，每个索引的值进行 先加1，后减1， 当所有均为0时，才相等 * t 是 s 的异位词等价于「两个字符串中字符出现的种类和次数均相等」 */ public boolean isAnagram(String s, String t) { int[] record = new int[26]; for (char c : s.toCharArray()) { record[c - 'a'] += 1; } for (char c : t.toCharArray()) { record[c - 'a'] -= 1; } for (int i : record) { // record数组如果有的元素不为零0，说明字符串s和t 一定是谁多了字符或者谁少了字符。 if (i != 0) { return false; } } // record数组所有元素都为零0，说明字符串s和t是字母异位词 return true; } /** * 方法2： * 1.数组排序 * 2.比较 */ public boolean isAnagram2(String s, String t) { if (s.length() != t.length()) { return false; } char[] str1 = s.toCharArray(); char[] str2 = t.toCharArray(); Arrays.sort(str1); Arrays.sort(str2); return Arrays.equals(str1, str2); } } ","date":"2022-09-10","objectID":"/posts/tech/leetcode/collect/:37:0","tags":["综合","leetcode"],"title":"算法-搜集","uri":"/posts/tech/leetcode/collect/"},{"categories":["leetcode"],"content":"268-简单-丢失的数字 268-简单-丢失的数字 给定一个包含 [0, n] 中 n 个数的数组 nums ，找出 [0, n] 这个范围内没有出现在数组中的那个数。 class Solution { /** * 法1：异或运算，异或运算具有交换律 */ public int missingNumber(int[] nums) { int num=0; // 先和新补的索引异或一下 num^=nums.length; // 和其他的元素、索引做异或 for(int i=0;i\u003cnums.length;i++){ num^=i^nums[i]; } return num; } /** * 法2：等差数列求和，减去所有值 */ public int missingNumber2(int[] nums) { int length = nums.length; int sum = (0 + length) * (length + 1) / 2; for (int i = 0; i \u003c length; i++){ sum -= nums[i]; } return sum; } } ","date":"2022-09-10","objectID":"/posts/tech/leetcode/collect/:38:0","tags":["综合","leetcode"],"title":"算法-搜集","uri":"/posts/tech/leetcode/collect/"},{"categories":["leetcode"],"content":"326-简单-3的幂 326-简单-3的幂 给定一个整数，写一个函数来判断它是否是 3 的幂次方。如果是，返回 true ；否则，返回 false 。 class Solution { /** * 方法1： while循环 */ public boolean isPowerOfThree(int n) { while (n != 0 \u0026\u0026 n % 3 == 0) { n = n / 3; } return n == 1; } /** * 方法二：判断是否为最大 33 的幂的约数 * \u003cp\u003e * 我们还可以使用一种较为取巧的做法。 * 在题目给定的 3232 位有符号整数的范围内，最大的 33 的幂为 3^{19} = 11622614673 * =1162261467。我们只需要判断 nn 是否是 3^{19} 的约数即可。 */ public boolean isPowerOfThree(int n) { return n \u003e 0 \u0026\u0026 1162261467 % n == 0; } /** * 方法3：哈希表 */ static Set\u003cInteger\u003e set = new HashSet\u003c\u003e(); static { int cur = 1; set.add(cur); while (cur \u003c= Integer.MAX_VALUE / 3) { cur *= 3; set.add(cur); } } public boolean isPowerOfThree(int n) { return n \u003e 0 \u0026\u0026 set.contains(n); } } ","date":"2022-09-10","objectID":"/posts/tech/leetcode/collect/:39:0","tags":["综合","leetcode"],"title":"算法-搜集","uri":"/posts/tech/leetcode/collect/"},{"categories":["leetcode"],"content":"342-简单-4的幂 342-简单-4的幂 给定一个整数，写一个函数来判断它是否是 4 的幂次方。如果是，返回 true ；否则，返回 false 。 class Solution { public boolean isPowerOfFour(int n) { while (n != 0 \u0026\u0026 n % 4 == 0) { n = n / 4; } return n == 1; } } ","date":"2022-09-10","objectID":"/posts/tech/leetcode/collect/:40:0","tags":["综合","leetcode"],"title":"算法-搜集","uri":"/posts/tech/leetcode/collect/"},{"categories":["leetcode"],"content":"384-中等-打乱数组 384-中等-打乱数组 给你一个整数数组 nums ，设计算法来打乱一个没有重复元素的数组。打乱后，数组的所有排列应该是 等可能 的。 实现 Solution class: Solution(int[] nums) 使用整数数组 nums 初始化对象 int[] reset() 重设数组到它的初始状态并返回 int[] shuffle() 返回数组随机打乱后的结果 class Solution { int[] array; public Solution(int[] nums) { array=nums; } public int[] reset() { return array; } public int[] shuffle() { //注意 array.clone(); int[] tmp= array.clone(); Random random =new Random(); int len =tmp.length; for(int i=0;i\u003clen;i++){ //i+random.nextInt(len-i); int j= i+random.nextInt(len-i); int t= tmp[j]; tmp[j]=tmp[i]; tmp[i]=t; } return tmp; } } ","date":"2022-09-10","objectID":"/posts/tech/leetcode/collect/:41:0","tags":["综合","leetcode"],"title":"算法-搜集","uri":"/posts/tech/leetcode/collect/"},{"categories":["leetcode"],"content":"387-简单-字符串中的第一个唯一字符 387-简单-字符串中的第一个唯一字符 给定一个字符串 s ，找到 它的第一个不重复的字符，并返回它的索引 。如果不存在，则返回 -1 。 public int firstUniqChar(String s) { Map\u003cCharacter, Integer\u003e frequency = new HashMap\u003cCharacter, Integer\u003e(); for (int i = 0; i \u003c s.length(); ++i) { char ch = s.charAt(i); frequency.put(ch, frequency.getOrDefault(ch, 0) + 1); } for (int i = 0; i \u003c s.length(); ++i) { if (frequency.get(s.charAt(i)) == 1) { return i; } } return -1; } /** * 法2：数组统计，高效 */ public int firstUniqChar(String s) { int[] arr = new int[26]; int n = s.length(); for (int i = 0; i \u003c n; i++) { arr[s.charAt(i)-'a']++ ; } for (int i = 0; i \u003c n; i++) { if (arr[s.charAt(i)-'a'] == 1) { return i; } } return -1; } ","date":"2022-09-10","objectID":"/posts/tech/leetcode/collect/:42:0","tags":["综合","leetcode"],"title":"算法-搜集","uri":"/posts/tech/leetcode/collect/"},{"categories":["leetcode"],"content":"412-简单-Fizz Buzz 412-简单-Fizz Buzz 给你一个整数 n ，找出从 1 到 n 各个整数的 Fizz Buzz 表示，并用字符串数组 answer（下标从 1 开始）返回结果，其中： answer[i] == “FizzBuzz” 如果 i 同时是 3 和 5 的倍数。 answer[i] == “Fizz” 如果 i 是 3 的倍数。 answer[i] == “Buzz” 如果 i 是 5 的倍数。 answer[i] == i （以字符串形式）如果上述条件全不满足。 /** * 法1：优化【反向思维】 */ public int countPrimes(int n) { int[] array = new int[n + 2]; for (int i = 2; i \u003c n; ++i) { if (array[i] == 0) { //注意 j += i for (int j = 2 * i; j \u003c n; j += i) { array[j] = 1; } } } int ans = 0; for (int i = 2; i \u003c n; i++) { if (array[i] == 0) { ans++; } } return ans; } /** * 法2：暴力, 超出时间限制 */ public int countPrimes2(int n) { int ans = 0; for (int i = 2; i \u003c n; ++i) { ans += isPrime(i) ? 1 : 0; } return ans; } public boolean isPrime(int x) { for (int i = 2; i * i \u003c= x; ++i) { if (x % i == 0) { return false; } } return true; } ","date":"2022-09-10","objectID":"/posts/tech/leetcode/collect/:43:0","tags":["综合","leetcode"],"title":"算法-搜集","uri":"/posts/tech/leetcode/collect/"},{"categories":["leetcode"],"content":"543-简单-二叉树的直径 543-简单-二叉树的直径 给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。 class Solution { // 记录最大直径的长度 int max = 0; public int diameterOfBinaryTree(TreeNode root) { maxDepth(root); return max; } public int maxDepth(TreeNode root) { if (root == null) { return 0; } int left = cal(root.left); int right = cal(root.right); // 后序位置，顺便计算最大直径 : left+right max = Math.max(max, left + right); return Math.max(left, right) + 1; } } ","date":"2022-09-10","objectID":"/posts/tech/leetcode/collect/:44:0","tags":["综合","leetcode"],"title":"算法-搜集","uri":"/posts/tech/leetcode/collect/"},{"categories":["leetcode"],"content":"640-中等-求解方程 640-中等-求解方程 求解一个给定的方程，将x以字符串 “x=#value” 的形式返回。该方程仅包含 ‘+’ ， ‘-’ 操作，变量 x 和其对应系数。 如果方程没有解或存在的解不为整数，请返回 “No solution” 。如果方程有无限解，则返回 “Infinite solutions” 。 题目保证，如果方程中只有一个解，则 ‘x’ 的值是一个整数。 class Solution { public String solveEquation(String s) { int x = 0, num = 0, length = s.length(); char[] array = s.toCharArray(); //定义op为操作符，若+号则为1，-号则为-1； for (int i = 0, op = 1; i \u003c length; ) { if (array[i] == '+') { op = 1; i++; } else if (array[i] == '-') { op = -1; i++; } else if (array[i] == '=') { //若为等号开始，马上右边 x *= -1; num *= -1; op = 1; i++; } else { int j = i; while (j \u003c length \u0026\u0026 array[j] != '+' \u0026\u0026 array[j] != '-' \u0026\u0026 array[j] != '=') { j++; } if (array[j - 1] == 'x') { x += (i \u003c j - 1 ? Integer.parseInt(s.substring(i, j - 1)) : 1) * op; } else { num += Integer.parseInt(s.substring(i, j)) * op; } i = j; } } if (x == 0) { return num == 0 ? \"Infinite solutions\" : \"No solution\"; } else { return \"x=\" + (num / -x); } } } ","date":"2022-09-10","objectID":"/posts/tech/leetcode/collect/:45:0","tags":["综合","leetcode"],"title":"算法-搜集","uri":"/posts/tech/leetcode/collect/"},{"categories":["leetcode"],"content":"654-中等-最大二叉树 654-中等-最大二叉树 给定一个不重复的整数数组 nums 。 最大二叉树 可以用下面的算法从 nums 递归地构建: 创建一个根节点，其值为 nums 中的最大值。 递归地在最大值 左边 的 子数组前缀上 构建左子树。 递归地在最大值 右边 的 子数组后缀上 构建右子树。 返回 nums 构建的 最大二叉树 。 class Solution { /** * 递归解法 */ public TreeNode constructMaximumBinaryTree(int[] nums) { return build(nums, 0, nums.length - 1); } TreeNode build(int[] nums, int left, int right) { if (left \u003e right) { return null; } int maxValIndex = left; //注意：i\u003c=right //1. 找出区间最大值索引 for (int i = left; i \u003c= right; i++) { if (nums[i] \u003e nums[maxValIndex]) { maxValIndex = i; } } //2. 节点赋值 TreeNode ans = new TreeNode(nums[maxValIndex]); //3. 左右树递归 ans.left = build(nums, left, maxValIndex - 1); ans.right = build(nums, maxValIndex + 1, right); return ans; } } ","date":"2022-09-10","objectID":"/posts/tech/leetcode/collect/:46:0","tags":["综合","leetcode"],"title":"算法-搜集","uri":"/posts/tech/leetcode/collect/"},{"categories":["leetcode"],"content":"876-简单-单链表的中点 876-简单-单链表的中点 给定一个头结点为 head 的非空单链表，返回链表的中间结点。 如果有两个中间结点，则返回第二个中间结点。 class Solution { ListNode middleNode(ListNode head) { // 快慢指针初始化指向 head ListNode slow = head, fast = head; // 快指针走到末尾时停止 while (fast != null \u0026\u0026 fast.next != null) { // 慢指针走一步，快指针走两步 slow = slow.next; fast = fast.next.next; } // 慢指针指向中点 return slow; } } ","date":"2022-09-10","objectID":"/posts/tech/leetcode/collect/:47:0","tags":["综合","leetcode"],"title":"算法-搜集","uri":"/posts/tech/leetcode/collect/"},{"categories":["leetcode"],"content":"10001-简单-树的前序遍历结果 10001-简单-树的前序遍历结果 输入一棵二叉树的根节点，返回这棵树的前序遍历结果 // 定义：输入一棵二叉树的根节点，返回这棵树的前序遍历结果 List\u003cInteger\u003e preorderTraverse(TreeNode root) { List\u003cInteger\u003e res = new LinkedList\u003c\u003e(); if (root == null) { return res; } // 前序遍历的结果，root.val 在第一个 res.add(root.val); // 利用函数定义，后面接着左子树的前序遍历结果 res.addAll(preorderTraverse(root.left)); // 利用函数定义，最后接着右子树的前序遍历结果 res.addAll(preorderTraverse(root.right)); return res; } ","date":"2022-09-10","objectID":"/posts/tech/leetcode/collect/:48:0","tags":["综合","leetcode"],"title":"算法-搜集","uri":"/posts/tech/leetcode/collect/"},{"categories":["leetcode"],"content":"二叉树 二叉树题型主要是用来培养递归思维的 ","date":"2022-08-21","objectID":"/posts/tech/leetcode/tree/:0:0","tags":["二叉树","leetcode"],"title":"算法-二叉树","uri":"/posts/tech/leetcode/tree/"},{"categories":["leetcode"],"content":"二叉树解题的思维模式分两类： 1、是否可以通过遍历一遍二叉树得到答案？如果可以，用一个 traverse 函数配合外部变量来实现，这叫「遍历」的思维模式。 2、是否可以定义一个递归函数，通过子问题（子树）的答案推导出原问题的答案？如果可以，写出这个递归函数的定义，并充分利用这个函数的返回值，这叫「分解问题」的思维模式。 无论使用哪种思维模式，你都需要思考： 如果单独抽出一个二叉树节点，它需要做什么事情？需要在什么时候（前/中/后序位置）做？其他的节点不用你操心，递归函数会帮你在所有节点上执行相同的操作。 二叉树的构造问题一般都是使用「分解问题」的思路：构造整棵树 = 根节点 + 构造左子树 + 构造右子树。 ","date":"2022-08-21","objectID":"/posts/tech/leetcode/tree/:1:0","tags":["二叉树","leetcode"],"title":"算法-二叉树","uri":"/posts/tech/leetcode/tree/"},{"categories":["leetcode"],"content":"二叉树的重要性 举个例子，比如两个经典排序算法 快速排序 和 归并排序，对于它俩，你有什么理解？ 如果你告诉我，快速排序就是个二叉树的前序遍历，归并排序就是个二叉树的后序遍历，那么我就知道你是个算法高手了。 ","date":"2022-08-21","objectID":"/posts/tech/leetcode/tree/:2:0","tags":["二叉树","leetcode"],"title":"算法-二叉树","uri":"/posts/tech/leetcode/tree/"},{"categories":["leetcode"],"content":"深入理解前中后序 几个问题，请默默思考 30 秒： 1、你理解的二叉树的前中后序遍历是什么，仅仅是三个顺序不同的 List 吗？ 2、请分析，后序遍历有什么特殊之处？ 3、请分析，为什么多叉树没有中序遍历？ 二叉树遍历框架 void traverse(TreeNode root) { if (root == null) { return; } // 前序位置 traverse(root.left); // 中序位置 traverse(root.right); // 后序位置 } 单链表和数组的遍历可以是迭代的，也可以是递归的，二叉树这种结构无非就是二叉链表，由于没办法简单改写成迭代形式，所以一般说二叉树的遍历框架都是指递归的形式。 你也注意到了，只要是递归形式的遍历，都可以有前序位置和后序位置，分别在递归之前和递归之后。 所谓前序位置，就是刚进入一个节点（元素）的时候，后序位置就是即将离开一个节点（元素）的时候，那么进一步，你把代码写在不同位置，代码执行的时机也不同： 比如说，如果让你倒序打印一条单链表上所有节点的值，你怎么搞？ 实现方式当然有很多，但如果你对递归的理解足够透彻，可以利用后序位置来操作： /* 递归遍历单链表，倒序打印链表元素 */ void traverse(ListNode head) { if (head == null) { return; } traverse(head.next); // 后序位置 print(head.val); } 为什么多叉树没有中序位置，因为二叉树的每个节点只会进行唯一一次左子树切换右子树，而多叉树节点可能有很多子节点，会多次切换子树去遍历，所以多叉树节点没有「唯一」的中序遍历位置。 二叉树的所有问题，就是让你在前中后序位置注入巧妙的代码逻辑，去达到自己的目的，你只需要单独思考每一个节点应该做什么，其他的不用你管，抛给二叉树遍历框架，递归会在所有节点上做相同的操作。 ","date":"2022-08-21","objectID":"/posts/tech/leetcode/tree/:3:0","tags":["二叉树","leetcode"],"title":"算法-二叉树","uri":"/posts/tech/leetcode/tree/"},{"categories":["leetcode"],"content":"两种解题思路 二叉树题目的递归解法可以分两类思路，第一类是遍历一遍二叉树得出答案，第二类是通过分解问题计算出答案，这两类思路分别对应着 回溯算法核心框架 和 动态规划核心框架。 一棵二叉树的前序遍历结果 = 根节点 + 左子树的前序遍历结果 + 右子树的前序遍历结果。 题解 ","date":"2022-08-21","objectID":"/posts/tech/leetcode/tree/:4:0","tags":["二叉树","leetcode"],"title":"算法-二叉树","uri":"/posts/tech/leetcode/tree/"},{"categories":["leetcode"],"content":"二叉树的最大深度-E 力扣第 104 题 二叉树的最大深度 给定一个二叉树，找出其最大深度。 二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。 说明: 叶子节点是指没有子节点的节点。 /** * 递归解法 */ public int maxDepth(TreeNode root) { //当root为0是，则代表tree不存在 if (root == null) { return 0; } // 利用定义，计算左右子树的最大深度 int maxLeft = maxDepth(root.left); int maxRight = maxDepth(root.right); // 整棵树的最大深度等于左右子树的最大深度取最大值， // 然后再加上根节点自己 return Math.max(maxLeft, maxRight) + 1; } ","date":"2022-08-21","objectID":"/posts/tech/leetcode/tree/:5:0","tags":["二叉树","leetcode"],"title":"算法-二叉树","uri":"/posts/tech/leetcode/tree/"},{"categories":["leetcode"],"content":"树的前序遍历结果 输入一棵二叉树的根节点，返回这棵树的前序遍历结果 // 定义：输入一棵二叉树的根节点，返回这棵树的前序遍历结果 List\u003cInteger\u003e preorderTraverse(TreeNode root) { List\u003cInteger\u003e res = new LinkedList\u003c\u003e(); if (root == null) { return res; } // 前序遍历的结果，root.val 在第一个 res.add(root.val); // 利用函数定义，后面接着左子树的前序遍历结果 res.addAll(preorderTraverse(root.left)); // 利用函数定义，最后接着右子树的前序遍历结果 res.addAll(preorderTraverse(root.right)); return res; } 中序和后序遍历也是类似的，只要把 add(root.val) 放到中序和后序对应的位置就行了。 这个解法短小精干，但为什么不常见呢？ 一个原因是这个算法的复杂度不好把控，比较依赖语言特性。 Java 的话无论 ArrayList 还是 LinkedList，addAll 方法的复杂度都是 O(N)，所以总体的最坏时间复杂度会达到 O(N^2)，除非你自己实现一个复杂度为 O(1) 的 addAll 方法，底层用链表的话并不是不可能。 当然，最主要的原因还是因为教科书上从来没有这么教过…… 上文举了两个简单的例子，但还有不少二叉树的题目是可以同时使用两种思路来思考和求解的，这就要靠你自己多去练习和思考，不要仅仅满足于一种熟悉的解法思路。 综上，遇到一道二叉树的题目时的通用思考过程是： 1、是否可以通过遍历一遍二叉树得到答案？如果可以，用一个 traverse 函数配合外部变量来实现。 2、是否可以定义一个递归函数，通过子问题（子树）的答案推导出原问题的答案？如果可以，写出这个递归函数的定义，并充分利用这个函数的返回值。 3、无论使用哪一种思维模式，你都要明白二叉树的每一个节点需要做什么，需要在什么时候（前中后序）做。 ","date":"2022-08-21","objectID":"/posts/tech/leetcode/tree/:6:0","tags":["二叉树","leetcode"],"title":"算法-二叉树","uri":"/posts/tech/leetcode/tree/"},{"categories":["leetcode"],"content":"后序位置的特殊之处 前序位置的代码执行是自顶向下的，而后序位置的代码执行是自底向上的： 前序位置的代码只能从函数参数中获取父节点传递来的数据，而后序位置的代码不仅可以获取参数数据，还可以获取到子树通过函数返回值传递回来的数据。 举具体的例子，现在给你一棵二叉树，两个简单的问题： 1、如果把根节点看做第 1 层，如何打印出每一个节点所在的层数？ 2、如何打印出每个节点的左右子树各有多少节点？ 第一个问题可以这样写代码： // 二叉树遍历函数 void traverse(TreeNode root, int level) { if (root == null) { return; } // 前序位置 printf(\"节点 %s 在第 %d 层\", root, level); traverse(root.left, level + 1); traverse(root.right, level + 1); } // 这样调用 traverse(root, 1); 第二个问题可以这样写代码： // 定义：输入一棵二叉树，返回这棵二叉树的节点总数 int count(TreeNode root) { if (root == null) { return 0; } int leftCount = count(root.left); int rightCount = count(root.right); // 后序位置 printf(\"节点 %s 的左子树有 %d 个节点，右子树有 %d 个节点\", root, leftCount, rightCount); return leftCount + rightCount + 1; } 这两个问题的根本区别在于： 一个节点在第几层，你从根节点遍历过来的过程就能顺带记录； 而以一个节点为根的整棵子树有多少个节点，你需要遍历完子树之后才能数清楚。 结合这两个简单的问题，你品味一下后序位置的特点，只有后序位置才能通过返回值获取子树的信息。 那么换句话说，一旦你发现题目和子树有关，那大概率要给函数设置合理的定义和返回值，在后序位置写代码了。 ","date":"2022-08-21","objectID":"/posts/tech/leetcode/tree/:7:0","tags":["二叉树","leetcode"],"title":"算法-二叉树","uri":"/posts/tech/leetcode/tree/"},{"categories":["leetcode"],"content":"二叉树的直径-E 力扣第 543 题 二叉树的直径 ，让你计算一棵二叉树的最长直径长度。 所谓二叉树的「直径」长度，就是任意两个结点之间的路径长度。最长「直径」并不一定要穿过根结点，比如下面这棵二叉树 解决这题的关键在于，每一条二叉树的「直径」长度，就是一个节点的左右子树的最大深度之和。 class Solution { // 记录最大直径的长度 int max = 0; public int diameterOfBinaryTree(TreeNode root) { maxDepth(root); return max; } public int maxDepth(TreeNode root) { if (root == null) { return 0; } int left = cal(root.left); int right = cal(root.right); // 后序位置，顺便计算最大直径 : left+right max = Math.max(max, left + right); return Math.max(left, right) + 1; } } ","date":"2022-08-21","objectID":"/posts/tech/leetcode/tree/:8:0","tags":["二叉树","leetcode"],"title":"算法-二叉树","uri":"/posts/tech/leetcode/tree/"},{"categories":["leetcode"],"content":"层序遍历 二叉树题型主要是用来培养递归思维的，而层序遍历属于迭代遍历，也比较简单，这里就过一下代码框架吧： // 输入一棵二叉树的根节点，层序遍历这棵二叉树 void levelTraverse(TreeNode root) { if (root == null) return; Queue\u003cTreeNode\u003e q = new LinkedList\u003c\u003e(); q.offer(root); // 从上到下遍历二叉树的每一层 while (!q.isEmpty()) { int sz = q.size(); // 从左到右遍历每一层的每个节点 for (int i = 0; i \u003c sz; i++) { TreeNode cur = q.poll(); // 将下一层节点放入队列 if (cur.left != null) { q.offer(cur.left); } if (cur.right != null) { q.offer(cur.right); } } } } 这里面 while 循环和 for 循环分管从上到下和从左到右的遍历. ","date":"2022-08-21","objectID":"/posts/tech/leetcode/tree/:9:0","tags":["二叉树","leetcode"],"title":"算法-二叉树","uri":"/posts/tech/leetcode/tree/"},{"categories":["leetcode"],"content":"翻转二叉树-E 力扣第 226 题 翻转二叉树 给你一棵二叉树的根节点 root ，翻转这棵二叉树，并返回其根节点。 class Solution { public TreeNode invertTree(TreeNode root) { if(root==null){ return root; } // 1. 利用函数定义，先翻转左右子树 TreeNode leftNode= invertTree(root.left); TreeNode rightNode= invertTree(root.right); // 2. 交换左右子节点 root.left=rightNode; root.right=leftNode; return root; } } ","date":"2022-08-21","objectID":"/posts/tech/leetcode/tree/:10:0","tags":["二叉树","leetcode"],"title":"算法-二叉树","uri":"/posts/tech/leetcode/tree/"},{"categories":["leetcode"],"content":"填充节点的右侧指针-M 力扣第 116 题 填充每个二叉树节点的右侧指针 ，看下题目： class Solution { /** * 法1：层次遍历 */ public Node connect(Node root) { if (root == null) { return root; } // 初始化队列同时将第一层节点加入队列中，即根节点 Queue\u003cNode\u003e queue = new LinkedList\u003cNode\u003e(); queue.add(root); // 外层的 while 循环迭代的是层数 while (!queue.isEmpty()) { // 记录当前队列大小 int size = queue.size(); // 遍历这一层的所有节点 for (int i = 0; i \u003c size; i++) { // 从队首取出元素 Node node = queue.poll(); // 连接 if (i \u003c size - 1) { node.next = queue.peek(); } // 拓展下一层节点 if (node.left != null) { queue.add(node.left); } if (node.right != null) { queue.add(node.right); } } } // 返回根节点 return root; } /** * 法2：三叉树 解法 * 1. 连接相同父节点的两个子节点 * 2. 连接跨越父节点的两个子节点 */ public Node connect2(Node root) { if (root == null) { return null; } traverse(root.left, root.right); return root; } /** * 三叉树遍历框架 */ public void traverse(Node node1, Node node2) { if (node1 == null || node2 == null) { return; } /**** 前序位置 ****/ // 将传入的两个节点穿起来 node1.next = node2; // 连接相同父节点的两个子节点 traverse(node1.left, node1.right); traverse(node2.left, node2.right); // 连接跨越父节点的两个子节点 traverse(node1.right, node2.left); } } ","date":"2022-08-21","objectID":"/posts/tech/leetcode/tree/:11:0","tags":["二叉树","leetcode"],"title":"算法-二叉树","uri":"/posts/tech/leetcode/tree/"},{"categories":["leetcode"],"content":"将二叉树展开为链表 【不懂】 力扣第 114 题 将二叉树展开为链表 ，看下题目 给你二叉树的根结点 root ，请你将它展开为一个单链表： class Solution { // 定义：将以 root 为根的树拉平为链表 void flatten(TreeNode root) { // base case if (root == null) return; // 利用定义，把左右子树拉平 flatten(root.left); flatten(root.right); /**** 后序遍历位置 ****/ // 1、左右子树已经被拉平成一条链表 TreeNode left = root.left; TreeNode right = root.right; // 2、将左子树作为右子树 root.left = null; root.right = left; // 3、将原先的右子树接到当前右子树的末端 TreeNode p = root; while (p.right != null) { p = p.right; } p.right = right; } } ","date":"2022-08-21","objectID":"/posts/tech/leetcode/tree/:12:0","tags":["二叉树","leetcode"],"title":"算法-二叉树","uri":"/posts/tech/leetcode/tree/"},{"categories":["leetcode"],"content":"最大二叉树-M[复习] 力扣第 654 题 最大二叉树 ，看下题目 给定一个不重复的整数数组nums 。最大二叉树可以用下面的算法从nums 递归地构建: 创建一个根节点，其值为nums 中的最大值。 递归地在最大值左边的子数组前缀上构建左子树。 递归地在最大值 右边 的子数组后缀上构建右子树。 返回nums 构建的 最大二叉树。 class Solution { /** * 递归解法 */ public TreeNode constructMaximumBinaryTree(int[] nums) { return build(nums, 0, nums.length - 1); } TreeNode build(int[] nums, int left, int right) { if (left \u003e right) { return null; } int maxValIndex = left; //注意：i\u003c=right //1. 找出区间最大值索引 for (int i = left; i \u003c= right; i++) { if (nums[i] \u003e nums[maxValIndex]) { maxValIndex = i; } } //2. 节点赋值 TreeNode ans = new TreeNode(nums[maxValIndex]); //3. 左右树递归 ans.left = build(nums, left, maxValIndex - 1); ans.right = build(nums, maxValIndex + 1, right); return ans; } } ","date":"2022-08-21","objectID":"/posts/tech/leetcode/tree/:13:0","tags":["二叉树","leetcode"],"title":"算法-二叉树","uri":"/posts/tech/leetcode/tree/"},{"categories":["leetcode"],"content":"从前序与中序遍历序列构造二叉树-M【不理解】 力扣第 105 题 从前序与中序遍历序列构造二叉树 ，看下题目 给定两个整数数组preorder 和 inorder，其中preorder 是二叉树的先序遍历， inorder是同一棵树的中序遍历，请构造二叉树并返回其根节点。 ","date":"2022-08-21","objectID":"/posts/tech/leetcode/tree/:14:0","tags":["二叉树","leetcode"],"title":"算法-二叉树","uri":"/posts/tech/leetcode/tree/"},{"categories":["leetcode"],"content":"通过后序和中序遍历结果构造二叉树-M [不理解] 类似上一题，这次我们利用后序和中序遍历的结果数组来还原二叉树，这是力扣第 106 题 从后序和中序遍历序列构造二叉树 ","date":"2022-08-21","objectID":"/posts/tech/leetcode/tree/:15:0","tags":["二叉树","leetcode"],"title":"算法-二叉树","uri":"/posts/tech/leetcode/tree/"},{"categories":["leetcode"],"content":"根据前序和后序遍历构造二叉树-M[不理解] 这是力扣第 889 题 根据前序和后序遍历构造二叉树 ，给你输入二叉树的前序和后序遍历结果，让你还原二叉树的结构。 通过前序中序，或者后序中序遍历结果可以确定唯一一棵原始二叉树，但是通过前序后序遍历结果无法确定唯一的原始二叉树。 ","date":"2022-08-21","objectID":"/posts/tech/leetcode/tree/:16:0","tags":["二叉树","leetcode"],"title":"算法-二叉树","uri":"/posts/tech/leetcode/tree/"},{"categories":["leetcode"],"content":"寻找重复的子树 力扣第 652 题 寻找重复的子树 给定一棵二叉树 root，返回所有重复的子树。 对于同一类的重复子树，你只需要返回其中任意一棵的根结点即可。 如果两棵树具有相同的结构和相同的结点值，则它们是重复的。 ","date":"2022-08-21","objectID":"/posts/tech/leetcode/tree/:17:0","tags":["二叉树","leetcode"],"title":"算法-二叉树","uri":"/posts/tech/leetcode/tree/"},{"categories":["leetcode"],"content":"链表 链表分带头结点的链表 和 不带头结点的链表； 所有的链表都有一个头指针head，带头结点的链表中head的数据项为空，而不带头的链表直接在头结点存入数据，那么当从头插入数据时，head需要时刻变化。 带头结点的单链表的的头结点一般数据域不存元素，指针域指向第一个结点，头指针（假设为pHead）指向头结点; 不带头结点的单链表，头指针指向单链表的第一个结点; 如果把链表中的结点进行编号，带头结点的链表的头结点可以理解为是其第0个结点，头指针pHead指向头结点即第0个结点，不带头结点的指针指向第1个结点。 ","date":"2022-08-21","objectID":"/posts/tech/leetcode/listnode/:0:0","tags":["链表","leetcode"],"title":"算法-链表","uri":"/posts/tech/leetcode/listnode/"},{"categories":["leetcode"],"content":"双指针技巧 ","date":"2022-08-21","objectID":"/posts/tech/leetcode/listnode/:1:0","tags":["链表","leetcode"],"title":"算法-链表","uri":"/posts/tech/leetcode/listnode/"},{"categories":["leetcode"],"content":"删除排序链表中的重复元素 力扣第 83 题「 删除排序链表中的重复元素」 给定一个已排序的链表的头 head ， 删除所有重复的元素，使每个元素只出现一次 。返回 已排序的链表 。 ListNode deleteDuplicates(ListNode head) { if (head == null) return null; ListNode slow = head, fast = head; while (fast != null) { if (fast.val != slow.val) { // nums[slow] = nums[fast]; slow.next = fast; // slow++; slow = slow.next; } // fast++ fast = fast.next; } // 断开与后面重复元素的连接 slow.next = null; return head; } ","date":"2022-08-21","objectID":"/posts/tech/leetcode/listnode/:1:1","tags":["链表","leetcode"],"title":"算法-链表","uri":"/posts/tech/leetcode/listnode/"},{"categories":["leetcode"],"content":"合并两个有序链表 这是最基本的链表技巧，力扣第 21 题 「 合并两个有序链表」 class Solution { /** * 法1- 迭代 * 参见讲解 * https://www.bilibili.com/video/BV1pZ4y1Y76v?spm_id_from=333.337.search-card.all.click */ public ListNode mergeTwoLists(ListNode list1, ListNode list2) { //定义新链表作为结果链表，首节点为哑结点，虚拟头结点 ListNode dump = new ListNode(0); //定义新链表的当前节点，也可以理解为尾部节点，作为指针参与和其他数值做比较运算 ListNode cur = dump; while (list1 != null \u0026\u0026 list2 != null) { // 比较 list1 和 list2 两个指针 // 将值较小的的节点接到 cur 指针 if (list2.val \u003e list1.val) { cur.next = list1; list1 = list1.next; } else { cur.next = list2; list2 = list2.next; } // cur 指针不断前进 cur = cur.next; } cur.next = (list1 == null) ? list2 : list1; return dump.next; } } /** * 法2- 递归调用 */ public ListNode mergeTwoLists(ListNode l1, ListNode l2) { if (l1 == null) { return l2; } else if (l2 == null) { return l1; } else if (l1.val \u003c l2.val) { l1.next = mergeTwoLists(l1.next, l2); return l1; } else { l2.next = mergeTwoLists(l1, l2.next); return l2; } } ","date":"2022-08-21","objectID":"/posts/tech/leetcode/listnode/:1:2","tags":["链表","leetcode"],"title":"算法-链表","uri":"/posts/tech/leetcode/listnode/"},{"categories":["leetcode"],"content":"单链表的分解 直接看下力扣第 86 题「 分隔链表」： class Solution { public ListNode partition(ListNode head, int x) { // 存放小于 x 的链表的虚拟头结点 ListNode dump1 = new ListNode(0); // 存放大于等于 x 的链表的虚拟头结点 ListNode dump2 = new ListNode(0); // cur1, cur2 指针负责生成结果链表 ListNode cur1 = dump1; ListNode cur2 = dump2; // 遍历原链表，类似合并两个有序链表的逻辑 // 这里是将一个链表分解成两个链表 while (head != null) { if (head.val \u003c x) { cur1.next = head; cur1 = cur1.next; } else { cur2.next = head; cur2 = cur2.next; } // 断开原链表中的每个节点的 next 指针 ??? 没理解 ！！！ ListNode tmp = head.next; head.next = null; head = tmp; } // 连接两个链表 cur1.next = dump2.next; return dump1.next; } } ","date":"2022-08-21","objectID":"/posts/tech/leetcode/listnode/:1:3","tags":["链表","leetcode"],"title":"算法-链表","uri":"/posts/tech/leetcode/listnode/"},{"categories":["leetcode"],"content":"合并 k 个有序链表 看下力扣第 23 题「 合并K个升序链表」 class Solution { /** * 法1: 使用优先队列合并 */ public ListNode mergeKLists(ListNode[] lists) { if (lists.length == 0) { return null; } //使用排序队列 PriorityQueue\u003cListNode\u003e pq = new PriorityQueue\u003c\u003e(lists.length, (a, b) -\u003e a.val - b.val); for (int i = 0; i \u003c lists.length; i++) { if (lists[i] != null) { pq.add(lists[i]); } } ListNode dump = new ListNode(0); ListNode cur = dump; while (!pq.isEmpty()) { ListNode node = pq.poll(); cur.next = node; cur = cur.next; if (node.next != null) { pq.add(node.next); } } return dump.next; } /** * 法2: 顺序合并 */ public ListNode mergeKLists(ListNode[] lists) { if (lists.length == 0) { return null; } ListNode ans = null; for (int i = 0; i \u003c lists.length; i++) { // mergeTwoLists 参照合并两个有序链表的解法 ans = mergeTwoLists(ans, lists[i]); } return ans; } } ","date":"2022-08-21","objectID":"/posts/tech/leetcode/listnode/:1:4","tags":["链表","leetcode"],"title":"算法-链表","uri":"/posts/tech/leetcode/listnode/"},{"categories":["leetcode"],"content":"（删除）单链表的倒数第 k 个节点 力扣第 19 题 删除链表的倒数第 N 个结点 给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。 进阶：你能尝试使用一趟扫描实现吗？ 从前往后寻找单链表的第 k 个节点很简单，一个 for 循环遍历过去就找到了，但是如何寻找从后往前数的第 k 个节点呢？ 那你可能说，假设链表有 n 个节点，倒数第 k 个节点就是正数第 n - k + 1 个节点，不也是一个 for 循环的事儿吗？ 是的，但是算法题一般只给你一个 ListNode 头结点代表一条单链表，你不能直接得出这条链表的长度 n，而需要先遍历一遍链表算出 n 的值，然后再遍历链表计算第 n - k + 1 个节点。 也就是说，这个解法需要遍历两次链表才能得到出倒数第 k 个节点。 那么，我们能不能只遍历一次链表，就算出倒数第 k 个节点？可以做到的，如果是面试问到这道题，面试官肯定也是希望你给出只需遍历一次链表的解法。 这个解法就比较巧妙了，假设 k = 2，思路如下： 首先，我们先让一个指针 p1 指向链表的头节点 head，然后走 k 步： 现在的 p1，只要再走 n - k 步，就能走到链表末尾的空指针了对吧？ 趁这个时候，再用一个指针 p2 指向链表头节点 head： 接下来就很显然了，让 p1 和 p2 同时向前走，p1 走到链表末尾的空指针时前进了 n - k 步，p2 也从 head 开始前进了 n - k 步，停留在第 n - k + 1 个节点上，即恰好停链表的倒数第 k 个节点上： 详细解释 refer to class Solution { /** * 法1：双指针，单次链表遍历 */ public ListNode removeNthFromEnd(ListNode head, int n) { // 虚拟头结点 ListNode dump = new ListNode(0); //注意此处 dump.next = head; // 删除倒数第 n 个，先找倒数第 n + 1 个节点 [注意此处 为n+1] ListNode objNode = findFromEnd(dump, n + 1); // 删掉倒数第 n 个节点 objNode.next = objNode.next.next; return dump.next; } // 返回链表的倒数第 n 个节点 public ListNode findFromEnd(ListNode head, int n) { ListNode p1 = head; // p1 先走 n 步 for (int i = 0; i \u003c n; i++) { p1 = p1.next; } ListNode p2 = head; // p1 和 p2 同时走 len - k 步 while (p1 != null) { p1 = p1.next; p2 = p2.next; } // p2 现在指向第 len - n + 1 个节点，即倒数第 n 个节点 return p2; } /** * 法2：2次链表遍历； 先循环查询链表总长度，在走到特定节点，操作； */ public ListNode removeNthFromEnd2(ListNode head, int n) { ListNode dummy = new ListNode(0, head); int length = getLength(head); ListNode cur = dummy; for (int i = 1; i \u003c length - n + 1; ++i) { cur = cur.next; } cur.next = cur.next.next; //注意：此处return不能是cur.next，原因？ return dummy.next; // ListNode ans = dummy.next; // return ans; } public int getLength(ListNode head) { int length = 0; while (head != null) { ++length; head = head.next; } return length; } } ","date":"2022-08-21","objectID":"/posts/tech/leetcode/listnode/:1:5","tags":["链表","leetcode"],"title":"算法-链表","uri":"/posts/tech/leetcode/listnode/"},{"categories":["leetcode"],"content":"单链表的中点 [错题] 力扣第 876 题「 链表的中间结点」 问题的关键也在于我们无法直接得到单链表的长度 n，常规方法也是先遍历链表计算 n，再遍历一次得到第 n / 2 个节点，也就是中间节点。 如果想一次遍历就得到中间节点，也需要耍点小聪明，使用「快慢指针」的技巧： 我们让两个指针 slow 和 fast 分别指向链表头结点 head。 每当慢指针 slow 前进一步，快指针 fast 就前进两步，这样，当 fast 走到链表末尾时，slow 就指向了链表中点。 class Solution { ListNode middleNode(ListNode head) { // 快慢指针初始化指向 head ListNode slow = head, fast = head; // 快指针走到末尾时停止 while (fast != null \u0026\u0026 fast.next != null) { // 慢指针走一步，快指针走两步 slow = slow.next; fast = fast.next.next; } // 慢指针指向中点 return slow; } } 需要注意的是，如果链表长度为偶数，也就是说中点有两个的时候，我们这个解法返回的节点是靠后的那个节点。 另外，这段代码稍加修改就可以直接用到判断链表成环的算法题上。 ","date":"2022-08-21","objectID":"/posts/tech/leetcode/listnode/:1:6","tags":["链表","leetcode"],"title":"算法-链表","uri":"/posts/tech/leetcode/listnode/"},{"categories":["leetcode"],"content":"判断链表是否包含环 boolean hasCycle(ListNode head) { // 快慢指针初始化指向 head ListNode slow = head, fast = head; // 快指针走到末尾时停止 while (fast != null \u0026\u0026 fast.next != null) { // 慢指针走一步，快指针走两步 slow = slow.next; fast = fast.next.next; // 快慢指针相遇，说明含有环 if (slow == fast) { return true; } } // 不包含环 return false; } 当然，这个问题还有进阶版：如果链表中含有环，如何计算这个环的起点？ ","date":"2022-08-21","objectID":"/posts/tech/leetcode/listnode/:1:7","tags":["链表","leetcode"],"title":"算法-链表","uri":"/posts/tech/leetcode/listnode/"},{"categories":["leetcode"],"content":"链表包含环的起点 ListNode detectCycle(ListNode head) { ListNode fast, slow; fast = slow = head; while (fast != null \u0026\u0026 fast.next != null) { fast = fast.next.next; slow = slow.next; if (fast == slow) break; } // 上面的代码类似 hasCycle 函数 if (fast == null || fast.next == null) { // fast 遇到空指针说明没有环 return null; } // 重新指向头结点 slow = head; // 快慢指针同步前进，相交点就是环起点 while (slow != fast) { fast = fast.next; slow = slow.next; } return slow; } 可以看到，当快慢指针相遇时，让其中任一个指针指向头节点，然后让它俩以相同速度前进，再次相遇时所在的节点位置就是环开始的位置。 为什么要这样呢？这里简单说一下其中的原理。 我们假设快慢指针相遇时，慢指针 slow 走了 k 步，那么快指针 fast 一定走了 2k 步： ","date":"2022-08-21","objectID":"/posts/tech/leetcode/listnode/:1:8","tags":["链表","leetcode"],"title":"算法-链表","uri":"/posts/tech/leetcode/listnode/"},{"categories":["leetcode"],"content":"两个链表是否相交 力扣第 160 题「 相交链表」 public class Solution { /** * 方法1 ： 双指针 On (a+b) */ public ListNode getIntersectionNode(ListNode headA, ListNode headB) { // p1 指向 A 链表头结点，p2 指向 B 链表头结点 ListNode p1 = headA, p2 = headB; while (p1 != p2) { // p1 走一步，如果走到 A 链表末尾，转到 B 链表 if (p1 == null) { p1 = headB; } else { p1 = p1.next; } // p2 走一步，如果走到 B 链表末尾，转到 A 链表 if (p2 == null) { p2 = headA; } else { p2 = p2.next; } } return p1; } /** * 方法2 哈希 */ public ListNode getIntersectionNode2(ListNode headA, ListNode headB) { Set\u003cListNode\u003e set = new HashSet\u003c\u003e(); ListNode temp = headA; while (temp != null) { set.add(temp); temp = temp.next; } temp = headB; while (temp != null) { if (set.contains(temp)) { return temp; } temp = temp.next; } return null; } } ","date":"2022-08-21","objectID":"/posts/tech/leetcode/listnode/:1:9","tags":["链表","leetcode"],"title":"算法-链表","uri":"/posts/tech/leetcode/listnode/"},{"categories":["leetcode"],"content":"回文链表-E 力扣第 234 题回文链表 给你一个单链表的头节点 head ，请你判断该链表是否为回文链表。如果是，返回 true ；否则，返回 false 。 class Solution { /** * 1. 链表遍历 值存list * 2. 对list 进行左右双指针 回文判断 */ public boolean isPalindrome(ListNode head) { List\u003cInteger\u003e vals =new ArrayList\u003cInteger\u003e(); ListNode dump = head; while(dump!=null){ vals.add(dump.val); //注意此处赋值为 dump.next dump = dump.next; } int left=0, right=vals.size()-1; while(left\u003cright){ if(!vals.get(left).equals(vals.get(right))){ return false; } left++; right--; } return true; } } ","date":"2022-08-21","objectID":"/posts/tech/leetcode/listnode/:1:10","tags":["链表","leetcode"],"title":"算法-链表","uri":"/posts/tech/leetcode/listnode/"},{"categories":["leetcode"],"content":"环形链表-E 力扣第 141 题环形链表 给你一个链表的头节点 head ，判断链表中是否有环。 如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 public class Solution { /** * 法1： 哈希 */ public boolean hasCycle(ListNode head) { Set\u003cListNode\u003e seen = new HashSet\u003cListNode\u003e(); while (head != null) { if (!seen.add(head)) { return true; } head = head.next; } return false; } /** * 法2：双指针 */ public boolean hasCycle2(ListNode head) { if (head == null || head.next == null) { return false; } ListNode slow = head; //注意：此处fast定义 ListNode fast = head.next; //注意：循环条件 while (slow != fast) { //注意：此处判断条件 if (fast == null || fast.next == null) { return false; } slow = slow.next; fast = fast.next.next; } return true; } } ","date":"2022-08-21","objectID":"/posts/tech/leetcode/listnode/:1:11","tags":["链表","leetcode"],"title":"算法-链表","uri":"/posts/tech/leetcode/listnode/"},{"categories":["leetcode"],"content":"递归魔法：反转单链表 什么叫反转单链表的一部分呢，就是给你一个索引区间，让你把单链表中这部分元素反转，其他部分不变。 看下力扣第 92 题「 反转链表 II」： ","date":"2022-08-21","objectID":"/posts/tech/leetcode/listnode/:2:0","tags":["链表","leetcode"],"title":"算法-链表","uri":"/posts/tech/leetcode/listnode/"},{"categories":["leetcode"],"content":"递归反转整个链表 【太绕，没理解！！】 这也是力扣第 206 题「 反转链表」 可以使用递归的3个条件： 大问题拆成2个子问题。 子问题求解方式和大问题一样。 存在最小子问题。 class Solution { /** * 方法1： 迭代反转 * 单链表反转视频讲解： https://leetcode.cn/problems/reverse-linked-list/solution/shi-pin-jiang-jie-die-dai-he-di-gui-hen-hswxy/ */ public ListNode reverseList(ListNode head) { ListNode prev = null; ListNode curr = head; while (curr != null) { //next 为临时变量，做数据临时存储 ListNode next = curr.next; curr.next = prev; prev = curr; curr = next; } return prev; } /** * 方法2：递归反转 * 视频讲解 https://leetcode.cn/problems/reverse-linked-list/solution/shi-pin-jiang-jie-die-dai-he-di-gui-hen-hswxy/ */ public ListNode reverseList2(ListNode head) { if (head == null || head.next == null) { return head; } ListNode last = reverseList2(head.next); head.next.next = head; head.next = null; return last; } } ","date":"2022-08-21","objectID":"/posts/tech/leetcode/listnode/:2:1","tags":["链表","leetcode"],"title":"算法-链表","uri":"/posts/tech/leetcode/listnode/"},{"categories":["leetcode"],"content":"反转链表前 N 个节点【没看懂！！】 解决思路和反转整个链表差不多，只要稍加修改即可： ListNode successor = null; // 后驱节点 // 反转以 head 为起点的 n 个节点，返回新的头结点 ListNode reverseN(ListNode head, int n) { if (n == 1) { // 记录第 n + 1 个节点 successor = head.next; return head; } // 以 head.next 为起点，需要反转前 n - 1 个节点 ListNode last = reverseN(head.next, n - 1); head.next.next = head; // 让反转之后的 head 节点和后面的节点连起来 head.next = successor; return last; } ","date":"2022-08-21","objectID":"/posts/tech/leetcode/listnode/:2:2","tags":["链表","leetcode"],"title":"算法-链表","uri":"/posts/tech/leetcode/listnode/"},{"categories":["leetcode"],"content":"反转链表的一部分 refer to ","date":"2022-08-21","objectID":"/posts/tech/leetcode/listnode/:2:3","tags":["链表","leetcode"],"title":"算法-链表","uri":"/posts/tech/leetcode/listnode/"},{"categories":["leetcode"],"content":"总结 递归的思想相对迭代思想，稍微有点难以理解，处理的技巧是：不要跳进递归，而是利用明确的定义来实现算法逻辑。 处理看起来比较困难的问题，可以尝试化整为零，把一些简单的解法进行修改，解决困难的问题。 值得一提的是，递归操作链表并不高效。和迭代解法相比，虽然时间复杂度都是 O(N)，但是迭代解法的空间复杂度是 O(1)，而递归解法需要堆栈，空间复杂度是 O(N)。 所以递归操作链表可以作为对递归算法的练习或者拿去和小伙伴装逼，但是考虑效率的话还是使用迭代算法更好。 ","date":"2022-08-21","objectID":"/posts/tech/leetcode/listnode/:3:0","tags":["链表","leetcode"],"title":"算法-链表","uri":"/posts/tech/leetcode/listnode/"},{"categories":["leetcode"],"content":"K 个一组翻转链表 力扣第 25 题「 K 个一组翻转链表」 refet to 其他 ","date":"2022-08-21","objectID":"/posts/tech/leetcode/listnode/:4:0","tags":["链表","leetcode"],"title":"算法-链表","uri":"/posts/tech/leetcode/listnode/"},{"categories":["leetcode"],"content":"删除链表中的节点 力扣第 237 题删除链表中的节点 请编写一个函数，用于 删除单链表中某个特定节点 。在设计函数时需要注意，你无法访问链表的头节点 head ，只能直接访问 要被删除的节点 。 题目数据保证需要删除的节点 不是末尾节点 。 class Solution { public void deleteNode(ListNode node) { node.val = node.next.val; node.next = node.next.next; } } ","date":"2022-08-21","objectID":"/posts/tech/leetcode/listnode/:5:0","tags":["链表","leetcode"],"title":"算法-链表","uri":"/posts/tech/leetcode/listnode/"},{"categories":["leetcode"],"content":"数组/单链表系列算法 单链表常考的技巧就是双指针 比如判断单链表是否成环，拍脑袋的暴力解是什么？就是用一个 HashSet 之类的数据结构来缓存走过的节点，遇到重复的就说明有环对吧。但我们用快慢指针可以避免使用额外的空间，这就是聪明地穷举嘛。 当然，对于找链表中点这种问题，使用双指针技巧只是显示你学过这个技巧，和遍历两次链表的常规解法从时间空间复杂度的角度来说都是差不多的。 数组常用的技巧有很大一部分还是双指针相关的技巧，说白了是教你如何聪明地进行穷举。 首先说二分搜索技巧，可以归为两端向中心的双指针。如果让你在数组中搜索元素，一个 for 循环穷举肯定能搞定对吧，但如果数组是有序的，二分搜索不就是一种更聪明的搜索方式么。 数组算法 双指针技巧 在处理数组和链表相关问题时，双指针技巧是经常用到的，双指针技巧主要分为两类：左右指针和快慢指针。 所谓左右指针，就是两个指针相向而行或者相背而行；而所谓快慢指针，就是两个指针同向而行，一快一慢。 ","date":"2022-08-19","objectID":"/posts/tech/leetcode/array/:0:0","tags":["数组","leetcode"],"title":"算法-数组","uri":"/posts/tech/leetcode/array/"},{"categories":["leetcode"],"content":"一、快慢指针技巧 数组问题中比较常见的快慢指针技巧，是让你原地修改数组。 ","date":"2022-08-19","objectID":"/posts/tech/leetcode/array/:1:0","tags":["数组","leetcode"],"title":"算法-数组","uri":"/posts/tech/leetcode/array/"},{"categories":["leetcode"],"content":"删除有序数组中的重复项 第 26 题「 删除有序数组中的重复项」 class Solution { public int removeDuplicates(int[] nums) { int len = nums.length; if (len == 0) { return 0; } //此处slow 代表新数组的长度，至少是1起 int slow = 1; //此处fast 代表比较指针，参与值比较 int fast = 1; while (fast \u003c len) { if (nums[fast] != nums[fast-1]) { nums[slow] = nums[fast]; slow++; } fast++; } return slow; } } ","date":"2022-08-19","objectID":"/posts/tech/leetcode/array/:1:1","tags":["数组","leetcode"],"title":"算法-数组","uri":"/posts/tech/leetcode/array/"},{"categories":["leetcode"],"content":"删除排序链表中的重复元素 第 83 题 删除排序链表中的重复元素 /** * 双指针 */ ListNode deleteDuplicates(ListNode head) { if (head == null) { return null; } ListNode slow = head, fast = head; while (fast != null) { if (fast.val != slow.val) { // nums[slow] = nums[fast]; slow.next = fast; // slow++; slow = slow.next; } // fast++ fast = fast.next; } // 断开与后面重复元素的连接 slow.next = null; return head; } /** * 单指针 */ ListNode deleteDuplicates1(ListNode head) { if (head == null) { return head; } ListNode cur = head; while (cur.next != null) { if (cur.val == cur.next.val) { cur.next = cur.next.next; } else { cur = cur.next; } } return head; } 除了让你在有序数组/链表中去重，题目还可能让你对数组中的某些元素进行「原地删除」。 ","date":"2022-08-19","objectID":"/posts/tech/leetcode/array/:1:2","tags":["数组","leetcode"],"title":"算法-数组","uri":"/posts/tech/leetcode/array/"},{"categories":["leetcode"],"content":"移除元素 如力扣第 27 题「 移除元素」 class Solution { /** * 移动完成后， nums[0]-nums[slow-1] 之间不包含val； nums[slow]-nums[nums.Length-1] 之间包含val */ public int removeElement(int[] nums, int val) { int slow = 0 ; int len = nums.length; for (int i = 0; i \u003c len; i++) { if (nums[i] != val) { // nums[slow] = nums[i]; // slow++; //等同于上面 nums[slow++] = nums[i]; } } return slow; } } ","date":"2022-08-19","objectID":"/posts/tech/leetcode/array/:1:3","tags":["数组","leetcode"],"title":"算法-数组","uri":"/posts/tech/leetcode/array/"},{"categories":["leetcode"],"content":"移动零-E 第 283 题「 移动零」 给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。 请注意 ，必须在不复制数组的情况下原地对数组进行操作。 class Solution { public void moveZeroes(int[] nums) { int tmp = 0; int last = nums.length - 1; for (int i = 0; i \u003c nums.length; i++) { if (nums[i] != 0) { // nums[tmp] = nums[i]; // tmp++; //等同于上述 nums[tmp++] = nums[i]; } } while (tmp \u003c nums.length) { // nums[tmp] = 0; // tmp++; //等同于上述 nums[tmp++] = 0; } } } ","date":"2022-08-19","objectID":"/posts/tech/leetcode/array/:1:4","tags":["数组","leetcode"],"title":"算法-数组","uri":"/posts/tech/leetcode/array/"},{"categories":["leetcode"],"content":"合并两个有序数组 第 88 题 合并两个有序数组 给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。 请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。 最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。 class Solution { /** * 方法1：双指针法 （低耗时） */ public void merge(int[] nums1, int m, int[] nums2, int n) { int[] array = new int[m + n]; int p1 = 0; int p2 = 0; int v; while (p1 \u003c m || p2 \u003c n) { if (p1 == m) { v = nums2[p2++]; } else if (p2 == n) { v = nums1[p1++]; } else if (nums1[p1] \u003e nums2[p2]) { v = nums2[p2++]; } else { v = nums1[p1++]; } array[p1 + p2 - 1] = v; } for (int i = 0; i != m + n; ++i) { nums1[i] = array[i]; } } /** * 方法2：直接合并后排序 * 运用函数 */ // public void merge(int[] nums1, int m, int[] nums2, int n) { // for (int i = 0; i \u003c n; i++) { // nums1[m + i] = nums2[i]; // } // Arrays.sort(nums1); // } } ","date":"2022-08-19","objectID":"/posts/tech/leetcode/array/:1:5","tags":["数组","leetcode"],"title":"算法-数组","uri":"/posts/tech/leetcode/array/"},{"categories":["leetcode"],"content":"二、左右指针的常用算法 1、二分查找 最简单的二分算法，旨在突出它的双指针特性： int binarySearch(int[] nums, int target) { // 一左一右两个指针相向而行 int left = 0, right = nums.length - 1; while(left \u003c= right) { int mid = (right + left) / 2; if(nums[mid] == target) return mid; else if (nums[mid] \u003c target) left = mid + 1; else if (nums[mid] \u003e target) right = mid - 1; } return -1; } ","date":"2022-08-19","objectID":"/posts/tech/leetcode/array/:2:0","tags":["数组","leetcode"],"title":"算法-数组","uri":"/posts/tech/leetcode/array/"},{"categories":["leetcode"],"content":"两数之和 2、两数之和 看下力扣第 167 题「 两数之和 II」 只要数组有序，就应该想到双指针技巧。这道题的解法有点类似二分查找，通过调节 left 和 right 就可以调整 sum 的大小： int[] twoSum(int[] nums, int target) { // 一左一右两个指针相向而行 int left = 0, right = nums.length - 1; while (left \u003c right) { int sum = nums[left] + nums[right]; if (sum == target) { // 题目要求的索引是从 1 开始的 return new int[]{left + 1, right + 1}; } else if (sum \u003c target) { left++; // 让 sum 大一点 } else if (sum \u003e target) { right--; // 让 sum 小一点 } } return new int[]{-1, -1}; } ","date":"2022-08-19","objectID":"/posts/tech/leetcode/array/:2:1","tags":["数组","leetcode"],"title":"算法-数组","uri":"/posts/tech/leetcode/array/"},{"categories":["leetcode"],"content":"反转数组 一般编程语言都会提供 reverse 函数，其实这个函数的原理非常简单，力扣第 344 题「 反转字符串」 就是类似的需求，让你反转一个 char[] 类型的字符数组， void reverseString(char[] s) { // 一左一右两个指针相向而行 int left = 0, right = s.length - 1; while (left \u003c right) { // 交换 s[left] 和 s[right] char temp = s[left]; s[left] = s[right]; s[right] = temp; left++; right--; } } ","date":"2022-08-19","objectID":"/posts/tech/leetcode/array/:2:2","tags":["数组","leetcode"],"title":"算法-数组","uri":"/posts/tech/leetcode/array/"},{"categories":["leetcode"],"content":"回文串判断 首先明确一下，回文串就是正着读和反着读都一样的字符串。 比如说字符串 aba 和 abba 都是回文串，因为它们对称，反过来还是和本身一样；反之，字符串 abac 就不是回文串。 现在你应该能感觉到回文串问题和左右指针肯定有密切的联系，比如让你判断一个字符串是不是回文串，你可以写出下面这段代码： boolean isPalindrome(String s) { // 一左一右两个指针相向而行 int left = 0, right = s.length() - 1; while (left \u003c right) { if (s.charAt(left) != s.charAt(right)) { return false; } left++; right--; } return true; } 那接下来我提升一点难度，给你一个字符串，让你用双指针技巧从中找出最长的回文串，你会做吗？ ","date":"2022-08-19","objectID":"/posts/tech/leetcode/array/:2:3","tags":["数组","leetcode"],"title":"算法-数组","uri":"/posts/tech/leetcode/array/"},{"categories":["leetcode"],"content":"最长回文子串 这就是力扣第 5 题「 最长回文子串」 class Solution { /** * 中心扩展算法 * 找到以 s[i] 为中心的回文串 * 找到以 s[i] 和 s[i+1] 为中心的回文串 * 更新答案 */ public String longestPalindrome(String s) { String maxStr = \"\"; for (int i = 0; i \u003c s.length(); i++) { // 以 s[i] 为中心的最长回文子串 String tmp = queryLongStr(s, i, i); maxStr = maxStr.length() \u003e tmp.length() ? maxStr : tmp; // 以 s[i] 和 s[i+1] 为中心的最长回文子串 tmp = queryLongStr(s, i, i + 1); maxStr = maxStr.length() \u003e tmp.length() ? maxStr : tmp; } return maxStr; } // 在 s 中寻找以 s[l] 和 s[r] 为中心的最长回文串 public String queryLongStr(String s, int l, int r) { // 防止索引越界 while (l \u003e= 0 \u0026\u0026 r \u003c s.length() \u0026\u0026 s.charAt(l) == s.charAt(r)) { // 双指针，向两边展开 l--; r++; } // 返回以 s[l] 和 s[r] 为中心的最长回文串 return s.substring(l + 1, r); } } ","date":"2022-08-19","objectID":"/posts/tech/leetcode/array/:2:4","tags":["数组","leetcode"],"title":"算法-数组","uri":"/posts/tech/leetcode/array/"},{"categories":["leetcode"],"content":"第一个错误的版本 力扣第 278 题 第一个错误的版本 你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。 假设你有 n 个版本 [1, 2, …, n]，你想找出导致之后所有版本出错的第一个错误的版本。 你可以通过调用bool isBadVersion(version)接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。 public class Solution extends VersionControl { /** * 二分查找 * 注意到一个性质：当一个版本为正确版本，则该版本之前的所有版本均为正确版本；当一个版本为错误版本，则该版本之后的所有版本均为错误版本。我们可以利用这个性质进行二分查找。 */ public int firstBadVersion(int n) { int left=0,right=n; while(left\u003cright){ int middle =left+(right-left)/2; if(isBadVersion(middle)){ right=middle; }else{ left=middle+1; } } return left; } } ","date":"2022-08-19","objectID":"/posts/tech/leetcode/array/:2:5","tags":["数组","leetcode"],"title":"算法-数组","uri":"/posts/tech/leetcode/array/"},{"categories":["leetcode"],"content":"两个数组的交集 II-E【重复】 力扣第 350 题 两个数组的交集 II 给你两个整数数组nums1 和 nums2 ，请你以数组形式返回两数组的交集。返回结果中每个元素出现的次数，应与元素在两个数组中都出现的次数一致（如果出现次数不一致，则考虑取较小值）。可以不考虑输出结果的顺序。 class Solution { public int[] intersect(int[] nums1, int[] nums2) { Arrays.sort(nums1); Arrays.sort(nums2); int len = nums1.length\u003enums2.length ? nums1.length : nums2.length;; int[] result = new int[len]; int left1=0,left2=0; int i=0; while(left1\u003cnums1.length \u0026\u0026 left2\u003cnums2.length){ if(nums1[left1]==nums2[left2]){ result[i]=nums1[left1]; i++; left1++; left2++; }else if(nums1[left1]\u003enums2[left2]){ left2++; }else if(nums1[left1]\u003cnums2[left2]){ left1++; } } int[] res = new int[i]; for(int n=0;n\u003ci;n++){ res[n]=result[n]; } return res; } } 算法技巧：[前缀和]数组 前缀和主要适用的场景是原始数组不会被修改的情况下，频繁查询某个区间的累加和。 ","date":"2022-08-19","objectID":"/posts/tech/leetcode/array/:2:6","tags":["数组","leetcode"],"title":"算法-数组","uri":"/posts/tech/leetcode/array/"},{"categories":["leetcode"],"content":"一维数组中的 [前缀和] 力扣第 303 题「 区域和检索 - 数组不可变」 ，让你计算数组区间内元素的和，这是一道标准的前缀和问题 class NumArray { // 前缀和数组 int[] sum; /* 输入一个数组，构造前缀和 */ public NumArray(int[] nums) { int len = nums.length(); sum = new int[len + 1]; for (int i = 0; i \u003c len; i++) { // 计算 nums 的累加和 //注意，此处为 sum[i + 1] sum[i + 1] = sum[i] + nums[i]; } } /* 查询闭区间 [left, right] 的累加和 */ public int sumRange(int left, int right) { return sum[right + 1] - sum[left]; } } ","date":"2022-08-19","objectID":"/posts/tech/leetcode/array/:3:0","tags":["数组","leetcode"],"title":"算法-数组","uri":"/posts/tech/leetcode/array/"},{"categories":["leetcode"],"content":"二维矩阵中的 [前缀和] 力扣第 304 题「 二维区域和检索 - 矩阵不可变」 ，其实和上一题类似，上一题是让你计算子数组的元素之和，这道题让你计算二维矩阵中子矩阵的元素之和。 class NumMatrix { // 定义：preSum[i][j] 记录 matrix 中子矩阵 [0, 0, i-1, j-1] 的元素和 int[][] preSum; public NumMatrix(int[][] matrix) { int height = matrix.length; int width = matrix[0].length; if (height == 0 || width == 0){ return; } // 构造前缀和矩阵 preSum = new int[height+1][width+1]; for (int i = 1; i \u003c= height; i++) { for (int j = 1; j \u003c= width; j++) { // 计算每个矩阵 [0, 0, i, j] 的元素和 preSum[i][j] = preSum[i - 1][j] + preSum[i][j - 1] - preSum[i - 1][j - 1] + matrix[i - 1][j - 1]; } } } // 计算子矩阵 [x1, y1, x2, y2] 的元素和 public int sumRegion(int row1, int col1, int row2, int col2) { // 目标矩阵之和由四个相邻矩阵运算获得 [此处注意坐标] return preSum[row2+1][col2+1] - preSum[row1][col2+1] - preSum[row2+1][col1] + preSum[row1][col1]; } } 算法技巧：差分数组 差分数组的主要适用场景是频繁对原始数组的某个区间的元素进行增减。 差分数组对应的概念是前缀 和 数组，对于数组 [1,2,2,4]，其差分数组为 [1,1,0,2] 事例：https://labuladong.gitee.io/algo/2/20/25/ class NumMatrix { // 定义：preSum[i][j] 记录 matrix 中子矩阵 [0, 0, i-1, j-1] 的元素和 int[][] preSum; public NumMatrix(int[][] matrix) { int height = matrix.length; int width = matrix[0].length; if (height == 0 || width == 0){ return; } // 构造前缀和矩阵 preSum = new int[height+1][width+1]; for (int i = 1; i \u003c= height; i++) { for (int j = 1; j \u003c= width; j++) { // 计算每个矩阵 [0, 0, i, j] 的元素和 preSum[i][j] = preSum[i - 1][j] + preSum[i][j - 1] - preSum[i - 1][j - 1] + matrix[i - 1][j - 1]; } } } // 计算子矩阵 [x1, y1, x2, y2] 的元素和 public int sumRegion(int row1, int col1, int row2, int col2) { // 目标矩阵之和由四个相邻矩阵运算获得 [此处注意坐标] return preSum[row2+1][col2+1] - preSum[row1][col2+1] - preSum[row2+1][col1] + preSum[row1][col1]; } } 比如说，我给你输入一个数组 nums，然后又要求给区间 nums[2..6] 全部加 1，再给 nums[3..9] 全部减 3，再给 nums[0..4] 全部加 2，再给… 一通操作猛如虎，然后问你，最后 nums 数组的值是什么？ 常规的思路很容易，你让我给区间 nums[i..j] 加上 val，那我就一个 for 循环给它们都加上呗，还能咋样？这种思路的时间复杂度是 O(N)，由于这个场景下对 nums 的修改非常频繁，所以效率会很低下。 这里就需要差分数组的技巧，类似前缀和技巧构造的 prefix 数组，我们先对 nums 数组构造一个 diff 差分数组，diff[i] 就是 nums[i] 和 nums[i-1] 之差： int[] diff = new int[nums.length]; // 构造差分数组 diff[0] = nums[0]; for (int i = 1; i \u003c nums.length; i++) { diff[i] = nums[i] - nums[i - 1]; } 通过这个 diff 差分数组是可以反推出原始数组 nums 的，代码逻辑如下： int[] res = new int[diff.length]; // 根据差分数组构造结果数组 res[0] = diff[0]; for (int i = 1; i \u003c diff.length; i++) { res[i] = res[i - 1] + diff[i]; } 这样构造差分数组 diff，就可以快速进行区间增减的操作，如果你想对区间 nums[i..j] 的元素全部加 3，那么只需要让 diff[i] += 3，然后再让 diff[j+1] -= 3 即可; 力扣第 370 题「 区间加法」 就直接考察了差分数组技巧 int[] getModifiedArray(int length, int[][] updates) { // nums 初始化为全 0 int[] nums = new int[length]; // 构造差分解法 Difference df = new Difference(nums); for (int[] update : updates) { int i = update[0]; int j = update[1]; int val = update[2]; df.increment(i, j, val); } return df.result(); } // 差分数组工具类 class Difference { // 差分数组 private int[] diff; /* 输入一个初始数组，区间操作将在这个数组上进行 */ public Difference(int[] nums) { assert nums.length \u003e 0; diff = new int[nums.length]; // 根据初始数组构造差分数组 diff[0] = nums[0]; for (int i = 1; i \u003c nums.length; i++) { diff[i] = nums[i] - nums[i - 1]; } } /* 给闭区间 [i, j] 增加 val（可以是负数）*/ public void increment(int i, int j, int val) { diff[i] += val; if (j + 1 \u003c diff.length) { diff[j + 1] -= val; } } /* 返回结果数组 */ public int[] result() { int[] res = new int[diff.length]; // 根据差分数组构造结果数组 res[0] = diff[0]; for (int i = 1; i \u003c diff.length; i++) { res[i] = res[i - 1] + diff[i]; } return res; } } ","date":"2022-08-19","objectID":"/posts/tech/leetcode/array/:4:0","tags":["数组","leetcode"],"title":"算法-数组","uri":"/posts/tech/leetcode/array/"},{"categories":["leetcode"],"content":"航班预定 实际的算法题可能需要我们对题目进行联想和抽象，不会这么直接地让你看出来要用差分数组技巧，这里看一下力扣第 1109 题「 航班预订统计」 这里有 n 个航班，它们分别从 1 到 n 进行编号。 有一份航班预订表 bookings ，表中第 i 条预订记录 bookings[i] = [firsti, lasti, seatsi] 意味着在从 firsti 到 lasti （包含 firsti 和 lasti ）的 每个航班 上预订了 seatsi 个座位。 请你返回一个长度为 n 的数组 answer，里面的元素是每个航班预定的座位总数。 示例 1： 输入：bookings = [[1,2,10],[2,3,20],[2,5,25]], n = 5 输出：[10,55,45,25,25] 解释： 航班编号 1 2 3 4 5 预订记录 1 ： 10 10 预订记录 2 ： 20 20 预订记录 3 ： 25 25 25 25 总座位数： 10 55 45 25 25 因此，answer = [10,55,45,25,25] class Solution { public int[] corpFlightBookings(int[][] bookings, int n) { // nums 初始化为全 0 int[] nums = new int[n]; // 构造差分解法 Difference df = new Difference(nums); for (int[] booking : bookings) { // 注意转成数组索引要减一哦 int i = booking[0] - 1; int j = booking[1] - 1; int val = booking[2]; // 对区间 nums[i..j] 增加 val df.increment(i, j, val); } // 返回最终的结果数组 return df.result(); } } // 差分数组工具类 class Difference { // 差分数组 private int[] diff; /* 输入一个初始数组，区间操作将在这个数组上进行 */ public Difference(int[] nums) { diff = new int[nums.length]; // 根据初始数组构造差分数组 diff[0] = nums[0]; for (int i = 1; i \u003c nums.length; i++) { diff[i] = nums[i] - nums[i - 1]; } } /* 给闭区间 [i, j] 增加 val（可以是负数）*/ public void increment(int i, int j, int val) { diff[i] += val; if (j + 1 \u003c diff.length) { diff[j + 1] -= val; } } /* 返回结果数组 */ public int[] result() { int[] res = new int[diff.length]; // 根据差分数组构造结果数组 res[0] = diff[0]; for (int i = 1; i \u003c diff.length; i++) { res[i] = res[i - 1] + diff[i]; } return res; } } ","date":"2022-08-19","objectID":"/posts/tech/leetcode/array/:5:0","tags":["数组","leetcode"],"title":"算法-数组","uri":"/posts/tech/leetcode/array/"},{"categories":["leetcode"],"content":"拼车 还有一道很类似的题目是力扣第 1094 题「 拼车」 class Solution { public boolean carPooling(int[][] trips, int capacity) { //注意此处的初始化定义 // 最多有 1001 个车站 int[] nums = new int[1001]; // 构造差分解法 Tools tools = new Tools(nums); for (int[] array : trips) { int v = array[0]; // 第 trip[1] 站乘客上车 int i = array[1]; //注意此处赋值 // 第 trip[2] 站乘客已经下车， // 即乘客在车上的区间是 [trip[1], trip[2] - 1] int j = array[2] - 1; tools.add(i, j, v); } int[] res = tools.result(); // 客车自始至终都不应该超载 for (int r : res) { if (r \u003e capacity) { return false; } } return true; } } // 差分数组工具类 class Tools { int preSum[]; public Tools(int[] array) { int len = array.length; preSum = new int[len]; // 根据初始数组构造差分数组 preSum[0] = array[0]; for (int i = 1; i \u003c array.length; i++) { preSum[i] = array[i] - array[i - 1]; } } /* 给闭区间 [i, j] 增加 val（可以是负数）*/ public void add(int i, int j, int v) { preSum[i] += v; if (j + 1 \u003c preSum.length) { preSum[j + 1] -= v; } } /* 返回结果数组 */ public int[] result() { int[] result = new int[preSum.length]; // 根据差分数组构造结果数组 result[0] = preSum[0]; for (int i = 1; i \u003c preSum.length; i++) { //注意此处为 preSum[i] + result[i - 1]; result[i] = preSum[i] + result[i - 1]; } return result; } } 二维数组的花式遍历技巧 ","date":"2022-08-19","objectID":"/posts/tech/leetcode/array/:6:0","tags":["数组","leetcode"],"title":"算法-数组","uri":"/posts/tech/leetcode/array/"},{"categories":["leetcode"],"content":"顺/逆时针旋转矩阵 ","date":"2022-08-19","objectID":"/posts/tech/leetcode/array/:7:0","tags":["数组","leetcode"],"title":"算法-数组","uri":"/posts/tech/leetcode/array/"},{"categories":["leetcode"],"content":"旋转图像 对二维数组进行旋转是常见的笔试题，力扣第 48 题「 旋转图像」 就是很经典的一道： class Solution { // 将二维矩阵原地顺时针旋转 90 度 public void rotate(int[][] matrix) { int high = matrix.length; int width = matrix[0].length; // 先沿对角线镜像对称二维矩阵 for(int i=0;i\u003chigh;i++){ for(int j=i;j\u003cwidth;j++){ int tmp = matrix[i][j]; matrix[i][j] = matrix[j][i]; matrix[j][i] = tmp; } } // 然后反转二维矩阵的每一行 for(int[] array: matrix){ int left=0,right=array.length-1; while(left\u003cright){ int tmp =array[left]; array[left] =array[right]; array[right] =tmp; left++; right--; } } } } 既然说道这里，我们可以发散一下，如何将矩阵逆时针旋转 90 度呢？ 思路是类似的，只要通过另一条对角线镜像对称矩阵，然后再反转每一行，就得到了逆时针旋转矩阵的结果 // 将二维矩阵原地逆时针旋转 90 度 void rotate2(int[][] matrix) { int n = matrix.length; // 沿左下到右上的对角线镜像对称二维矩阵 for (int i = 0; i \u003c n; i++) { for (int j = 0; j \u003c n - i; j++) { // swap(matrix[i][j], matrix[n-j-1][n-i-1]) int temp = matrix[i][j]; matrix[i][j] = matrix[n - j - 1][n - i - 1]; matrix[n - j - 1][n - i - 1] = temp; } } // 然后反转二维矩阵的每一行 for(int[] array: matrix){ int left=0,right=array.length-1; while(left\u003cright){ int tmp =array[left]; array[left] =array[right]; array[right] =tmp; left++; right--; } } } ","date":"2022-08-19","objectID":"/posts/tech/leetcode/array/:7:1","tags":["数组","leetcode"],"title":"算法-数组","uri":"/posts/tech/leetcode/array/"},{"categories":["leetcode"],"content":"矩阵的螺旋遍历 ","date":"2022-08-19","objectID":"/posts/tech/leetcode/array/:8:0","tags":["数组","leetcode"],"title":"算法-数组","uri":"/posts/tech/leetcode/array/"},{"categories":["leetcode"],"content":"螺旋矩阵 力扣第 54 题「 螺旋矩阵」 ，看一看二维矩阵可以如何花式遍历 class Solution { public List\u003cInteger\u003e spiralOrder(int[][] matrix) { List\u003cInteger\u003e result = new ArrayList\u003c\u003e(); //upper_bound right_bound //left_bound lower_bound int m = matrix.length; int n = matrix[0].length; int upper_bound = 0, right_bound = n - 1; int left_bound = 0, lower_bound = m - 1; // result.size() == m * n 则遍历完整个数组 while (result.size() \u003c m * n) { if (upper_bound \u003c= lower_bound) { // 在顶部从左向右遍历 for (int j = left_bound; j \u003c= right_bound; j++) { result.add(matrix[upper_bound][j]); } // 上边界下移 upper_bound++; } if (left_bound \u003c= right_bound) { // 在右侧从上向下遍历 for (int i = upper_bound; i \u003c= lower_bound; i++) { result.add(matrix[i][right_bound]); } // 右边界左移 right_bound--; } if (upper_bound \u003c= lower_bound) { // 在底部从右向左遍历 for (int j = right_bound; j \u003e= left_bound; j--) { result.add(matrix[lower_bound][j]); } // 下边界上移 lower_bound--; } if (left_bound \u003c= right_bound) { // 在左侧从下向上遍历 for (int i = lower_bound; i \u003e= upper_bound; i--) { result.add(matrix[i][left_bound]); } // 左边界右移 left_bound++; } } return result; } } ","date":"2022-08-19","objectID":"/posts/tech/leetcode/array/:8:1","tags":["数组","leetcode"],"title":"算法-数组","uri":"/posts/tech/leetcode/array/"},{"categories":["leetcode"],"content":"螺旋矩阵II 力扣第 59 题「 螺旋矩阵 II」 也是类似的题目，只不过是反过来，让你按照螺旋的顺序生成矩阵 class Solution { public int[][] generateMatrix(int n) { //upper_bound right_bound //left_bound lower_bound int[][] matrix=new int[n][n]; int upper_bound = 0, right_bound = n - 1; int left_bound = 0, lower_bound = n - 1; int sum = 1; // result.size() == m * n 则遍历完整个数组 while (sum \u003c= n*n) { if (upper_bound \u003c= lower_bound) { // 在顶部从左向右遍历 for (int j = left_bound; j \u003c= right_bound; j++) { matrix[upper_bound][j] = sum++; } // 上边界下移 upper_bound++; } if (left_bound \u003c= right_bound) { // 在右侧从上向下遍历 for (int i = upper_bound; i \u003c= lower_bound; i++) { matrix[i][right_bound] = sum++; } // 右边界左移 right_bound--; } if (upper_bound \u003c= lower_bound) { // 在底部从右向左遍历 for (int j = right_bound; j \u003e= left_bound; j--) { matrix[lower_bound][j] = sum++; } // 下边界上移 lower_bound--; } if (left_bound \u003c= right_bound) { // 在左侧从下向上遍历 for (int i = lower_bound; i \u003e= upper_bound; i--) { matrix[i][left_bound] = sum++; } // 左边界右移 left_bound++; } } return matrix; } } 滑动窗口 滑动窗口防滑记 链表子串数组题，用双指针别犹豫。 双指针家三兄弟，各个都是万人迷， 快慢指针最神奇，链表操作无压力。 归并排序找中点，链表成环搞判定。 左右指针最常见，左右两端相向行。 反转数组要靠它，二分搜索是弟弟。 滑动窗口老猛男，子串问题全靠它， 左右指针滑窗口，一前一后齐头进。 算法思想很简单，出了bug想升天。 labuladong稳若狗，一套框架不翻车。 一路漂移带闪电，算法变成默写题。 本文就解决一类最难掌握的双指针技巧：滑动窗口技巧。总结出一套框架，可以保你闭着眼睛都能写出正确的解法。 说起滑动窗口算法，很多读者都会头疼。这个算法技巧的思路非常简单，就是维护一个窗口，不断滑动，然后更新答案么。LeetCode 上有起码 10 道运用滑动窗口算法的题目，难度都是中等和困难。该算法的大致逻辑如下： int left = 0, right = 0; while (right \u003c s.size()) { // 增大窗口 window.add(s[right]); right++; while (window needs shrink) { // 缩小窗口 window.remove(s[left]); left++; } } 这个算法技巧的时间复杂度是 O(N)，比字符串暴力算法要高效得多。 其实困扰大家的，不是算法的思路，而是各种细节问题。比如说如何向窗口中添加新元素，如何缩小窗口，在窗口滑动的哪个阶段更新结果。即便你明白了这些细节，也容易出 bug，找 bug 还不知道怎么找，真的挺让人心烦的。 所以今天我就写一套滑动窗口算法的代码框架，我连再哪里做输出 debug 都给你写好了，以后遇到相关的问题，你就默写出来如下框架然后改三个地方就行，还不会出 bug： /* 滑动窗口算法框架 */ void slidingWindow(string s) { unordered_map\u003cchar, int\u003e window; int left = 0, right = 0; while (right \u003c s.size()) { // c 是将移入窗口的字符 char c = s[right]; // 增大窗口 right++; // 进行窗口内数据的一系列更新 ... /*** debug 输出的位置 ***/ printf(\"window: [%d, %d)\\n\", left, right); /********************/ // 判断左侧窗口是否要收缩 while (window needs shrink) { // d 是将移出窗口的字符 char d = s[left]; // 缩小窗口 left++; // 进行窗口内数据的一系列更新 ... } } } 虽然滑动窗口代码框架中有一个嵌套的 while 循环，但算法的时间复杂度依然是 O(N)，其中 N 是输入字符串/数组的长度。 为什么呢？简单说，字符串/数组中的每个元素都只会进入窗口一次，然后被移出窗口一次，不会说有某些元素多次进入和离开窗口，所以算法的时间复杂度就和字符串/数组的长度成正比。 说句题外话，我发现很多人喜欢执着于表象，不喜欢探求问题的本质。比如说有很多人评论我这个框架，说什么散列表速度慢，不如用数组代替散列表；还有很多人喜欢把代码写得特别短小，说我这样代码太多余，影响编译速度，LeetCode 上速度不够快。 我的意见是，算法主要看时间复杂度，你能确保自己的时间复杂度最优就行了。至于 LeetCode 所谓的运行速度，那个都是玄学，只要不是慢的离谱就没啥问题，根本不值得你从编译层面优化，不要舍本逐末…… ","date":"2022-08-19","objectID":"/posts/tech/leetcode/array/:8:2","tags":["数组","leetcode"],"title":"算法-数组","uri":"/posts/tech/leetcode/array/"},{"categories":["leetcode"],"content":"最小覆盖子串 先来看看力扣第 76 题「 最小覆盖子串」 难度 Hard： class Solution { public String minWindow(String s, String t) { Map\u003cCharacter, Integer\u003e needMap = new HashMap\u003c\u003e(); Map\u003cCharacter, Integer\u003e windowMap = new HashMap\u003c\u003e(); for (char c : t.toCharArray()) { needMap.put(c, needMap.getOrDefault(c, 0) + 1); } int left = 0, right = 0; int valid = 0; // 记录最小覆盖子串的起始索引 及 长度 int startIndex = 0, lenStep = Integer.MAX_VALUE; while (right \u003c s.length()) { // c 是将移入窗口的字符 char c = s.charAt(right); // 扩大窗口 right++; // 进行窗口内数据的一系列更新 if (needMap.containsKey(c)) { windowMap.put(c, windowMap.getOrDefault(c, 0) + 1); //若窗口内某个字符 总数 和 needMap中的该字符的 数量相等时 if (windowMap.get(c).equals(needMap.get(c))) { valid++; } } // 判断左侧窗口是否要收缩 【窗口内的字符，包含needMap中的所有字符】 while (valid == needMap.size()) { // 在这里更新最小覆盖子串, if (right - left \u003c lenStep) { startIndex = left; lenStep = right - left; } // d 是将移出窗口的字符 char d = s.charAt(left); // 缩小窗口 left++; // 进行窗口内数据的一系列更新 if (needMap.containsKey(d)) { if (windowMap.get(d).equals(needMap.get(d))) { valid--; } windowMap.put(d, windowMap.getOrDefault(d, 0) - 1); } } } // 返回最小覆盖子串 return lenStep == Integer.MAX_VALUE ? \"\" : s.substring(startIndex, startIndex + lenStep); } } ","date":"2022-08-19","objectID":"/posts/tech/leetcode/array/:9:0","tags":["数组","leetcode"],"title":"算法-数组","uri":"/posts/tech/leetcode/array/"},{"categories":["leetcode"],"content":"字符串排列 力扣第 567 题「 字符串的排列」 ，难度中等： 这种题目，是明显的滑动窗口算法，相当给你一个 S 和一个 T，请问你 S 中是否存在一个子串，包含 T 中所有字符且不包含其他字符？ 首先，先复制粘贴之前的算法框架代码，然后明确刚才提出的几个问题，即可写出这道题的答案： 对于这道题的解法代码，基本上和最小覆盖子串一模一样，只需要改变几个地方： 1、本题移动 left 缩小窗口的时机是窗口大小大于 t.size() 时，应为排列嘛，显然长度应该是一样的。 2、当发现 valid == need.size() 时，就说明窗口中就是一个合法的排列，所以立即返回 true。 至于如何处理窗口的扩大和缩小，和最小覆盖子串完全相同。 class Solution { /** 滑动窗口解法 */ public boolean checkInclusion(String s1, String s2) { Map\u003cCharacter, Integer\u003e needMap = new HashMap\u003c\u003e(); Map\u003cCharacter, Integer\u003e windowMap = new HashMap\u003c\u003e(); for (char c : s1.toCharArray()) { needMap.put(c, needMap.getOrDefault(c, 0) + 1); } int left = 0, right = 0; int valid = 0; // 记录最小覆盖子串的起始索引 及 长度 int startIndex = 0, lenStep = Integer.MAX_VALUE; while (right \u003c s2.length()) { // c 是将移入窗口的字符 char c = s2.charAt(right); // 扩大窗口 right++; // 进行窗口内数据的一系列更新 if (needMap.containsKey(c)) { windowMap.put(c, windowMap.getOrDefault(c, 0) + 1); //若窗口内某个字符 总数 和 needMap中的该字符的 数量相等时 if (windowMap.get(c).equals(needMap.get(c))) { valid++; } } // 判断左侧窗口是否要收缩 [注意此处为 s1.length()] while (right-left \u003e= s1.length()) { // 在这里判断是否找到了合法的子串 if (valid==needMap.size()) { return true; } // d 是将移出窗口的字符 char d = s2.charAt(left); // 缩小窗口 left++; // 进行窗口内数据的一系列更新 if (needMap.containsKey(d)) { if (windowMap.get(d).equals(needMap.get(d))) { valid--; } windowMap.put(d, windowMap.getOrDefault(d, 0) - 1); } } } return false; } } ","date":"2022-08-19","objectID":"/posts/tech/leetcode/array/:10:0","tags":["数组","leetcode"],"title":"算法-数组","uri":"/posts/tech/leetcode/array/"},{"categories":["leetcode"],"content":"找所有字母异位词 力扣第 438 题「 找到字符串中所有字母异位词」 ，难度中等： 呵呵，这个所谓的字母异位词，不就是排列吗，搞个高端的说法就能糊弄人了吗？ 相当于，输入一个串 S，一个串 T，找到 S 中所有 T 的排列，返回它们的起始索引。 class Solution { /** 滑动窗口解法 */ public List\u003cInteger\u003e findAnagrams(String s, String p) { List\u003cInteger\u003e result = new ArrayList\u003c\u003e(); Map\u003cCharacter, Integer\u003e needMap = new HashMap\u003c\u003e(); Map\u003cCharacter, Integer\u003e windowMap = new HashMap\u003c\u003e(); for (char c : p.toCharArray()) { needMap.put(c, needMap.getOrDefault(c, 0) + 1); } int left = 0, right = 0; int valid = 0; // 记录最小覆盖子串的起始索引 及 长度 int startIndex = 0, lenStep = Integer.MAX_VALUE; while (right \u003c s.length()) { // c 是将移入窗口的字符 char c = s.charAt(right); // 扩大窗口 right++; // 进行窗口内数据的一系列更新 if (needMap.containsKey(c)) { windowMap.put(c, windowMap.getOrDefault(c, 0) + 1); //若窗口内某个字符 总数 和 needMap中的该字符的 数量相等时 if (windowMap.get(c).equals(needMap.get(c))) { valid++; } } // 判断左侧窗口是否要收缩 [注意此处为 p.length()] while (right-left \u003e= p.length()) { // 在这里判断是否找到了合法的子串 if (valid==needMap.size()) { result.add(left); } // d 是将移出窗口的字符 char d = s.charAt(left); // 缩小窗口 left++; // 进行窗口内数据的一系列更新 if (needMap.containsKey(d)) { if (windowMap.get(d).equals(needMap.get(d))) { valid--; } windowMap.put(d, windowMap.getOrDefault(d, 0) - 1); } } } return result; } } ","date":"2022-08-19","objectID":"/posts/tech/leetcode/array/:11:0","tags":["数组","leetcode"],"title":"算法-数组","uri":"/posts/tech/leetcode/array/"},{"categories":["leetcode"],"content":"最长无重复子串 力扣第 3 题「 无重复字符的最长子串」 ，难度中等： class Solution { /** * 滑动窗口 */ public int lengthOfLongestSubstring(String s) { Map\u003cCharacter, Integer\u003e windowMap = new HashMap\u003c\u003e(); int left = 0, right = 0; int max = 0; while (right \u003c s.length()) { // c 是将移入窗口的字符 char c = s.charAt(right); // 扩大窗口 right++; // 判断左侧窗口是否要收缩 [注意此处为 p.length()] windowMap.put(c, windowMap.getOrDefault(c, 0) + 1); while (windowMap.get(c) \u003e 1) { // d 是将移出窗口的字符 char d = s.charAt(left); // 缩小窗口 left++; // 进行窗口内数据的一系列更新 windowMap.put(d, windowMap.getOrDefault(d, 0) - 1); } max = Math.max(max, right - left); } return max; } // public int lengthOfLongestSubstring(String s) { // int ans = 0; // int len = s.length(); // Map\u003cCharacter, Integer\u003e map = new HashMap\u003c\u003e(); // for (int i = 0, j = 0; j \u003c len; j++) { // //判断这个字母是否在map中。 // if(map.containsKey(s.charAt(j))) { // //如果在，说明重复了，需要移动i了，将i移动到 s.charAt(j) 这个字母的下一位。 // //因为map中的key字母可以重复，所以，查找最大的i保证了i是在最右边。 // i = Math.max(map.get(s.charAt(j)), i); // } // //如果不再，说明这位也是字符串的字母，需要加一。 // ans = Math.max(ans, j-i+1); // //将键值对写入map，key是字母，位置是value。不用管重复的问题，只需要移动i到合适的位置即可。 // map.put(s.charAt(j), j+1); // } // return ans; // } } 滑动窗口算法模板就讲到这里，希望大家能理解其中的思想，记住算法模板并融会贯通。回顾一下，遇到子数组/子串相关的问题，你只要能回答出来以下几个问题，就能运用滑动窗口算法： 1、什么时候应该扩大窗口？ 2、什么时候应该缩小窗口？ 3、什么时候得到一个合法的答案？ 旨在强化你对算法的理解和记忆，以后就再也不怕子串、子数组问题了。 算法就是这样，再高大上的技巧，都是在最简单最基本的原理之上构建的. 滑动窗口算法延伸：RABIN KARP 字符匹配算法 refer to ","date":"2022-08-19","objectID":"/posts/tech/leetcode/array/:12:0","tags":["数组","leetcode"],"title":"算法-数组","uri":"/posts/tech/leetcode/array/"},{"categories":["leetcode"],"content":"高效寻找重复子序列 ","date":"2022-08-19","objectID":"/posts/tech/leetcode/array/:13:0","tags":["数组","leetcode"],"title":"算法-数组","uri":"/posts/tech/leetcode/array/"},{"categories":["leetcode"],"content":"重复的 DNA 序列 看下力扣第 187 题「 重复的 DNA 序列」 ，我简单描述下题目： class Solution { /** 穷举 */ public List\u003cString\u003e findRepeatedDnaSequences(String s) { // 记录出现过的子串 Set\u003cString\u003e total = new HashSet\u003c\u003e(); // 记录那些重复出现多次的子串 // 注意要用哈希集合，防止记录重复的结果 Set\u003cString\u003e repeat = new HashSet\u003c\u003e(); for(int i=0;i+10\u003c= s.length();i++){ String str= s.substring(i,i+10); if(total.contains(str)){ repeat.add(str); }else{ total.add(str); } } return new ArrayList\u003c\u003e(repeat); } } 零、二分查找框架 先给大家讲个笑话乐呵一下： 有一天阿东到图书馆借了 N 本书，出图书馆的时候，警报响了，于是保安把阿东拦下，要检查一下哪本书没有登记出借。阿东正准备把每一本书在报警器下过一下，以找出引发警报的书，但是保安露出不屑的眼神：你连二分查找都不会吗？于是保安把书分成两堆，让第一堆过一下报警器，报警器响；于是再把这堆书分成两堆…… 最终，检测了 logN 次之后，保安成功的找到了那本引起警报的书，露出了得意和嘲讽的笑容。于是阿东背着剩下的书走了。 从此，图书馆丢了 N - 1 本书（手动狗头）。 int binarySearch(int[] nums, int target) { int left = 0, right = ...; while(...) { int mid = left + (right - left) / 2; if (nums[mid] == target) { ... } else if (nums[mid] \u003c target) { left = ... } else if (nums[mid] \u003e target) { right = ... } } return ...; } 分析二分查找的一个技巧是：不要出现 else，而是把所有情况用 else if 写清楚，这样可以清楚地展现所有细节。本文都会使用 else if，旨在讲清楚，读者理解后可自行简化。 另外提前说明一下，计算 mid 时需要防止溢出，代码中 left + (right - left) / 2 就和 (left + right) / 2 的结果相同，但是有效防止了 left 和 right 太大，直接相加导致溢出的情况。 ","date":"2022-08-19","objectID":"/posts/tech/leetcode/array/:13:1","tags":["数组","leetcode"],"title":"算法-数组","uri":"/posts/tech/leetcode/array/"},{"categories":["leetcode"],"content":"寻找一个数（基本的二分搜索） 力扣第 704 题「 二分查找」 int binarySearch(int[] nums, int target) { int left = 0; int right = nums.length - 1; // 注意 while(left \u003c= right) { int mid = left + (right - left) / 2; if(nums[mid] == target) return mid; else if (nums[mid] \u003c target) left = mid + 1; // 注意 else if (nums[mid] \u003e target) right = mid - 1; // 注意 } return -1; } ","date":"2022-08-19","objectID":"/posts/tech/leetcode/array/:14:0","tags":["数组","leetcode"],"title":"算法-数组","uri":"/posts/tech/leetcode/array/"},{"categories":["leetcode"],"content":"寻找左侧边界的二分搜索 ","date":"2022-08-19","objectID":"/posts/tech/leetcode/array/:15:0","tags":["数组","leetcode"],"title":"算法-数组","uri":"/posts/tech/leetcode/array/"},{"categories":["leetcode"],"content":"寻找右侧边界的二分查找 int right_bound(int[] nums, int target) { int left = 0, right = nums.length - 1; while (left \u003c= right) { int mid = left + (right - left) / 2; if (nums[mid] \u003c target) { left = mid + 1; } else if (nums[mid] \u003e target) { right = mid - 1; } else if (nums[mid] == target) { // 这里改成收缩左侧边界即可 left = mid + 1; } } // 最后改成返回 left - 1 if (left - 1 \u003c 0) return -1; return nums[left - 1] == target ? (left - 1) : -1; } 带权重的随机选择算法 题解 ","date":"2022-08-19","objectID":"/posts/tech/leetcode/array/:16:0","tags":["数组","leetcode"],"title":"算法-数组","uri":"/posts/tech/leetcode/array/"},{"categories":["leetcode"],"content":"按权重随机选择 [没看懂] 力扣第 528 题「 按权重随机选择」 class Solution { // 前缀和数组 private int[] preSum; private Random rand = new Random(); public Solution(int[] w) { int n = w.length; // 构建前缀和数组，偏移一位留给 preSum[0] preSum = new int[n + 1]; preSum[0] = 0; // preSum[i] = sum(w[0..i-1]) for (int i = 1; i \u003c= n; i++) { preSum[i] = preSum[i - 1] + w[i - 1]; } } public int pickIndex() { int n = preSum.length; // 在闭区间 [1, preSum[n - 1]] 中随机选择一个数字 int target = rand.nextInt(preSum[n - 1]) + 1; // 获取 target 在前缀和数组 preSum 中的索引 // 别忘了前缀和数组 preSum 和原始数组 w 有一位索引偏移 return left_bound(preSum, target) - 1; } // 搜索左侧边界的二分搜索 private int left_bound(int[] nums, int target) { if (nums.length == 0) return -1; int left = 0, right = nums.length; while (left \u003c right) { int mid = left + (right - left) / 2; if (nums[mid] == target) { right = mid; } else if (nums[mid] \u003c target) { left = mid + 1; } else if (nums[mid] \u003e target) { right = mid; } } return left; } } /** * Your Solution object will be instantiated and called as such: * Solution obj = new Solution(w); * int param_1 = obj.pickIndex(); */ 田忌赛马背后的算法决策 力扣第 870 题「 优势洗牌」 基本思路 这题就像田忌赛马的情景，nums1 就是田忌的马，nums2 就是齐王的马，数组中的元素就是马的战斗力，你就是谋士孙膑，请你帮田忌安排赛马顺序，使胜场最多。 最优策略是将齐王和田忌的马按照战斗力排序，然后按照战斗力排名一一对比： 如果田忌的马能赢，那就比赛，如果赢不了，那就换个垫底的来送人头，保存实力。 public int[] advantageCount(int[] nums1, int[] nums2) { int n = nums1.length; // 给 nums2 降序排序 PriorityQueue\u003cint[]\u003e maxpq = new PriorityQueue\u003c\u003e( (int[] pair1, int[] pair2) -\u003e { return pair2[1] - pair1[1]; } ); for (int i = 0; i \u003c n; i++) { maxpq.offer(new int[]{i, nums2[i]}); } // 给 nums1 升序排序 Arrays.sort(nums1); // nums1[left] 是最小值，nums1[right] 是最大值 int left = 0, right = n - 1; int[] res = new int[n]; while (!maxpq.isEmpty()) { int[] pair = maxpq.poll(); // maxval 是 nums2 中的最大值，i 是对应索引 int i = pair[0], maxval = pair[1]; if (maxval \u003c nums1[right]) { // 如果 nums1[right] 能胜过 maxval，那就自己上 res[i] = nums1[right]; right--; } else { // 否则用最小值混一下，养精蓄锐 res[i] = nums1[left]; left++; } } return res; } /** *主要的思路: * 将问题转化成 已知B马出场顺序 以及B马的能力值 如何调整A的出场顺序 使能赢的场次最大 * * 将A马由大到小排序 * B从大到小排序,并记录B马原来的出场顺序() * 比较A当前最小的马和B当前最小的马 * 如果A最小的马\u003c=B最小的马 则让A最小的马和B最大的马对 * 如果A最小的马\u003eB最小的马 则让A最小的马和B最小的马对 * */ public int[] advantageCount(int[] nums1, int[] nums2) { /*让nums1马从小到大排序*/ Arrays.sort(nums1); int len = nums2.length; //0 -\u003e num2的马力值， 1 -\u003e num2的马力值对应的原数组坐标 int[][] sort2 = new int[len][2]; for (int i = 0; i \u003c len; i++) { sort2[i][0] = nums2[i]; sort2[i][1] = i; } /*让 nums2马从小到大排序*/ Arrays.sort(sort2, (a, b) -\u003e a[0] - b[0]); // num2最小值坐标 int left = 0; // num2最大值坐标 int right = len - 1; int[] result = new int[len]; for (int i = 0; i \u003c len; i++) { /*当前的马比最小马小, 就和他最大的马对*/ if (nums1[i] \u003c= sort2[left][0]) { result[sort2[right][1]] = nums1[i]; right--; } else { result[sort2[left][1]] = nums1[i]; left++; } } return result; } 常数时间删除/查找数组中的任意元素 [不懂] 力扣第 380 题「 常数时间插入、删除和获取随机元素」 ","date":"2022-08-19","objectID":"/posts/tech/leetcode/array/:17:0","tags":["数组","leetcode"],"title":"算法-数组","uri":"/posts/tech/leetcode/array/"},{"categories":["leetcode"],"content":"避开黑名单的随机数 力扣第 710 题「 黑名单中的随机数」 数组去重 力扣第 316 题「 去除重复字母」 同 第 1081 题「不同字符的最小子序列」 的解法是完全相同的 #其他 ","date":"2022-08-19","objectID":"/posts/tech/leetcode/array/:18:0","tags":["数组","leetcode"],"title":"算法-数组","uri":"/posts/tech/leetcode/array/"},{"categories":["leetcode"],"content":"有效的数独 力扣第 36 题 有效的数独 看每行、每列、每个9*9区块内，是否有重复的数字. 大多数的哈希表计数问题，都能转换为使用数组解决。 虽然时间复杂度一样，但哈希表的更新和查询复杂度为均摊 O(1)O(1)，而定长数组的的更新和查询复杂度则是严格 O(1)O(1)。 因此从执行效率上来说，数组要比哈希表快上不少。 class Solution { /** * 数组解法， * 从执行效率上来说，数组要比哈希表快上不少。 */ public boolean isValidSudoku(char[][] board) { boolean[][] row = new boolean[10][10]; boolean[][] col = new boolean[10][10]; //9*9区块 boolean[][] area = new boolean[10][10]; for (int i = 0; i \u003c 9; i++) { for (int j = 0; j \u003c 9; j++) { int c = board[i][j]; if (c == '.') { continue; } int u = c - '0'; int idx = i / 3 * 3 + j / 3; if (row[i][u] || col[j][u] || area[idx][u]) { return false; } row[i][u] = col[j][u] = area[idx][u] = true; } } return true; } /** * 哈希解法 * 大多数的哈希表计数问题，都能转换为使用数组解决。 */ public boolean isValidSudoku2(char[][] board) { Map\u003cInteger, Set\u003cInteger\u003e\u003e rowMap = new HashMap(); Map\u003cInteger, Set\u003cInteger\u003e\u003e cloumnMap = new HashMap(); //最小区块map Map\u003cInteger, Set\u003cInteger\u003e\u003e subMap = new HashMap(); //初始化定义 for (int i = 0; i \u003c 9; i++) { rowMap.put(i, new HashSet\u003c\u003e()); cloumnMap.put(i, new HashSet\u003c\u003e()); subMap.put(i, new HashSet\u003c\u003e()); } for (int i = 0; i \u003c board.length; i++) { for (int j = 0; j \u003c board[0].length; j++) { char c = board[i][j]; if (c == '.') { continue; } Integer v = c - '0'; Integer idx = i / 3 * 3 + j / 3; if (rowMap.get(i).contains(v) || cloumnMap.get(j).contains(v) || subMap.get(idx).contains(v)) { return false; } rowMap.get(i).add(v); cloumnMap.get(j).add(v); subMap.get(idx).add(v); } } return true; } } ","date":"2022-08-19","objectID":"/posts/tech/leetcode/array/:19:0","tags":["数组","leetcode"],"title":"算法-数组","uri":"/posts/tech/leetcode/array/"},{"categories":["leetcode"],"content":"多数元素-E 第 169 题 多数元素 给定一个大小为 n 的数组 nums ，返回其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n/2 ⌋ 的元素。 你可以假设数组是非空的，并且给定的数组总是存在多数元素。 class Solution { /** * 法1：比较 */ public int majorityElement(int[] nums) { int target = 0; int count = 0; for (int i = 0; i \u003c nums.length; i++) { if (count == 0) { target = nums[i]; } if (nums[i] == target) { count++; } else { count--; } } return target; } /** * 法2：sort后取值 */ public int majorityElement2(int[] nums) { Arrays.sort(nums); return nums[nums.length / 2]; } } ","date":"2022-08-19","objectID":"/posts/tech/leetcode/array/:20:0","tags":["数组","leetcode"],"title":"算法-数组","uri":"/posts/tech/leetcode/array/"},{"categories":["leetcode"],"content":"搜索二维矩阵 II-M 第 240 题 搜索二维矩阵 II 编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target 。该矩阵具有以下特性： 每行的元素从左到右升序排列。 每 列的元素从上到下升序排列。 class Solution { /** * 法1：Z 字形查找 * 从右上角开始， 向下-\u003e数字变大； 向左-\u003e数字变小； * 也可从左下角开始，只有两个方向可以做到一个变大，一个变小即可 */ public boolean searchMatrix(int[][] matrix, int target) { int width = matrix[0].length; int len = matrix.length; int i = 0, j = width - 1; while (i \u003c len \u0026\u0026 j \u003e= 0) { if (matrix[i][j] == target) { return true; } else if (matrix[i][j] \u003e target) { j--; } else if (matrix[i][j] \u003c target) { i++; } } return false; } /** * 法2：直接查找, 全遍历 */ public boolean searchMatrix2(int[][] matrix, int target) { for (int[] row : matrix) { for (int element : row) { if (element == target) { return true; } } } return false; } } ","date":"2022-08-19","objectID":"/posts/tech/leetcode/array/:21:0","tags":["数组","leetcode"],"title":"算法-数组","uri":"/posts/tech/leetcode/array/"},{"categories":["leetcode"],"content":"其他 ","date":"2022-08-19","objectID":"/posts/tech/leetcode/array/:22:0","tags":["数组","leetcode"],"title":"算法-数组","uri":"/posts/tech/leetcode/array/"},{"categories":["leetcode"],"content":"存在重复元素-E 217题 存在重复元素 给你一个整数数组 nums 。如果任一值在数组中出现 至少两次 ，返回 true ；如果数组中每个元素互不相同，返回 false 。 /** * 方法1：HashSet 解法 */ public boolean containsDuplicate1(int[] nums) { Set\u003cInteger\u003e set = new HashSet\u003cInteger\u003e(); for (int x : nums) { if (!set.add(x)) { return true; } } return false; } /** * 方法2：先排序，然后再比较相邻元素是否相等 */ public boolean containsDuplicate2(int[] nums) { Arrays.sort(nums); int i = 1; while (i \u003c nums.length) { if (nums[i] == nums[i - 1]) { return true; } } return false; } ","date":"2022-08-19","objectID":"/posts/tech/leetcode/array/:22:1","tags":["数组","leetcode"],"title":"算法-数组","uri":"/posts/tech/leetcode/array/"},{"categories":["leetcode"],"content":"除自身以外数组的乘积-M 第 238 题 除自身以外数组的乘积 给你一个整数数组nums，返回 数组answer，其中answer[i]等于nums中除nums[i]之外其余各元素的乘积。 题目数据 保证 数组nums之中任意元素的全部前缀元素和后缀的乘积都在 32 位 整数范围内。 请不要使用除法，且在O(n) 时间复杂度内完成此题。 class Solution { public int[] productExceptSelf(int[] nums) { int len = nums.length; // L 和 R 分别表示左右两侧的乘积列表 int[] leftValue = new int[len]; int[] rightValue = new int[len]; int[] result = new int[len]; // L[i] 为索引 i 左侧所有元素的乘积 // 对于索引为 '0' 的元素，因为左侧没有元素，所以 L[0] = 1 leftValue[0] = 1; for (int i = 1; i \u003c len; i++) { leftValue[i] = nums[i-1] * leftValue[i - 1]; } // R[i] 为索引 i 右侧所有元素的乘积 // 对于索引为 'length-1' 的元素，因为右侧没有元素，所以 R[length-1] = 1 rightValue[len-1] = 1; for (int i = len - 2; i \u003e= 0; i--) { rightValue[i] = nums[i + 1] * rightValue[i + 1]; } // 对于索引 i，除 nums[i] 之外其余各元素的乘积就是左侧所有元素的乘积乘以右侧所有元素的乘积 for (int i = 0; i \u003c len; i++) { result[i] = leftValue[i] * rightValue[i]; } return result; } } ","date":"2022-08-19","objectID":"/posts/tech/leetcode/array/:22:2","tags":["数组","leetcode"],"title":"算法-数组","uri":"/posts/tech/leetcode/array/"},{"categories":null,"content":"天行健，君子以自强不息 ","date":"2022-08-15","objectID":"/aboutme/:0:0","tags":null,"title":"关于","uri":"/aboutme/"},{"categories":null,"content":"古往 \u0026\u0026 今来 SYC在河南省的一个农村长大，在一个五线小县城的高中读书。高考那年全省考生近100万，当年本、专科总录取率不足30%， 意味着有70w左右的学生不能再继续学习深造，想想都是泪水；🙁 Syc grew up in a rural village in Henan province and studied in a high school in a small town. Almost 1 million students took college entrance examinations in Henan province at that time. The acceptance rate was less than 30 percent. It means that there was about 0.7 million students who can no longer continue their studies. That’s a sad thing. 古语云: 知识改变命运，《士兵突击》里王团长对许三多说的话：\"想要和得到中间还有两个字，那就是做到。你只有做到，才能够得到。\" Knowledge changes fate. In “Soldier Assault”, Captain Wang said to Xu Sanduo: “There are two words between wanting and getting, and that is to do. You can only get it if you do it.” 大学毕业后，先后在上海、杭州工作过，机缘巧合，经历过创业公司、中厂和互联网大厂，横跨供应链、金融、互联网电商等行业。 My major is Computer science and technology. after graduating from university, I worked in Shanghai and Hangzhou. I have experience in start-up companies and medium and large companies. I have strong experience in the Internet e-commerce industry. 18年加入AL，作为一名技术同学，在国际化电商板块搬砖，为国际化业务贡献自己的一份力量! 😀 I joined AL as a senior development engineer in 2018 and contributed to the international business. ","date":"2022-08-15","objectID":"/aboutme/:1:0","tags":null,"title":"关于","uri":"/aboutme/"},{"categories":null,"content":"技能 \u0026\u0026 爱好 户外、摄影📷、爬山、跑步🏃‍♂️、羽毛球🏸、撸铁 Outdoors, photography, mountain climbing, running, badminton, fitness. 读书📚、纪录片 Reading 刷剧（快进式） ","date":"2022-08-15","objectID":"/aboutme/:2:0","tags":null,"title":"关于","uri":"/aboutme/"},{"categories":null,"content":"友情联系 email: michael_songs@163.com ","date":"2022-08-15","objectID":"/aboutme/:3:0","tags":null,"title":"关于","uri":"/aboutme/"},{"categories":["生活"],"content":"8.6号，机缘巧合，今天来到杭州花开岭公益基地，“免费午餐”、“微博打拐发起人” 邓飞 老师在这里分享了他的真实经历。 邓飞老师使用微博、抖音等社交传媒渠道，充分发挥使用这些app且有良知的人，结合众人的力量，共同寻找丢失儿童，拯救了多个破碎的家庭； ","date":"2022-08-06","objectID":"/posts/life/huakailing/:0:0","tags":["公益"],"title":"花开岭公益行","uri":"/posts/life/huakailing/"},{"categories":["生活"],"content":" 今年年初就计划着去新疆旅行，刚好六月份看到朋友发的帖子，大家一拍即合，开团成行；刚好借此计划给自己放一个长假， 把自己从持续多年的忙碌状态中抽离出来，利用这几天时间，来一场心灵的放松、灵魂的洗礼和体力的马拉松。来阿里四年，给自己休的第一次长假。 ","date":"2022-07-22","objectID":"/posts/travel/xinjiang/:0:0","tags":["新疆"],"title":"新疆旅行-北疆","uri":"/posts/travel/xinjiang/"},{"categories":["生活"],"content":"行程计划 2022.7.8 - 2022.7.17 7.8： 杭州出发； 7.9： 尹宁 伊力特酒厂、六星街、伊犁河；（美食） 7.10：尹宁7点发车（1.5小时车程）、紫仙镇薰衣草庄园（1小时）、（1小时车程）果子沟（1.5小时）、午餐、赛里木湖（落日）（9小时左右）、（1.5小时车程）住清水河镇（预计12点多了）； 7.11：清水河镇8点出发附近看免费薰衣草（1小时），（6.5小时车程）前往夏塔旅游风景区，进景区入住，有时间可以游玩下（星空）； 7.12：6点早起，早餐后徒步夏塔古道（20公里左右，原路往返，也许还有日出）、17点左右出景区晚饭、（3小时）驱车住特克斯、八卦城； 7.13：早起，（8点前）喀拉峻（8小时）、阔克苏大峡谷（4h）、（4小时车程）住那拉提； 7.14：（8点）那拉提风景区（一整天），住那拉提； 7.15：坐车到巴音（2.5小时），巴音天鹅湖、九曲十八弯（落日）、住巴音；（大巴车返回伊宁） 7.16：换5座或7座车，完整独库公路+s101国防公路（百里丹霞，走一段，不然吃不消），到乌鲁木齐； 7.17：返杭； ","date":"2022-07-22","objectID":"/posts/travel/xinjiang/:1:0","tags":["新疆"],"title":"新疆旅行-北疆","uri":"/posts/travel/xinjiang/"},{"categories":["生活"],"content":"DAY1 [周五] 2022.7.8, 头天晚上和同事一起吃夜宵到凌晨一点，聊得很嗨，晚上回家后又解决几个工作问题，本打算熬下夜直接去机场，谁知凌晨两点多，收到航空公司航班延迟起飞的信息， 果断睡觉； 早上起床后，收拾行李，刚好赶上早高峰，预估打车的话会堵车，测算地铁到机场的站总数后（地铁时间相对能准确预测），果断选择做地铁去机场； 最终一个半小时准时到达机场，和小伙伴汇合，完美; 11:55起飞，14:55到达兰州中川机场，机场吃了碗拉州拉面，本以为到达兰州本土，味道会有些不一样，结果证明期望过高，味道可能还不如个别面馆； 航班原计划19:35起飞，上飞机后，因为天气原因，硬生生拖到20:45才起飞（小插曲，上飞机后，有些累，就立马闭眼补觉，后来醒了看了下外面，哇塞，落地了，这么快，爽！； 然后在停顿了几秒，懵懵的看了下周围，脑袋瞬间清晰，瓦特… 这都一觉睡醒了，飞机还没起飞！！！），最终23:50左右到达伊宁。 目前还属于疫情管控时期，到新疆前需要提前申报行程，不然有可能落地后被原地劝返； 今天的时间基本全花在路途中。 凌晨两点吃晚饭； ","date":"2022-07-22","objectID":"/posts/travel/xinjiang/:2:0","tags":["新疆"],"title":"新疆旅行-北疆","uri":"/posts/travel/xinjiang/"},{"categories":["生活"],"content":"DAY2[周六] 今日安排：伊力特酒厂、六星街、伊犁河、喀赞其民宿旅游区。 早餐七点起床，吃早餐； 借助花姐独特的人脉关系，有幸拜访伊力特酒厂，了解到酒厂的历史发展轨迹，由几代人共同的心血才铸就而成，心中五味杂陈。品尝了红冰、白冰葡萄酒，酸甜可口，让人垂涎三尺。 了解到了北纬45°生命线，独特的地理气候，最终生长出优质的瓜果粮食。品尝了内部迎宾特供伊力特45°白酒，味道纯正，不辛辣，后劲也不大，超出预期；午饭吃了羊肉包、羊肉，没有疝气，味道鲜美，怒赞！ 在六星街，看到新疆本土大叔悠闲的用手风琴演奏本土轻音乐，音调轻缓优美，让人瞬间放松，忘记一切凡尘琐事，享受生活。 六星街-公路咖啡 自东向西流的伊犁河，以及晚上九点悬挂半空的大太阳. （以东部地区同学对东八区的时间理解，在这里有些颠覆认知） 伊犁河 ","date":"2022-07-22","objectID":"/posts/travel/xinjiang/:3:0","tags":["新疆"],"title":"新疆旅行-北疆","uri":"/posts/travel/xinjiang/"},{"categories":["生活"],"content":"DAY3 [周日] 今日安排：紫仙镇薰衣草庄园、果子沟、赛里木湖。 凌晨2点睡觉，早晨7点吃早餐； 7月中薰衣草已经花谢，薰衣草庄园里并没有看到成片的花海，听当地人说，最好6月中旬来。 果子沟全长4.4千米，大桥长700米。 塔里木湖【强烈推荐去！】 大西洋的最后一滴眼泪，让人沉醉； 围着赛里木湖转了一圈，感受到它的独特，海天一色的蓝，一望无际的湖面，让人内心平静； 坐在长廊中间，眺望眼前的赛里木湖，心无杂念，凡尘种种，皆为过往；远处挺拔的雪山和蓝天白云，造就出了当地人民心中的“净海”。 ","date":"2022-07-22","objectID":"/posts/travel/xinjiang/:4:0","tags":["新疆"],"title":"新疆旅行-北疆","uri":"/posts/travel/xinjiang/"},{"categories":["生活"],"content":"DAY4[周一] 今日安排：油菜花田、入住夏塔旅游风景区； 早7点起床，“温州包子\"早餐店吃早点； 8点出发，去夏塔旅游风景区途中，遇到油菜花田，犹豫天气不太好，不好出片，如果天气不错，效果会很棒； 17点到达夏塔景区，景区大门口买票后，分批坐景区的接驳车，从大门口开车40分钟，到达景区内住宿地，入住小木屋旅馆，晚上是真的冷，好在有电热毯，相对舒服的睡了半宿。 ","date":"2022-07-22","objectID":"/posts/travel/xinjiang/:5:0","tags":["新疆"],"title":"新疆旅行-北疆","uri":"/posts/travel/xinjiang/"},{"categories":["生活"],"content":"DAY5[周二] 今日安排：徒步夏塔古道（20公里左右）、特克斯、八卦城； 早上五点半起床，六点出发徒步，目的地雪山； 14:40左右坐上下山的景区接驳车，17点左右离开景区吃晚饭、驱车（3小时左右距离）到 特克斯.八卦城，入住酒店； ","date":"2022-07-22","objectID":"/posts/travel/xinjiang/:6:0","tags":["新疆"],"title":"新疆旅行-北疆","uri":"/posts/travel/xinjiang/"},{"categories":["生活"],"content":"DAY6[周三] 今日安排：喀拉峻草原、阔克苏大峡谷（4h） 喀拉峻草原\u0026\u0026阔克苏大峡谷，高山草原(7月这里的草，有些泛黄)，视野辽阔，山风吹过很冷，不过可以抱只小羊，相当暖和。 ","date":"2022-07-22","objectID":"/posts/travel/xinjiang/:7:0","tags":["新疆"],"title":"新疆旅行-北疆","uri":"/posts/travel/xinjiang/"},{"categories":["生活"],"content":"DAY7[周四] 今日安排：那拉提风景区 ","date":"2022-07-22","objectID":"/posts/travel/xinjiang/:8:0","tags":["新疆"],"title":"新疆旅行-北疆","uri":"/posts/travel/xinjiang/"},{"categories":["生活"],"content":"DAY8[周五] 今日安排：巴音天鹅湖、九曲十八弯（落日） 坐车到巴音（2.5小时），巴音天鹅湖、九曲十八弯（落日）、住巴音；（大巴车返回伊宁） 天鹅湖里有几只天鹅，但湖水味道呛人，过敏者慎入； 九曲十八弯，如果遇到落日，会更美；这里的山风吹得让人由内而外的发冷，山上有个小超市，买了包泡面，店主赠送开水，价钱合理，吃饱取暖，完美； ","date":"2022-07-22","objectID":"/posts/travel/xinjiang/:9:0","tags":["新疆"],"title":"新疆旅行-北疆","uri":"/posts/travel/xinjiang/"},{"categories":["生活"],"content":"DAY9[周六] 今日安排：乘7座车游览独库公路+s101国防公路，到乌鲁木齐 路上偶遇彩虹，有点超出预期； 一路上听说会经历春夏秋冬，途中遇到的几个小雪山，和预期中的差距蛮大，不过能近距离看到，也算不错。整条独库路是有些绕，不建议新手自驾； 独库公路-雪山 独库公路 ","date":"2022-07-22","objectID":"/posts/travel/xinjiang/:10:0","tags":["新疆"],"title":"新疆旅行-北疆","uri":"/posts/travel/xinjiang/"},{"categories":["生活"],"content":"DAY10[周日] 因为预定酒店比较找，酒店有赠送整点接送服务，所以早晨6点半起床，7点出门，7点一刻到机场，机场吃了点八宝粥，8:25乌鲁木齐起飞，中途郑州中转1小时，然后14：55到达杭州萧山。 ","date":"2022-07-22","objectID":"/posts/travel/xinjiang/:11:0","tags":["新疆"],"title":"新疆旅行-北疆","uri":"/posts/travel/xinjiang/"},{"categories":["生活"],"content":"费用 去新机票：2217 返杭机票：2225 酒店+交通：3500 部分景点门票: 132+145+132+115+150+135 其他开销另算 上述小计：8751； ","date":"2022-07-22","objectID":"/posts/travel/xinjiang/:12:0","tags":["新疆"],"title":"新疆旅行-北疆","uri":"/posts/travel/xinjiang/"},{"categories":["读书笔记"],"content":"个人履历 纳纳瓦尔 •拉维坎特经历表 1974年，出生于印度德里 1983年，9岁，从印度新德里搬到美国纽约皇后区 1988年，14岁，就读于史岱文森高中 1995年，21岁，从达特茅斯大学毕业（学习计算机科学和经济学） 1999年，25岁，成为 Epinions 创始人、首席执行官 2001年，27岁，成为风投机构 August Capital 创业合伙人 2003年，29岁，成为分类广告平台 Vast.com 创始人 2005年，31岁，在硅谷被称为“放射性泥浆” 2007年，33岁，创立小型风险投资基金 Hit Forge，最初设想是用作艀化器 2007年，33岁，创立 VentureHacks 博客 2010年，36岁，创立AngelList 2010年，36岁，投资优步 2012年，38岁，游说国会通过 《就业法案》 2018年，44岁，获评 “年度天使投资人” ","date":"2022-07-05","objectID":"/posts/book/naval/:1:0","tags":["读书笔记"],"title":"[读书笔记] 《纳瓦尔宝典》","uri":"/posts/book/naval/"},{"categories":["读书笔记"],"content":"语录 只要想做，办法总是有的。 坐而言，不如起而行； 人生中真正重要的道理不需要太多。 如果社会可以培训你，那么社会也可以培训他人来取代你。大家都能学会的东西是不可能让你致富的。凡是可以批量化培训的技能都是能够被雇佣的技能。只有你自己学到的东西，才是属于你独有的能力，才有可能让你成功。 同样是读书，有人指望书本能告诉他怎么开始怎么结束，所以总是失望（或者被骗）。而有人从书中获得启发，自己思考，自己实践，于是对书充满感激。从同一个教室里走出的学生天差地别，就是因为有人等着被打造，有人是自己在探索。 最重要的是，要在重大决定上花更多时间。人生早期有三个重大决定：在哪里生活，和谁在一起，从事什么职业。 阅读数学、科学和哲学领域的经典作品。 学会销售，学会构建，两技傍身，势不可当。 赚钱不是一件想做就能做的事情，而是一门需要学习的技能。 依靠出租时间是不可能致富的。你必须拥有股权（企业的部分所有权），才能实现财务自由。 工作时要拼尽全力，毫无保留。不过，共事的人和工作的内容比努力程度更重要。 在自己选择的职业领域里做到全球顶尖。不断重新定义自己的事业，直到理想成为现实。 ","date":"2022-07-05","objectID":"/posts/book/naval/:2:0","tags":["读书笔记"],"title":"[读书笔记] 《纳瓦尔宝典》","uri":"/posts/book/naval/"},{"categories":["tech"],"content":"方式1 使用 codeinword 在线工具，选择code对应的语言后，生成copy，粘贴到word中即可。 方式2 使用 Visual Studio code. VSCode 支持复制后直接粘贴到word即是着色后的代码高亮的效果。 注意： 用vscode 写完代码后，一定要保存为指定的格式文件(如.java)； 复制vscode 代码到word，完美。 因为微软自家的软件所用的字符格式是相通的，比如说你写工作邮件，想要从word 或者excel 复制内容到chrome 网页版的邮箱里，这时候你可能发现格式丢失，如果使用微软自家浏览器edge 或者 ie 就不会有这个问题。 ","date":"2022-06-21","objectID":"/posts/tech/tools/wordcode/:0:0","tags":["tools"],"title":"Word中如何插入代码块？","uri":"/posts/tech/tools/wordcode/"},{"categories":["Java"],"content":" 一、基础篇 网络基础 TCP三次握手 1、OSI与TCP/IP 模型 2、常见网络服务分层 3、TCP与UDP区别及场景 4、TCP滑动窗口，拥塞控制 5、TCP粘包原因和解决方法 6、TCP、UDP报文格式 HTTP协议 1、HTTP协议1.0_1.1_2.0 2、HTTP与HTTPS之间的区别 3、Get和Post请求区别 4、HTTP常见响应状态码 5、重定向和转发区别 6、Cookie和Session区别。 浏览器输入URL过程 操作系统基础 进程和线程的区别 1、进程间通信方式IPC 2、用户态和核心态 3、操作系统的进程空间 操作系统内存管理 1、页面置换算法FIFO、LRU 2、死锁条件、解决方式。 Java基础 面向对象三大特性 1、Java与C++区别 2、多态实现原理 3、static和final关键字 4、抽象类和接口 5、泛型以及泛型擦除 6、反射原理以及使用场景 7、Java异常体系 数据结构 1、ArrayList和LinkedList 2、List遍历快速和安全失败 3、详细介绍HashMap **4、ConcurrentHashMap ** 5、序列化和反序列化 6、String 设计模式与原则 1、单例模式 2、工厂模式 3、抽象工厂模式 面试题 构造方法 初始化块 This 重写和重载的区别 Object类方法 基本数据类型和包装类 二、JVM篇 JVM内存划分 1、JVM运行时数据区域 2、堆内存分配策略 3、创建一个对象的步骤 4、对象引用 JVM类加载过程 1、双亲委派机制 2、tomcat的类加载机制 JVM垃圾回收 1、存活算法和两次标记过程 2、垃圾回收算法 MinorGC、MajorGC、FullGC 3、垃圾收集器 4、配置垃圾收集器 4、JVM性能调优 5、JDK新特性 线上故障排查 1、硬件故障排查 2、报表异常 | JVM调优 3、大屏异常 | JUC调优 4、接口延迟 | SWAP调优 5、内存溢出 | Cache调优 6：CPU飙高 | 死循环 三、多线程篇 线程调度 1、线程状态 2、线程状态切换 3、阻塞唤醒过程 4、wait和sleep区别 5、创建线程方式 线程池 1、线程池构造函数 2、线程处理任务过程： 3、线程拒绝策略 4、Execuors类实现线程池 5、线程池大小设置 线程安全 1、乐观锁，CAS思想 2、synchronized底层实现 3、ReenTrantLock底层实现 4、公平锁和非公平锁区别 5、使用层面锁优化 6、系统层面锁优化 7、ThreadLocal原理 8、HashMap线程安全 9、String不可变原因 内存模型 1、volatile底层实现 2、AQS思想 3、happens-before 四、MySQL篇 WhyMysql？ 海量Aerospike 图谱Neo4j 文档MongoDB 云存储 FastDFS 事务 1、事务4大特性 2、事务隔离级别 3、默认隔离级别-RR 4、RR和RC使用场景 5、行锁，表锁，意向锁 6、MVCC多版本并发控制 索引 1、Innodb和Myisam引擎 2、哈希索引 3、B+树索引 4、创建索引 5、聚簇索引和非聚簇索引 6、最左前缀问题 SQL查询 1、SQL语句的执行过程 2、回表查询和覆盖索引 3、Explain及优化 4、JOIN查询 集群 1、主从复制过程 2、数据一致性问题 3、集群架构 4、故障转移和恢复 面试题 分库分表 如何进行分库分表 如何将老数据进行迁移 系统性能的评估及扩容 如何生成自增的id主键 线上故障及优化 更新失败 | 主从同步延时 应用崩溃 | 分库分表优化 查询异常 | SQL 调优 五、Redis篇 WhyRedis 1、简单高效 2、Memcache 3、Tair 4、Guava 5、EVCache 6、ETCD Redis底层 1、redis数据类型 2、相关API 3、redis底层结构 4、Zset底层实现 Redis可用性 1、redis持久化 2、redis事务 3、redis失效策略 4、redis读写模式 5、多级缓存 Redis七大经典问题 1、缓存雪崩 2、缓存穿透 3、缓存击穿 4、数据不一致 5、数据并发竞争 6、热点key问题 7、BigKey问题 Redis分区容错 1、redis数据分区 2、主从模式=简单 3、哨兵模式=读多 4、集群模式=写多 5、分布式锁 6、redis心跳检测 Redis实战 1、Redis优化 2、Redis热升级 六、Kafka篇 Why kafka What Kafka How Kafka 生产消费基本流程 一致性 可用性 面试题 线上问题rebalance ZooKeeper 的作用 Replica副本的作用 为什么不支持读写分离? 如何防止重复消费 如何保证数据不会丢失 如何保证顺序消费 【线上】如何解决积压消费 如何避免消息积压 如何设计消息队列 七、Spring篇 设计思想\u0026Beans 1、IOC 控制反转 2、AOP 动态代理 3、Bean生命周期 4、Bean作用域 5、循环依赖 Spring注解 1、@SpringBoot 2、@SpringMVC 3、@SpringMybatis 4、@Transactional Spring源码阅读 1、Spring中的设计模式 八、SpringCloud篇 Why SpringCloud Spring Boot GateWay / Zuul Eureka / Zookeeper Feign / Ribbon Hystrix / Sentinel Config / Nacos Bus / Stream Sleuth / Zipkin 安全认证 灰度发布 多版本隔离 各组件调优 九、分布式篇 发展历程 CAP 一致性 XA方案 Paxos算法 ZAB算法 Raft算法 数据库和Redis的一致性 可用性 心跳检测 多机房实时热备 分区容错性 日志复制 主备（Master-Slave） 互备（Active-Active） 集群（Cluster）模式 分布式事务 XA方案 TCC方案 Saga方案 本地消息表（eBay） MQ最终一致性 最大努力通知方案（订单 -\u003e 积分） 面试题 分布式Session实现方案 一、基础篇 ","date":"2022-06-03","objectID":"/posts/tech/interview/interview-nw-java/:0:0","tags":["Java学习随笔","interview"],"title":"内部-design-1","uri":"/posts/tech/interview/interview-nw-java/"},{"categories":["Java"],"content":"网络基础 ","date":"2022-06-03","objectID":"/posts/tech/interview/interview-nw-java/:1:0","tags":["Java学习随笔","interview"],"title":"内部-design-1","uri":"/posts/tech/interview/interview-nw-java/"},{"categories":["Java"],"content":"TCP三次握手 ​ 三次握手过程： ​ 客户端——发送带有SYN标志的数据包——服务端 一次握手 Client进入syn_sent状态 ​ 服务端——发送带有SYN/ACK标志的数据包——客户端 二次握手 服务端进入syn_rcvd ​ 客户端——发送带有ACK标志的数据包——服务端 三次握手 连接就进入Established状态 ​ 为什么三次： ​ 主要是为了建立可靠的通信信道，保证客户端与服务端同时具备发送、接收数据的能力 ​ 为什么两次不行？ ​ 1、防止已失效的请求报文又传送到了服务端，建立了多余的链接，浪费资源 ​ 2、 两次握手只能保证单向连接是畅通的。（为了实现可靠数据传输， TCP 协议的通信双方， 都必须维 护一个序列号， 以标识发送出去的数据包中， 哪些是已经被对方收到的。 三次握手的过程即是通信双方 相互告知序列号起始值， 并确认对方已经收到了序列号起始值的必经步骤；如果只是两次握手， 至多只有连接发起方的起始序列号能被确认， 另一方选择的序列号则得不到确认） **TCP四次挥手过程 ** 四次挥手过程： ​ 客户端——发送带有FIN标志的数据包——服务端，关闭与服务端的连接 ，客户端进入FIN-WAIT-1状态 ​ 服务端收到这个 FIN，它发回⼀ 个 ACK，确认序号为收到的序号加1，服务端就进入了CLOSE-WAIT状态 ​ 服务端——发送⼀个FIN数据包——客户端，关闭与客户端的连接，客户端就进入FIN-WAIT-2状态 ​ 客户端收到这个 FIN，发回 ACK 报⽂确认，并将确认序号设置为收到序号加1，TIME-WAIT状态 为什么四次： ​ 因为需要确保客户端与服务端的数据能够完成传输。 CLOSE-WAIT： ​ 这种状态的含义其实是表示在等待关闭 TIME-WAIT： ​ 为了解决网络的丢包和网络不稳定所带来的其他问题，确保连接方能在时间范围内，关闭自己的连接 如何查看TIME-WAIT状态的链接数量？ ​ netstat -an |grep TIME_WAIT|wc -l 查看连接数等待time_wait状态连接数 为什么会TIME-WAIT过多？解决方法是怎样的？ ​ 可能原因： 高并发短连接的TCP服务器上，当服务器处理完请求后立刻按照主动正常关闭连接 ​ **解决：**负载均衡服务器；Web服务器首先关闭来自负载均衡服务器的连接 1、OSI与TCP/IP 模型 ​ OSI七层：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层 ​ TCP/IP五层：物理层、数据链路层、网络层、传输层、应用层 2、常见网络服务分层 ​ 应用层：HTTP、SMTP、DNS、FTP ​ 传输层：TCP 、UDP ​ 网络层：ICMP 、IP、路由器、防火墙 ​ 数据链路层：网卡、网桥、交换机 ​ 物理层：中继器、集线器 3、TCP与UDP区别及场景 | 类型 | 特点 | 性能 | 应用过场景 | 首部字节 | | | —- | :————————: | :——————–: | :————–: | :——: | —- | | TCP | 面向连接、可靠、字节流 | 传输效率慢、所需资源多 | 文件、邮件传输 | 20-60 | | | UDP | 无连接、不可靠、数据报文段 | 传输效率快、所需资源少 | 语音、视频、直播 | 8个字节 | | ​ **基于TCP的协议：**HTTP、FTP、SMTP ​ **基于UDP的协议：**RIP、DNS、SNMP 4、TCP滑动窗口，拥塞控制 ​ **TCP通过：**应用数据分割、对数据包进行编号、校验和、流量控制、拥塞控制、超时重传等措施保证数据的可靠传输； ​ **拥塞控制目的：**为了防止过多的数据注入到网络中，避免网络中的路由器、链路过载 ​ **拥塞控制过程：**TCP维护一个拥塞窗口，该窗口随着网络拥塞程度动态变化，通过慢开始、拥塞避免等算法减少网络拥塞的发生。 5、TCP粘包原因和解决方法 ​ TCP粘包是指：发送方发送的若干包数据到接收方接收时粘成一包 ​ 发送方原因： ​ TCP默认使用Nagle算法（主要作用：减少网络中报文段的数量）： ​ 收集多个小分组，在一个确认到来时一起发送、导致发送方可能会出现粘包问题 ​ 接收方原因： ​ TCP将接收到的数据包保存在接收缓存里，如果TCP接收数据包到缓存的速度大于应用程序从缓存中读取数据包的速度，多个包就会被缓存，应用程序就有可能读取到多个首尾相接粘到一起的包。 ​ 解决粘包问题： ​ 最本质原因在与接收对等方无法分辨消息与消息之间的边界在哪，通过使用某种方案给出边界，例如： 发送定长包。每个消息的大小都是一样的，接收方只要累计接收数据，直到数据等于一个定长的数值就将它作为一个消息。 包尾加上\\r\\n标记。FTP协议正是这么做的。但问题在于如果数据正文中也含有\\r\\n，则会误判为消息的边界。 包头加上包体长度。包头是定长的4个字节，说明了包体的长度。接收对等方先接收包体长度，依据包体长度来接收包体。 6、TCP、UDP报文格式 ​ TCP报文格式： ​ ​ 源端口号和目的端口号： ​ 用于寻找发端和收端应用进程。这两个值加上ip首部源端ip地址和目的端ip地址唯一确定一个tcp连接。 ​ 序号字段： ​ 序号用来标识从T C P发端向T C P收端发送的数据字节流，它表示在这个报文段中的的第一个数据字节。如果将字节流看作在两个应用程序间的单向流动，则 T C P用序号对每个字节进行计数。序号是32 bit的无符号数，序号到达 2^32-1后又从0开始。 当建立一个新的连接时，SYN标志变1。序号字段包含由这个主机选择的该连接的初始序号ISN（Initial Sequence Number）。该主机要发送数据的第一个字节序号为这个ISN加1，因为SYN标志消耗了一个序号 ​ 确认序号： ​ 既然每个传输的字节都被计数，确认序号包含发送确认的一端所期望收到的下一个序号。因此，确认序号应当是上次已成功收到数据字节序号加 1。只有ACK标志为 1时确认序号字段才有效。发送ACK无需任何代价，因为 32 bit的确认序号字段和A C K标志一样，总是T C P首部的一部分。因此，我们看到一旦一个连接建立起来，这个字段总是被设置， ACK标志也总是被设置为1。TCP为应用层提供全双工服务。这意味数据能在两个方向上独立地进行传输。因此，连接的每一端必须保持每个方向上的传输数据序号。 ​ 首都长度： ​ 首部长度给出首部中 32 bit字的数目。需要这个值是因为任选字段的长度是可变的。这个字段占4 bit，因此T C P最多有6 0字节的首部。然而，没有任选字段，正常的长度是 2 0字节。 ​ 标志字段：在T C P首部中有 6个标志比特。它们中的多个可同时被设置为1. URG紧急指针（u rgent pointer）有效 ACK确认序号有效。 PSH接收方应该尽快将这个报文段交给应用层。 RST重建连接。 SYN同步序号用来发起一个连接。这个标志和下一个标志将在第 1 8章介绍。 FIN发端完成发送任务。 ​ 窗口大小： ​ T C P的流量控制由连接的每一端通过声明的窗口大小来提供。窗口大小为字节数，起始于确认序号字段指明的值，这个值是接收端期望接收的字节。窗口大小是一个 16 bit字段，因而窗口大小最大为 65535字节。 ​ 检验和： ​ 检验和覆盖了整个的 T C P报文段：T C P首部和T C P数据。这是一个强制性的字段，一定是由发端计算和存储，并由收端进行验证。 ​ 紧急指针： ​ 只有当URG标志置1时紧急指针才有效。紧急指针是一个正的偏移量，和序号字段中的值相加表示紧急数据最后一个字节的序号。 T C P的紧急方式是发送端向另一端发送紧急数据的一种方式。 ​ 选项： ​ 最常见的可选字段是最长报文大小，又称为 MSS (Maximum Segment Size)。每个连接方通常都在通信的第一个报文段（为建立连接而设置 S Y N标志的那个段）中指明这个选项。它指明本端所能接收的最大长度的报文段。 ​ UDP报文格式： ​ ​ 端口号： ​ 用来表示发送和接受进程。由于 I P层已经把I P数据报分配给T C P或U D P（根据I P首部中协议字段值），因此T C P端口号由T C P来查看，而 U D P端口号由UDP来查看。T C P端口号与UDP端口号是相互独立的。 ​ 长度： ​ UDP长度字段指的是UDP首部和UDP数据的字节长度。该字段的最小值为 8字节（发送一份0字节的UDP数据报是 O K）。 ​ 检验和： ​ UDP检验和是一个端到端的检验和。它由发送端计算，然后由接收端验证。其目的是为了发现UDP首部和数据在发送端到接收端之间发生的任何改动。 ​ **IP报文格式：**普通的IP首部长为20个字节，除非含有可选项字段。 ​ ​ 4位版本： ​ 目前协议版本号是4，因此IP有时也称作IPV4. ​ 4位首部长度： ​ 首部长度指的是首部占32bit字的数目，包括任何选项。由于它是一个4比特字段，因此首部长度最长为60个字节。 ​ 服务类型（TOS）： ​ 服务类型字段包括一个3bit的优先权字段（现在已经被忽略），4bit的TOS子字段和1bit未用位必须置0。4bit的TOS分别代表：最小时延，最大吞吐量，最高可靠性和最小费用。4bit中只能置其中1比特。如果所有4bit均为0，那么就意味着是一般服务。 ​ 总长度： ​ 总长度字段是指整个IP数据报的长度，以字节为单位。利用首部","date":"2022-06-03","objectID":"/posts/tech/interview/interview-nw-java/:1:1","tags":["Java学习随笔","interview"],"title":"内部-design-1","uri":"/posts/tech/interview/interview-nw-java/"},{"categories":["Java"],"content":"HTTP协议 1、HTTP协议1.0_1.1_2.0 ​ **HTTP1.0：**服务器处理完成后立即断开TCP连接（无连接），服务器不跟踪每个客户端也不记录过去的请求（无状态） ​ HTTP1.1：KeepAlived长连接避免了连接建立和释放的开销；通过Content-Length来判断当前请求数据是否已经全部接受（有状态） ​ HTTP2.0：引入二进制数据帧和流的概念，其中帧对数据进行顺序标识；因为有了序列，服务器可以并行的传输数据。 ​ http1.0和http1.1的主要区别如下： ​ 1、缓存处理：1.1添加更多的缓存控制策略（如：Entity tag，If-Match） ​ 2、网络连接的优化：1.1支持断点续传 ​ 3、错误状态码的增多：1.1新增了24个错误状态响应码，丰富的错误码更加明确各个状态 ​ 4、Host头处理：支持Host头域，不在以IP为请求方标志 ​ 5、长连接：减少了建立和关闭连接的消耗和延迟。 ​ http1.1和http2.0的主要区别： ​ 1、新的传输格式：2.0使用二进制格式，1.0依然使用基于文本格式 ​ 2、多路复用：连接共享，不同的request可以使用同一个连接传输（最后根据每个request上的id号组合成正常的请求） ​ 3、header压缩：由于1.X中header带有大量的信息，并且得重复传输，2.0使用encoder来减少需要传输的hearder大小 ​ 4、服务端推送：同google的SPDUY（1.0的一种升级）一样 2、HTTP与HTTPS之间的区别 ​ HTTP与HTTPS之间的区别： | HTTP | HTTPS | | :—————————-: | :————————————–: | | 默认端口80 | HTTPS默认使用端口443 | | 明文传输、数据未加密、安全性差 | 传输过程ssl加密、安全性较好 | | 响应速度快、消耗资源少 | 响应速度较慢、消耗资源多、需要用到CA证书 | ​ HTTPS链接建立的过程： ​ 1.首先客户端先给服务器发送一个请求 ​ 2.服务器发送一个SSL证书给客户端，内容包括：证书的发布机构、有效期、所有者、签名以及公钥 ​ 3.客户端对发来的公钥进行真伪校验，校验为真则使用公钥对对称加密算法以及对称密钥进行加密 ​ 4.服务器端使用私钥进行解密并使用对称密钥加密确认信息发送给客户端 ​ 5.随后客户端和服务端就使用对称密钥进行信息传输 ​ 对称加密算法： ​ 双方持有相同的密钥，且加密速度快，典型对称加密算法：DES、AES ​ 非对称加密算法： ​ 密钥成对出现（私钥、公钥），私钥只有自己知道，不在网络中传输；而公钥可以公开。相比对称加密速度较慢，典型的非对称加密算法有：RSA、DSA 3、Get和Post请求区别 HTTP请求： | 方法 | 描述 | | :—— | ———————————————————— | | GET | 向特定资源发送请求，查询数据，并返回实体 | | POST | 向指定资源提交数据进行处理请求，可能会导致新的资源建立、已有资源修改 | | PUT | 向服务器上传新的内容 | | HEAD | 类似GET请求，返回的响应中没有具体的内容，用于获取报头 | | DELETE | 请求服务器删除指定标识的资源 | | OPTIONS | 可以用来向服务器发送请求来测试服务器的功能性 | | TRACE | 回显服务器收到的请求，用于测试或诊断 | | CONNECT | HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器 | get和Post区别： | | GET | POST | | ——– | ———————————————————— | ———————————————————- | | 可见性 | 数据在URL中对所有人可见 | 数据不会显示在URL中 | | 安全性 | 与post相比，get的安全性较差，因为所发送的数据是URL的一部分 | 安全，因为参数不会被保存在浏览器历史或web服务器日志中 | | 数据长度 | 受限制，最长2kb | 无限制 | | 编码类型 | application/x-www-form-urlencoded | multipart/form-data | | 缓存 | 能被缓存 | 不能被缓存 | | | | | 4、HTTP常见响应状态码 ​ 100：Continue — 继续。客户端应继续其请求。 ​ 200：OK — 请求成功。一般用于GET与POST请求。 ​ 301：Moved Permanently — 永久重定向。 ​ 302：Found — 暂时重定向。 ​ 400：Bad Request — 客户端请求的语法错误，服务器无法理解。 ​ 403：Forbideen — 服务器理解请求客户端的请求，但是拒绝执行此请求。 ​ 404：Not Found — 服务器无法根据客户端的请求找到资源（网页）。 ​ 500：Internal Server Error — 服务器内部错误，无法完成请求。 ​ 502：Bad Gateway — 作为网关或者代理服务器尝试执行请求时，从远程服务器接收到了无效的响应。 5、重定向和转发区别 ​ 重定向：redirect： ​ 地址栏发生变化 ​ 重定向可以访问其他站点（服务器）的资源 ​ 重定向是两次请求。不能使用request对象来共享数据 ​ 转发：forward： ​ 转发地址栏路径不变 ​ 转发只能访问当前服务器下的资源 ​ 转发是一次请求，可以使用request对象共享数据 6、Cookie和Session区别。 ​ Cookie 和 Session都是用来跟踪浏览器用户身份的会话方式，但两者有所区别： ​ Cookie 数据保存在客户端(浏览器端)，Session 数据保存在服务器端。 ​ cookie不是很安全，别人可以分析存放在本地的COOKIE并进行欺骗,考虑到安全应当使用session。 ​ Cookie ⼀般⽤来保存⽤户信息，Session 的主要作⽤就是通过服务端记录⽤户的状态 ","date":"2022-06-03","objectID":"/posts/tech/interview/interview-nw-java/:1:2","tags":["Java学习随笔","interview"],"title":"内部-design-1","uri":"/posts/tech/interview/interview-nw-java/"},{"categories":["Java"],"content":"浏览器输入URL过程 ​ **过程：**DNS解析、TCP连接、发送HTTP请求、服务器处理请求并返回HTTP报文、浏览器渲染、结束 | 过程 | 使用的协议 | | ———————————————————— | ——————— | | 1、浏览器查找域名DNS的IP地址DNS查找过程（浏览器缓存、路由器缓存、DNS缓存） | DNS：获取域名对应的ip | | 2、根据ip建立TCP连接 | TCP：与服务器建立连接 | | 3、浏览器向服务器发送HTTP请求 | HTTP：发送请求 | | 4、服务器响应HTTP响应 | HTTP | | 5、浏览器进行渲染 | | ","date":"2022-06-03","objectID":"/posts/tech/interview/interview-nw-java/:1:3","tags":["Java学习随笔","interview"],"title":"内部-design-1","uri":"/posts/tech/interview/interview-nw-java/"},{"categories":["Java"],"content":"操作系统基础 ","date":"2022-06-03","objectID":"/posts/tech/interview/interview-nw-java/:2:0","tags":["Java学习随笔","interview"],"title":"内部-design-1","uri":"/posts/tech/interview/interview-nw-java/"},{"categories":["Java"],"content":"进程和线程的区别 ​ **进程：**是资源分配的最小单位，一个进程可以有多个线程，多个线程共享进程的堆和方法区资源，不共享栈、程序计数器 ​ **线程：**是任务调度和执行的最小单位，线程并行执行存在资源竞争和上下文切换的问题 ​ **协程：**是一种比线程更加轻量级的存在，正如一个进程可以拥有多个线程一样，一个线程可以拥有多个协程。 1、进程间通信方式IPC 管道pipe： ​ 亲缘关系使用匿名管道，非亲缘关系使用命名管道，管道遵循FIFO，半双工，数据只能单向通信； 信号： ​ 信号是一种比较复杂的通信方式，用户调用kill命令将信号发送给其他进程。 消息队列： ​ 消息队列克服了信号传递信息少，管道只能承载无格式字节流以及缓冲区大小受限等特点。 共享内存(share memory)： 使得多个进程可以可以直接读写同一块内存空间，是最快的可用IPC形式。是针对其他通信机制运行效率较低而设计的。 由于多个进程共享一段内存，因此需要依靠某种同步机制（如信号量）来达到进程间的同步及互斥。 信号量(Semaphores) ： ​ 信号量是⼀个计数器，⽤于多进程对共享数据的访问，这种通信⽅式主要⽤于解决与同步相关的问题并避免竞争条件。 套接字(Sockets) : ​ 简单的说就是通信的两⽅的⼀种约定，⽤套接字中的相关函数来完成通信过程。 2、用户态和核心态 **用户态：**只能受限的访问内存，运行所有的应用程序 **核心态：**运行操作系统程序，cpu可以访问内存的所有数据，包括外围设备 为什么要有用户态和内核态： ​ 由于需要限制不同的程序之间的访问能力, 防止他们获取别的程序的内存数据, 或者获取外围设备的数据, 并发送到网络 用户态切换到内核态的3种方式： ​ a. 系统调用 ​ 主动调用，系统调用的机制其核心还是使用了操作系统为用户特别开放的一个中断来实现，例如Linux的int 80h中断。 ​ b. 异常 ​ 当CPU在执行运行在用户态下的程序时，发生了某些事先不可知的异常，比如缺页异常，这时会触发切换内核态处理异常。 ​ c. 外围设备的中断 ​ 当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号，这时CPU会由用户态到内核态的切换。 3、操作系统的进程空间 ​ 栈区（stack）— 由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。 ​ 堆区（heap）— 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收 。 ​ 静态区（static）—存放全局变量和静态变量的存储 ​ 代码区(text)—存放函数体的二进制代码。 ​ 线程共享堆区、静态区 ","date":"2022-06-03","objectID":"/posts/tech/interview/interview-nw-java/:2:1","tags":["Java学习随笔","interview"],"title":"内部-design-1","uri":"/posts/tech/interview/interview-nw-java/"},{"categories":["Java"],"content":"操作系统内存管理 **存管理方式：**页式管理、段式管理、段页式管理 分段管理： ​ 将程序的地址空间划分为若干段（segment），如代码段，数据段，堆栈段；这样每个进程有一个二维地址空间，相互独立，互不干扰。段式管理的优点是：没有内碎片（因为段大小可变，改变段大小来消除内碎片）。但段换入换出时，会产生外碎片（比如4k的段换5k的段，会产生1k的外碎片） 分页管理： ​ 在页式存储管理中，将程序的逻辑地址划分为固定大小的页（page），而物理内存划分为同样大小的页框，程序加载时，可以将任意一页放入内存中任意一个页框，这些页框不必连续，从而实现了离散分离。页式存储管理的优点是：没有外碎片（因为页的大小固定），但会产生内碎片（一个页可能填充不满） 段页式管理： ​ 段⻚式管理机制结合了段式管理和⻚式管理的优点。简单来说段⻚式管理机制就是把主存先分成若⼲段，每个段⼜分成若⼲⻚，也就是说 段⻚式管理机制 中段与段之间以及段的内部的都是离散的 1、页面置换算法FIFO、LRU **置换算法：**先进先出FIFO、最近最久未使用LRU、最佳置换算法OPT 先进先出FIFO: ​ 缺点：没有考虑到实际的页面使用频率，性能差、与通常页面使用的规则不符合，实际应用较少 最近最久未使用LRU: ​ 原理：选择最近且最久未使用的页面进行淘汰 ​ 优点：考虑到了程序访问的时间局部性，有较好的性能，实际应用也比较多 ​ 缺点：没有合适的算法，只有适合的算法，lFU、random都可以 /** * @program: Java * @description: LRU最近最久未使用置换算法，通过LinkedHashMap实现 * @author: Mr.Li * @create: 2020-07-17 10:29 **/ public class LRUCache { private LinkedHashMap\u003cInteger,Integer\u003e cache; private int capacity; //容量大小 /** *初始化构造函数 * @param capacity */ public LRUCache(int capacity) { cache = new LinkedHashMap\u003c\u003e(capacity); this.capacity = capacity; } public int get(int key) { //缓存中不存在此key，直接返回 if(!cache.containsKey(key)) { return -1; } int res = cache.get(key); cache.remove(key); //先从链表中删除 cache.put(key,res); //再把该节点放到链表末尾处 return res; } public void put(int key,int value) { if(cache.containsKey(key)) { cache.remove(key); //已经存在，在当前链表移除 } if(capacity == cache.size()) { //cache已满，删除链表头位置 Set\u003cInteger\u003e keySet = cache.keySet(); Iterator\u003cInteger\u003e iterator = keySet.iterator(); cache.remove(iterator.next()); } cache.put(key,value); //插入到链表末尾 } } /** * @program: Java * @description: LRU最近最久未使用置换算法，通过LinkedHashMap内部removeEldestEntry方法实现 * @author: Mr.Li * @create: 2020-07-17 10:59 **/ class LRUCache { private Map\u003cInteger, Integer\u003e map; private int capacity; /** *初始化构造函数 * @param capacity */ public LRUCache(int capacity) { this.capacity = capacity; map = new LinkedHashMap\u003cInteger, Integer\u003e(capacity, 0.75f, true) { @Override protected boolean removeEldestEntry(Map.Entry eldest) { return size() \u003e capacity; // 容量大于capacity 时就删除 } }; } public int get(int key) { //返回key对应的value值，若不存在，返回-1 return map.getOrDefault(key, -1); } public void put(int key, int value) { map.put(key, value); } } 最佳置换算法OPT: ​ 原理：每次选择当前物理块中的页面在未来长时间不被访问的或未来不再使用的页面进行淘汰 ​ 优点：具有较好的性能，可以保证获得最低的缺页率 ​ 缺点：过于理想化，但是实际上无法实现（没办法预知未来的页面） 2、死锁条件、解决方式。 ​ 死锁是指两个或两个以上进程在执行过程中，因争夺资源而造成的下相互等待的现象； ​ 死锁的条件： ​ 互斥条件：进程对所分配到的资源不允许其他进程访问，若其他进程访问该资源，只能等待至占有该资源的进程释放该资源； ​ 请求与保持条件：进程获得一定的资源后，又对其他资源发出请求，阻塞过程中不会释放自己已经占有的资源 ​ 非剥夺条件：进程已获得的资源，在未完成使用之前，不可被剥夺，只能在使用后自己释放 ​ 循环等待条件：系统中若干进程组成环路，环路中每个进程都在等待相邻进程占用的资源 ​ **解决方法：**破坏死锁的任意一条件 ​ 乐观锁，破坏资源互斥条件，CAS ​ 资源一次性分配，从而剥夺请求和保持条件、tryLock ​ 可剥夺资源：即当进程新的资源未得到满足时，释放已占有的资源，从而破坏不可剥夺的条件，数据库deadlock超时 ​ 资源有序分配法：系统给每类资源赋予一个序号，每个进程按编号递增的请求资源，从而破坏环路等待的条件，转账场景 ","date":"2022-06-03","objectID":"/posts/tech/interview/interview-nw-java/:2:2","tags":["Java学习随笔","interview"],"title":"内部-design-1","uri":"/posts/tech/interview/interview-nw-java/"},{"categories":["Java"],"content":"Java基础 ","date":"2022-06-03","objectID":"/posts/tech/interview/interview-nw-java/:3:0","tags":["Java学习随笔","interview"],"title":"内部-design-1","uri":"/posts/tech/interview/interview-nw-java/"},{"categories":["Java"],"content":"面向对象三大特性 **特性：**封装、继承、多态 ​ **封装：**对抽象的事物抽象化成一个对象，并对其对象的属性私有化，同时提供一些能被外界访问属性的方法； ​ 继承：子类扩展新的数据域或功能，并复用父类的属性与功能，单继承，多实现； ​ **多态：**通过继承（多个⼦类对同⼀⽅法的重写）、也可以通过接⼝（实现接⼝并覆盖接⼝） 1、Java与C++区别 ​ 不同点：c++支持多继承，并且有指针的概念，由程序员自己管理内存；Java是单继承，可以用接口实现多继承，Java 不提供指针来直接访问内存，程序内存更加安全，并且Java有JVM⾃动内存管理机制，不需要程序员⼿动释放⽆⽤内存 2、多态实现原理 多态的底层实现是动态绑定，即在运行时才把方法调用与方法实现关联起来。 静态绑定与动态绑定： ​ 一种是在编译期确定，被称为静态分派，比如方法的重载； ​ 一种是在运行时确定，被称为动态分派，比如方法的覆盖（重写）和接口的实现。 多态的实现 ​ 虚拟机栈中会存放当前方法调用的栈帧（局部变量表、操作栈、动态连接 、返回地址）。多态的实现过程，就是方法调用动态分派的过程，如果子类覆盖了父类的方法，则在多态调用中，动态绑定过程会首先确定实际类型是子类，从而先搜索到子类中的方法。这个过程便是方法覆盖的本质。 3、static和final关键字 **static：**可以修饰属性、方法 ​ static修饰属性： ​ 类级别属性，所有对象共享一份，随着类的加载而加载（只加载一次），先于对象的创建；可以使用类名直接调用。 ​ static修饰方法： ​ 随着类的加载而加载；可以使用类名直接调用；静态方法中，只能调用静态的成员，不可用this； **final：**关键字主要⽤在三个地⽅：变量、⽅法、类。 ​ final修饰变量： ​ 如果是基本数据类型的变量，则其数值⼀旦在初始化之后便不能更改； ​ 如果是引⽤类型的变量，则在对其初始化之后便不能再让其指向另⼀个对象。 ​ final修饰方法： ​ 把⽅法锁定，以防任何继承类修改它的含义（重写）；类中所有的 private ⽅法都隐式地指定为 final。 ​ final修饰类： ​ final 修饰类时，表明这个类不能被继承。final 类中的所有成员⽅法都会被隐式地指定为 final ⽅法。 一个类不能被继承，除了final关键字之外，还有可以私有化构造器。（内部类无效） 4、抽象类和接口 **抽象类：**包含抽象方法的类，即使用abstract修饰的类；抽象类只能被继承，所以不能使用final修饰，抽象类不能被实例化， **接口：**接口是一个抽象类型，是抽象方法的集合，接口支持多继承，接口中定义的方法，默认是public abstract修饰的抽象方法 相同点： ​ ① 抽象类和接口都不能被实例化 ​ ② 抽象类和接口都可以定义抽象方法，子类/实现类必须覆写这些抽象方法 不同点： ​ ① 抽象类有构造方法，接口没有构造方法 ​ ③抽象类可以包含普通方法，接口中只能是public abstract修饰抽象方法（Java8之后可以） ​ ③ 抽象类只能单继承，接口可以多继承 ​ ④ 抽象类可以定义各种类型的成员变量，接口中只能是public static final修饰的静态常量 抽象类的使用场景： ​ 既想约束子类具有共同的行为（但不再乎其如何实现），又想拥有缺省的方法，又能拥有实例变量 接口的应用场景： ​ 约束多个实现类具有统一的行为，但是不在乎每个实现类如何具体实现；实现类中各个功能之间可能没有任何联系 5、泛型以及泛型擦除 参考：https://blog.csdn.net/baoyinwang/article/details/107341997 泛型： ​ 泛型的本质是参数化类型。这种参数类型可以用在类、接口和方法的创建中，分别称为泛型类、泛型接口和泛型方法。 泛型擦除： ​ Java的泛型是伪泛型，使用泛型的时候加上类型参数，在编译器编译生成的字节码的时候会去掉，这个过程成为类型擦除。 ​ 如List等类型，在编译之后都会变成 List。JVM 看到的只是 List，而由泛型附加的类型信息对 JVM 来说是不可见的。 可以通过反射添加其它类型元素 6、反射原理以及使用场景 Java反射： ​ 是指在运行状态中，对于任意一个类都能够知道这个类所有的属性和方法；并且都能够调用它的任意一个方法； 反射原理： ​ 反射首先是能够获取到Java中的反射类的字节码，然后将字节码中的方法，变量，构造函数等映射成 相应的 Method、Filed、Constructor 等类 ​ 如何得到Class的实例: 1.类名.class(就是一份字节码) 2.Class.forName(String className);根据一个类的全限定名来构建Class对象 3.每一个对象都有getClass()方法:obj.getClass();返回对象的真实类型 使用场景： 开发通用框架 - 反射最重要的用途就是开发各种通用框架。很多框架（比如 Spring）都是配置化的（比如通过 XML 文件配置 JavaBean、Filter 等），为了保证框架的通用性，需要根据配置文件运行时动态加载不同的对象或类，调用不同的方法。 动态代理 - 在切面编程（AOP）中，需要拦截特定的方法，通常，会选择动态代理方式。这时，就需要反射技术来实现了。 JDK：spring默认动态代理，需要实现接口 CGLIB：通过asm框架序列化字节流，可配置，性能差 自定义注解 - 注解本身仅仅是起到标记作用，它需要利用反射机制，根据注解标记去调用注解解释器，执行行为。 7、Java异常体系 ​ Throwable 是 Java 语言中所有错误或异常的超类。下一层分为 Error 和 Exception Error ： ​ 是指 java 运行时系统的内部错误和资源耗尽错误。应用程序不会抛出该类对象。如果出现了这样的错误，除了告知用户，剩下的就是尽力使程序安全的终止。 Exception 包含：RuntimeException 、CheckedException 编程错误可以分成三类：语法错误、逻辑错误和运行错误。 语法错误（也称编译错误）是在编译过程中出现的错误，由编译器检查发现语法错误 逻辑错误指程序的执行结果与预期不符，可以通过调试定位并发现错误的原因 运行错误是引起程序非正常终端的错误，需要通过异常处理的方式处理运行错误 RuntimeException： 运行时异常，程序应该从逻辑角度尽可能避免这类异常的发生。 ​ 如 NullPointerException 、 ClassCastException ； **CheckedException：**受检异常，程序使用trycatch进行捕捉处理 ​ 如IOException、SQLException、NotFoundException； ","date":"2022-06-03","objectID":"/posts/tech/interview/interview-nw-java/:3:1","tags":["Java学习随笔","interview"],"title":"内部-design-1","uri":"/posts/tech/interview/interview-nw-java/"},{"categories":["Java"],"content":"数据结构 1、ArrayList和LinkedList ArrayList： ​ 底层基于数组实现，支持对元素进行快速随机访问，适合随机查找和遍历，不适合插入和删除。（提一句实际上） ​ 默认初始大小为10，当数组容量不够时，会触发扩容机制（扩大到当前的1.5倍），需要将原来数组的数据复制到新的数组中；当从 ArrayList 的中间位置插入或者删除元素时，需要对数组进行复制、移动、代价比较高。 LinkedList： ​ 底层基于双向链表实现，适合数据的动态插入和删除； ​ 内部提供了 List 接口中没有定义的方法，用于操作表头和表尾元素，可以当作堆栈、队列和双向队列使用。（比如jdk官方推荐使用基于linkedList的Deque进行堆栈操作） ArrayList与LinkedList区别： ​ 都是线程不安全的，ArrayList 适用于查找的场景，LinkedList 适用于增加、删除多的场景 实现线程安全： ​ 可以使用原生的Vector，或者是Collections.synchronizedList(List list)函数返回一个线程安全的ArrayList集合。 ​ 建议使用concurrent并发包下的CopyOnWriteArrayList的。 ​ ①Vector: 底层通过synchronize修饰保证线程安全，效率较差 ​ ②CopyOnWriteArrayList：写时加锁，使用了一种叫写时复制的方法；读操作是可以不用加锁的 ​ 2、List遍历快速和安全失败 ①普通for循环遍历List删除指定元素 for(int i=0; i \u003c list.size(); i++){ if(list.get(i) == 5) list.remove(i); } ② 迭代遍历,用list.remove(i)方法删除元素 Iterator\u003cInteger\u003e it = list.iterator(); while(it.hasNext()){ Integer value = it.next(); if(value == 5){ list.remove(value); } } ③foreach遍历List删除元素 for(Integer i:list){ if(i==3) list.remove(i); } **fail—fast：**快速失败 ​ 当异常产生时，直接抛出异常，程序终止; ​ fail-fast主要是体现在当我们在遍历集合元素的时候，经常会使用迭代器，但在迭代器遍历元素的过程中，如果集合的结构（modCount）被改变的话，就会抛出异常ConcurrentModificationException，防止继续遍历。这就是所谓的快速失败机制。 **fail—safe：**安全失败 采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。由于在遍历过程中对原集合所作的修改并不能被迭代器检测到，所以不会触发ConcurrentModificationException。 缺点：基于拷贝内容的优点是避免了ConcurrentModificationException，但同样地，迭代器并不能访问到修改后的内容，即：迭代器遍历的是开始遍历那一刻拿到的集合拷贝，在遍历期间原集合发生的修改迭代器是不知道的。 场景：java.util.concurrent包下的容器都是安全失败，可以在多线程下并发使用，并发修改。 3、详细介绍HashMap 角度：数据结构+扩容情况+put查找的详细过程+哈希函数+容量为什么始终都是2^N，JDK1.7与1.8的区别。 参考：https://www.cnblogs.com/wuhuangdi/p/4175991.html https://blog.csdn.net/qq_39480875/article/details/123423138 数据结构： ​ HashMap在底层数据结构上采用了数组＋链表＋红黑树，通过散列映射来存储键值对数据 扩容情况： ​ 默认的负载因子是0.75，如果数组中已经存储的元素个数大于数组长度的75%，将会引发扩容操作。 ​ 【1】创建一个长度为原来数组长度两倍的新数组。 ​ 【2】1.7采用Entry的重新hash运算，1.8采用高于与运算。 put操作步骤： ​ ​ 1、判断数组是否为空，为空进行初始化; ​ 2、不为空，则计算 key 的 hash 值，通过(n - 1) \u0026 hash计算应当存放在数组中的下标 index; ​ 3、查看 table[index] 是否存在数据，没有数据就构造一个Node节点存放在 table[index] 中； ​ 4、存在数据，说明发生了hash冲突(存在二个节点key的hash值一样), 继续判断key是否相等，相等，用新的value替换原数据； ​ 5、若不相等，判断当前节点类型是不是树型节点，如果是树型节点，创造树型节点插入红黑树中； ​ 6、若不是红黑树，创建普通Node加入链表中；判断链表长度是否大于 8，大于则将链表转换为红黑树； ​ 7、插入完成之后判断当前节点数是否大于阈值，若大于，则扩容为原数组的二倍 哈希函数： ​ 通过hash函数（优质因子31循环累加）先拿到 key 的hashcode，是一个32位的值，然后让hashcode的高16位和低16位进行异或操作。该函数也称为扰动函数，做到尽可能降低hash碰撞，通过尾插法进行插入。 容量为什么始终都是2^N： ​ 先做对数组的⻓度取模运算，得到的余数才能⽤来要存放的位置也就是对应的数组下标。这个数组下标的计算⽅法是“ (n - 1) \u0026 hash ”。（n代表数组⻓度）。方便数组的扩容和增删改时的取模。 JDK1.7与1.8的区别： JDK1.7 HashMap： ​ 底层是 数组和链表 结合在⼀起使⽤也就是链表散列。如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。扩容翻转时顺序不一致使用头插法会产生死循环，导致cpu100% JDK1.8 HashMap： ​ 底层数据结构上采用了数组＋链表＋红黑树；当链表⻓度⼤于阈值（默认为 8-泊松分布），数组的⻓度大于 64时，链表将转化为红⿊树，以减少搜索时间。（解决了tomcat臭名昭著的url参数dos攻击问题） **4、ConcurrentHashMap ** ​ 可以通过ConcurrentHashMap 和 Hashtable来实现线程安全；Hashtable 是原始API类，通过synchronize同步修饰，效率低下；ConcurrentHashMap 通过分段锁实现，效率较比Hashtable要好； ConcurrentHashMap的底层实现： ​ JDK1.7的 ConcurrentHashMap 底层采⽤ 分段的数组+链表 实现；采用 分段锁（Sagment） 对整个桶数组进⾏了分割分段(Segment默认16个)，每⼀把锁只锁容器其中⼀部分数据，多线程访问容器⾥不同数据段的数据，就不会存在锁竞争，提⾼并发访问率。 ​ JDK1.8的 ConcurrentHashMap 采⽤的数据结构跟HashMap1.8的结构⼀样，数组+链表/红⿊树；摒弃了Segment的概念，⽽是直接⽤ Node 数组+链表+红⿊树的数据结构来实现，通过并发控制 synchronized 和CAS来操作保证线程的安全。 5、序列化和反序列化 ​ 序列化的意思就是将对象的状态转化成字节流，以后可以通过这些值再生成相同状态的对象。对象序列化是对象持久化的一种实现方法，它是将对象的属性和方法转化为一种序列化的形式用于存储和传输。反序列化就是根据这些保存的信息重建对象的过程。 **序列化：**将java对象转化为字节序列的过程。 **反序列化：**将字节序列转化为java对象的过程。 优点： ​ a、实现了数据的持久化，通过序列化可以把数据永久地保存到硬盘上（通常存放在文件里）Redis的RDB ​ b、利用序列化实现远程通信，即在网络上传送对象的字节序列。 Google的protoBuf 反序列化失败的场景： ​ 序列化ID：serialVersionUID不一致的时候，导致反序列化失败 6、String String 使用数组存储内容，数组使用 final 修饰，因此 String 定义的字符串的值也是不可变的 StringBuffer 对方法加了同步锁，线程安全，效率略低于 StringBuilder ","date":"2022-06-03","objectID":"/posts/tech/interview/interview-nw-java/:3:2","tags":["Java学习随笔","interview"],"title":"内部-design-1","uri":"/posts/tech/interview/interview-nw-java/"},{"categories":["Java"],"content":"设计模式与原则 1、单例模式 ​ 某个类只能生成一个实例，该实例全局访问，例如Spring容器里一级缓存里的单例池。 优点： ​ 唯一访问：如生成唯一序列化的场景、或者spring默认的bean类型。 ​ 提高性能：频繁实例化创建销毁或者耗时耗资源的场景，如连接池、线程池。 缺点： ​ 不适合有状态且需变更的 实现方式： ​ 饿汉式：线程安全速度快 ​ 懒汉式：双重检测锁，第一次减少锁的开销、第二次防止重复、volatile防止重排序导致实例化未完成 ​ 静态内部类：线程安全利用率高 ​ 枚举：effictiveJAVA推荐，反射也无法破坏 2、工厂模式 ​ 定义一个用于创建产品的接口，由子类决定生产何种产品。 **优点：**解耦：提供参数即可获取产品，通过配置文件可以不修改代码增加具体产品。 **缺点：**每增加一个产品就得新增一个产品类 3、抽象工厂模式 ​ 提供一个接口，用于创建相关或者依赖对象的家族，并由此进行约束。 **优点：**可以在类的内部对产品族进行约束 缺点：假如产品族中需要增加一个新的产品，则几乎所有的工厂类都需要进行修改。 ","date":"2022-06-03","objectID":"/posts/tech/interview/interview-nw-java/:3:3","tags":["Java学习随笔","interview"],"title":"内部-design-1","uri":"/posts/tech/interview/interview-nw-java/"},{"categories":["Java"],"content":"面试题 ","date":"2022-06-03","objectID":"/posts/tech/interview/interview-nw-java/:4:0","tags":["Java学习随笔","interview"],"title":"内部-design-1","uri":"/posts/tech/interview/interview-nw-java/"},{"categories":["Java"],"content":"构造方法 构造方法可以被重载，只有当类中没有显性声明任何构造方法时，才会有默认构造方法。 构造方法没有返回值，构造方法的作用是创建新对象。 ","date":"2022-06-03","objectID":"/posts/tech/interview/interview-nw-java/:4:1","tags":["Java学习随笔","interview"],"title":"内部-design-1","uri":"/posts/tech/interview/interview-nw-java/"},{"categories":["Java"],"content":"初始化块 静态初始化块的优先级最高，会最先执行，在非静态初始化块之前执行。 静态初始化块会在类第一次被加载时最先执行，因此在 main 方法之前。 ","date":"2022-06-03","objectID":"/posts/tech/interview/interview-nw-java/:4:2","tags":["Java学习随笔","interview"],"title":"内部-design-1","uri":"/posts/tech/interview/interview-nw-java/"},{"categories":["Java"],"content":"This 关键字 this 代表当前对象的引用。当前对象指的是调用类中的属性或方法的对象 关键字 this 不可以在静态方法中使用。静态方法不依赖于类的具体对象的引用 ","date":"2022-06-03","objectID":"/posts/tech/interview/interview-nw-java/:4:3","tags":["Java学习随笔","interview"],"title":"内部-design-1","uri":"/posts/tech/interview/interview-nw-java/"},{"categories":["Java"],"content":"重写和重载的区别 重载指在同一个类中定义多个方法，这些方法名称相同，签名不同。 重写指在子类中的方法的名称和签名都和父类相同，使用override注解 ","date":"2022-06-03","objectID":"/posts/tech/interview/interview-nw-java/:4:4","tags":["Java学习随笔","interview"],"title":"内部-design-1","uri":"/posts/tech/interview/interview-nw-java/"},{"categories":["Java"],"content":"Object类方法 toString 默认是个指针，一般需要重写 equals 比较对象是否相同，默认和==功能一致 hashCode 散列码，equals则hashCode相同，所以重写equals必须重写hashCode **finalize ** 用于垃圾回收之前做的遗嘱，默认空，子类需重写 clone 深拷贝，类需实现cloneable的接口 getClass 反射获取对象元数据，包括类名、方法、 notify、wait 用于线程通知和唤醒 ","date":"2022-06-03","objectID":"/posts/tech/interview/interview-nw-java/:4:5","tags":["Java学习随笔","interview"],"title":"内部-design-1","uri":"/posts/tech/interview/interview-nw-java/"},{"categories":["Java"],"content":"基本数据类型和包装类 | 类型 | 缓存范围 | | ———————– | ————- | | Byte,Short,Integer,Long | [-128, 127] | | Character | [0, 127] | | Boolean | [false, true] | 二、JVM篇 ","date":"2022-06-03","objectID":"/posts/tech/interview/interview-nw-java/:4:6","tags":["Java学习随笔","interview"],"title":"内部-design-1","uri":"/posts/tech/interview/interview-nw-java/"},{"categories":["Java"],"content":"JVM内存划分 1、JVM运行时数据区域 ​ 堆、方法区（元空间）、虚拟机栈、本地方法栈、程序计数器 Heap(堆)： ​ 对象的实例以及数组的内存都是要在堆上进行分配的，堆是线程共享的一块区域，用来存放对象实例，也是垃圾回收（GC）的主要区域；开启逃逸分析后，某些未逃逸的对象可以通过标量替换的方式在栈中分配 ​ 堆细分：新生代、老年代，对于新生代又分为：Eden区和Surviver1和Surviver2区； 方法区： ​ 对于JVM的方法区也可以称之为永久区，它储存的是已经被java虚拟机加载的类信息、常量、静态变量；Jdk1.8以后取消了方法区这个概念，称之为元空间（MetaSpace）； ​ 当应用中的 Java 类过多时，比如 Spring 等一些使用动态代理的框架生成了很多类，如果占用空间超出了我们的设定值，就会发生元空间溢出 虚拟机栈： ​ 虚拟机栈是线程私有的，他的生命周期和线程的生命周期是一致的。里面装的是一个一个的栈帧，每一个方法在执行的时候都会创建一个栈帧，栈帧中用来存放（局部变量表、操作数栈 、动态链接 、返回地址）；在Java虚拟机规范中，对此区域规定了两种异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将会抛出StackOverflowError异常；如果虚拟机栈动态扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常。 局部变量表：局部变量表是一组变量值存储空间，用来存放方法参数、方法内部定义的局部变量。底层是变量槽（variable slot） 操作数栈：是用来记录一个方法在执行的过程中，字节码指令向操作数栈中进行入栈和出栈的过程。大小在编译的时候已经确定了，当一个方法刚开始执行的时候，操作数栈中是空发的，在方法执行的过程中会有各种字节码指令往操作数栈中入栈和出栈。 动态链接：因为字节码文件中有很多符号的引用，这些符号引用一部分会在类加载的解析阶段或第一次使用的时候转化成直接引用，这种称为静态解析；另一部分会在运行期间转化为直接引用，称为动态链接。 **返回地址（returnAddress）：**类型（指向了一条字节码指令的地址） JIT即时编译器（Just In Time Compiler），简称 JIT 编译器: 为了提高热点代码的执行效率，在运行时，虚拟机将会把这些代码编译成与本地平台相关的机器码，并进行各种层次的优化，比如锁粗化等 本地方法栈： ​ 本地方法栈和虚拟机栈类似，不同的是虚拟机栈服务的是Java方法，而本地方法栈服务的是Native方法。在HotSpot虚拟机实现中是把本地方法栈和虚拟机栈合二为一的，同理它也会抛出StackOverflowError和OOM异常。 PC程序计数器： ​ PC，指的是存放下一条指令的位置的一个指针。它是一块较小的内存空间，且是线程私有的。由于线程的切换，CPU在执行的过程中，需要记住原线程的下一条指令的位置，所以每一个线程都需要有自己的PC。 2、堆内存分配策略 对象优先分配在Eden区，如果Eden区没有足够的空间进行分配时，虚拟机执行一次MinorGC。而那些无需回收的存活对象，将会进到 Survivor 的 From 区（From 区内存不足时，直接进入 Old 区）。 大对象直接进入老年代（需要大量连续内存空间的对象）。这样做的目的是避免在Eden区和两个Survivor区之间发生大量的内存拷贝（新生代采用复制算法收集内存）。 长期存活的对象进入老年代。虚拟机为每个对象定义了一个年龄（Age Count）计数器，如果对象经过了1次Minor GC那么对象会进入Survivor区，之后每经过一次Minor GC那么对象的年龄加1，直到达到阀值（默认15次），对象进入老年区。 （动态对象年龄判定：程序从年龄最小的对象开始累加，如果累加的对象大小，大于幸存区的一半，则将当前的对象 age 作为新的阈值，年龄大于此阈值的对象则直接进入老年代） 每次进行Minor GC或者大对象直接进入老年区时，JVM会计算所需空间大小如小于老年区的剩余值大小，则进行一次Full GC。 3、创建一个对象的步骤 步骤：类加载检查、分配内存、初始化零值、设置对象头、执行init方法 ①类加载检查： ​ 虚拟机遇到 new 指令时，⾸先去检查是否能在常量池中定位到这个类的符号引⽤，并且检查这个符号引⽤代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执⾏相应的类加载过程。 ②分配内存： ​ 在类加载检查通过后，接下来虚拟机将为新⽣对象分配内存，分配⽅式有 “指针碰撞” 和 “空闲列表” 两种，选择那种分配⽅式由 Java 堆是否规整决定，⽽Java堆是否规整⼜由所采⽤的垃圾收集器是否带有压缩整理功能决定。 ③初始化零值： ​ 内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值，这⼀步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使⽤，程序能访问到这些字段的数据类型所对应的零值。 ④设置对象头： ​ 初始化零值完成之后，虚拟机要对对象进⾏必要的设置，例如这个对象是那个类的实例、如何才能找到类的元数据信息、对象的哈希吗、对象的 GC 分代年龄等信息。 这些信息存放在对象头中。 另外，根据虚拟机当前运⾏状态的不同，如是否启⽤偏向锁等，对象头会有不同的设置⽅式。 ⑤执⾏ init ⽅法： ​ 从虚拟机的视⻆来看，⼀个新的对象已经产⽣了，但从Java 程序的视⻆来看， ⽅法还没有执⾏，所有的字段都还为零。所以⼀般来说（除循环依赖），执⾏ new 指令之后会接着执⾏ ⽅法，这样⼀个真正可⽤的对象才算产⽣出来。 4、对象引用 普通的对象引用关系就是强引用。 软引用用于维护一些可有可无的对象。只有在内存不足时，系统则会回收软引用对象，如果回收了软引用对象之后仍然没有足够的内存，才会抛出内存溢出异常。 弱引用对象相比软引用来说，要更加无用一些，它拥有更短的生命周期，当 JVM 进行垃圾回收时，无论内存是否充足，都会回收被弱引用关联的对象。 虚引用是一种形同虚设的引用，在现实场景中用的不是很多，它主要用来跟踪对象被垃圾回收的活动。 ","date":"2022-06-03","objectID":"/posts/tech/interview/interview-nw-java/:4:7","tags":["Java学习随笔","interview"],"title":"内部-design-1","uri":"/posts/tech/interview/interview-nw-java/"},{"categories":["Java"],"content":"JVM类加载过程 过程：加载、验证、准备、解析、初始化 加载阶段： ​ 1.通过一个类的全限定名来获取定义此类的二进制字节流。 ​ 2.将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。 ​ 3.在Java堆中生成一个代表这个类的java.lang.class对象，作为方法区这些数据的访问入口。 验证阶段： ​ 1.文件格式验证（是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理） ​ 2.元数据验证（对字节码描述的信息进行语意分析，以保证其描述的信息符合Java语言规范要求） ​ 3.字节码验证（保证被校验类的方法在运行时不会做出危害虚拟机安全的行为） ​ 4.符号引用验证（虚拟机将符号引用转化为直接引用时，解析阶段中发生） 准备阶段： ​ 准备阶段是正式为类变量分配内存并设置类变量初始值的阶段。将对象初始化为“零”值 解析阶段： ​ 解析阶段时虚拟机将常量池内的符号引用替换为直接引用的过程。 ​ 字符串常量池：堆上，默认class文件的静态常量池 ​ 运行时常量池：在方法区，属于元空间 初始化阶段： ​ 初始化阶段时加载过程的最后一步，而这一阶段也是真正意义上开始执行类中定义的Java程序代码。 1、双亲委派机制 ​ 每⼀个类都有⼀个对应它的类加载器。系统中的 ClassLoder 在协同⼯作的时候会默认使⽤ 双亲委派模型 。即在类加载的时候，系统会⾸先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载。加载的时候，⾸先会把该请求委派该⽗类加载器的 loadClass() 处理，因此所有的请求最终都应该传送到顶层的启动类加载器 BootstrapClassLoader 中。当⽗类加载器⽆法处理时，才由⾃⼰来处理。当⽗类加载器为null时，会使⽤启动类加载器 BootstrapClassLoader 作为⽗类加载器。 使用好处： ​ 此机制保证JDK核心类的优先加载；使得Java程序的稳定运⾏，可以避免类的重复加载，也保证了 Java 的核⼼ API 不被篡改。如果不⽤没有使⽤双亲委派模型，⽽是每个类加载器加载⾃⼰的话就会出现⼀些问题，⽐如我们编写⼀个称为 java.lang.Object 类的话，那么程序运⾏的时候，系统就会出现多个不同的Object 类。 破坏双亲委派机制： 可以⾃⼰定义⼀个类加载器，重写loadClass方法； Tomcat 可以加载自己目录下的 class 文件，并不会传递给父类的加载器； Java 的 SPI，发起者 BootstrapClassLoader 已经是最上层了，它直接获取了 AppClassLoader 进行驱动加载，和双亲委派是相反的。 2、tomcat的类加载机制 步骤： 先在本地cache查找该类是否已经加载过，看看 Tomcat 有没有加载过这个类。 如果Tomcat 没有加载过这个类，则从系统类加载器的cache中查找是否加载过。 如果没有加载过这个类，尝试用ExtClassLoader类加载器类加载，重点来了，这里并没有首先使用 AppClassLoader 来加载类。这个Tomcat 的 WebAPPClassLoader 违背了双亲委派机制，直接使用了 ExtClassLoader来加载类。这里注意 ExtClassLoader 双亲委派依然有效，ExtClassLoader 就会使用 Bootstrap ClassLoader 来对类进行加载，保证了 Jre 里面的核心类不会被重复加载。 比如在 Web 中加载一个 Object 类。WebAppClassLoader → ExtClassLoader → Bootstrap ClassLoader，这个加载链，就保证了 Object 不会被重复加载。 如果 BoostrapClassLoader，没有加载成功，就会调用自己的 findClass 方法由自己来对类进行加载，findClass 加载类的地址是自己本 web 应用下的 class。 加载依然失败，才使用 AppClassLoader 继续加载。 都没有加载成功的话，抛出异常。 总结一下以上步骤，WebAppClassLoader 加载类的时候，故意打破了JVM 双亲委派机制，绕开了 AppClassLoader，直接先使用 ExtClassLoader 来加载类。 ","date":"2022-06-03","objectID":"/posts/tech/interview/interview-nw-java/:4:8","tags":["Java学习随笔","interview"],"title":"内部-design-1","uri":"/posts/tech/interview/interview-nw-java/"},{"categories":["Java"],"content":"JVM垃圾回收 1、存活算法和两次标记过程 引用计数法： ​ 给对象添加一个引用计数器，每当由一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的。 ​ 优点：实现简单，判定效率也很高 ​ 缺点：他很难解决对象之间相互循环引用的问题，基本上被抛弃 可达性分析法： ​ 通过一系列的成为“GC Roots”(活动线程相关的各种引用，虚拟机栈帧引用，静态变量引用，JNI引用)的对象作为起始点，从这些节点ReferenceChains开始向下搜索，搜索所走过的路径成为引用链，当一个对象到GC ROOTS没有任何引用链相连时，则证明此对象时不可用的； 两次标记过程： ​ 对象被回收之前，该对象的finalize()方法会被调用；两次标记，即第一次标记不在“关系网”中的对象。第二次的话就要先判断该对象有没有实现finalize()方法了，如果没有实现就直接判断该对象可回收；如果实现了就会先放在一个队列中，并由虚拟机建立的一个低优先级的线程去执行它，随后就会进行第二次的小规模标记，在这次被标记的对象就会真正的被回收了。 2、垃圾回收算法 垃圾回收算法：复制算法、标记清除、标记整理、分代收集 复制算法：(young) ​ 将内存分为⼤⼩相同的两块，每次使⽤其中的⼀块。当这⼀块的内存使⽤完后，就将还存活的对象复制到另⼀块去，然后再把使⽤的空间⼀次清理掉。这样就使每次的内存回收都是对内存区间的⼀半进⾏回收； ​ 优点：实现简单，内存效率高，不易产生碎片 ​ 缺点：内存压缩了一半，倘若存活对象多，Copying 算法的效率会大大降低 标记清除：(cms) ​ 标记出所有需要回收的对象，在标记完成后统⼀回收所有被标记的对象 ​ 缺点：效率低，标记清除后会产⽣⼤量不连续的碎⽚，需要预留空间给分配阶段的浮动垃圾 标记整理：(old) ​ 标记过程仍然与“标记-清除”算法⼀样，再让所有存活的对象向⼀端移动，然后直接清理掉端边界以外的内存；解决了产生大量不连续碎片问题 分代收集： ​ 根据各个年代的特点选择合适的垃圾收集算法。 ​ 新生代采用复制算法，新生代每次垃圾回收都要回收大部分对象，存活对象较少，即要复制的操作比较少，一般将新生代划分为一块较大的 Eden 空间和两个较小的 Survivor 空间(From Space, To Space)，每次使用Eden 空间和其中的一块 Survivor 空间，当进行回收时，将该两块空间中还存活的对象复制到另一块 Survivor 空间中。 ​ 老年代的对象存活⼏率是⽐较⾼的，⽽且没有额外的空间对它进⾏分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进⾏垃圾收集。 Safepoint 当发生 GC 时，用户线程必须全部停下来，才可以进行垃圾回收，这个状态我们可以认为 JVM 是安全的（safe），整个堆的状态是稳定的。如果在 GC 前，有线程迟迟进入不了 safepoint，那么整个 JVM 都在等待这个阻塞的线程，造成了整体 GC 的时间变长 MinorGC、MajorGC、FullGC MinorGC 在年轻代空间不足的时候发生， MajorGC 指的是老年代的 GC，出现 MajorGC 一般经常伴有 MinorGC。 FullGC 1、当老年代无法再分配内存的时候；2、元空间不足的时候；3、显示调用 System.gc 的时候。另外，像 CMS 一类的垃圾回收器，在 MinorGC 出现 promotion failure 的时候也会发生 FullGC。 对象优先在 Eden 区分配 大多数情况下，对象在新生代 Eden 区分配，当 Eden 区空间不够时，发起 Minor GC。 大对象直接进入老年代 大对象是指需要连续内存空间的对象，比如很长的字符串以及数组。老年代直接分配的目的是避免在 Eden 区和 Survivor 区之间出现大量内存复制。 长期存活的对象进入老年代 虚拟机给每个对象定义了年龄计数器，对象在 Eden 区出生之后，如果经过一次 Minor GC 之后，将进入 Survivor 区，同时对象年龄变为 1，增加到一定阈值时则进入老年代（阈值默认为 15） 动态对象年龄判定 为了能更好地适应不同程序的内存状况，虚拟机并不总是要求对象的年龄必须达到阈值才能进入老年代。如果在 Survivor 区中相同年龄的所有对象的空间总和大于 Survivor 区空间的一半，则年龄大于或等于该年龄的对象直接进入老年代。 空间分配担保 在发生 Minor GC 之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象的空间总和，如果这个条件成立，那么 Minor GC 可以确保是安全的。如果不成立则进行 Full GC。 3、垃圾收集器 ​ JDK3：Serial Parnew 关注效率 Serial： ​ Serial 是一个单线程的收集器，它不但只会使用一个 CPU 或一条线程去完成垃圾收集工作，并且在进行垃圾收集的同时，必须暂停其他所有的工作线程，直到垃圾收集结束。适合用于客户端垃圾收集器。 Parnew： ​ ParNew 垃圾收集器其实是 Serial 收集器的多线程版本，也使用复制算法，除了使用多线程进行垃圾收集之外，其余的行为和 Serial 收集器完全一样，ParNew 垃圾收集器在垃圾收集过程中同样也要暂停所有其他的工作线程。 ​ JDK5：parallel Scavenge+（Serial old/parallel old）关注吞吐量 parallel Scavenge：(关注吞吐量) ​ Parallel Scavenge收集器关注点是吞吐量（⾼效率的利⽤CPU）。CMS等垃圾收集器的关注点更多的是⽤户线程的停顿时间（提⾼⽤户体验）；高吞吐量可以最高效率地利用 CPU 时间，尽快地完成程序的运算任务，主要适用于在后台运算而不需要太多交互的任务。 Serial old： Serial收集器的⽼年代版本，它同样是⼀个单线程收集器，使用标记-整理算法。主要有两个用途： 在 JDK1.5 之前版本中与新生代的 Parallel Scavenge 收集器搭配使用。 作为年老代中使用 CMS 收集器的后备垃圾收集方案。 parallel old： ​ Parallel Scavenge收集器的⽼年代版本。使⽤多线程和“标记-整理”算法。 JDK8-CMS：（关注最短垃圾回收停顿时间） ​ CMS收集器是一种年老代垃圾收集器，其最主要目标是获取最短垃圾回收停顿时间，和其他年老代使用标记-整理算法不同，它使用多线程的标记-清除算法。最短的垃圾收集停顿时间可以为交互比较高的程序提高用户体验。CMS 工作机制相比其他的垃圾收集器来说更复杂，整个过程分为以下 4 个阶段： ​ **初始标记：**只是标记一下 GC Roots 能直接关联的对象，速度很快，STW。 ​ **并发标记：**进行 ReferenceChains跟踪的过程，和用户线程一起工作，不需要暂停工作线程。 ​ **重新标记：**为了修正在并发标记期间，因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，STW。 ​ **并发清除：**清除 GC Roots 不可达对象，和用户线程一起工作，不需要暂停工作线程。 ​ 由于耗时最长的并发标记和并发清除过程中，垃圾收集线程可以和用户现在一起并发工作，所以总体上来看CMS 收集器的内存回收和用户线程是一起并发地执行。 ​ **优点：**并发收集、低停顿 ​ **缺点：**对CPU资源敏感；⽆法处理浮动垃圾；使⽤“标记清除”算法，会导致⼤量空间碎⽚产⽣。 JDK9-G1：（精准控制停顿时间，避免垃圾碎片） ​ 是⼀款⾯向服务器的垃圾收集器,主要针对配备多颗处理器及⼤容量内存的机器.以极⾼概率满⾜GC停顿时间要求的同时,还具备⾼吞吐量性能特征；相比与 CMS 收集器，G1 收集器两个最突出的改进是： ​ 【1】基于标记-整理算法，不产生内存碎片。 ​ 【2】可以非常精确控制停顿时间，在不牺牲吞吐量前提下，实现低停顿垃圾回收。 ​ G1 收集器避免全区域垃圾收集，它把堆内存划分为大小固定的几个独立区域，并且跟踪这些区域的垃圾收集进度，同时在后台维护一个优先级列表，每次根据所允许的收集时间，优先回收垃圾最多的区域。区域划分和优先级区域回收机制，确保 G1 收集器可以在有限时间获得最高的垃圾收集效率。 初始标记：**Stop The World，**仅使用一条初始标记线程对GC Roots关联的对象进行标记 并发标记：使用一条标记线程与用户线程并发执行。此过程进行可达性分析，速度很慢 最终标记：Stop The World，使用多条标记线程并发执行 筛选回收：回收废弃对象，此时也要 Stop The World，并使用多条筛选回收线程并发执行 JDK11-ZGC:（在不关注容量的情况获取最小停顿时间5TB/10ms） ​ 着色笔技术：加快标记过程 ​ 读屏障：解决GC和应用之间并发导致的STW问题 支持 TB 级堆内存（最大 4T， JDK13 最大16TB） 最大 GC 停顿 10ms 对吞吐量影响最大，不超过 15% 4、配置垃圾收集器 首先是内存大小问题，基本上每一个内存区域我都会设置一个上限，来避免溢出问题，比如元空间。 通常，堆空间我会设置成操作系统的 2/3，超过 8GB 的堆，优先选用 G1 然后我会对 JVM 进行初步优化，比如根据老年代的对象提升速度，来调整年轻代和老年代之间的比例 依据系统容量、访问延迟、吞吐量等进行专项","date":"2022-06-03","objectID":"/posts/tech/interview/interview-nw-java/:4:9","tags":["Java学习随笔","interview"],"title":"内部-design-1","uri":"/posts/tech/interview/interview-nw-java/"},{"categories":["Java"],"content":"线上故障排查 1、硬件故障排查 如果一个实例发生了问题，根据情况选择，要不要着急去重启。如果出现的CPU、内存飙高或者日志里出现了OOM异常 第一步是隔离，第二步是保留现场，第三步才是问题排查。 隔离 就是把你的这台机器从请求列表里摘除，比如把 nginx 相关的权重设成零。 现场保留 瞬时态和历史态 查看比如 CPU、系统内存等，通过历史状态可以体现一个趋势性问题，而这些信息的获取一般依靠监控系统的协作。 保留信息 （1）系统当前网络连接 ss -antp \u003e $DUMP_DIR/ss.dump 2\u003e\u00261 使用 ss 命令而不是 netstat 的原因，是因为 netstat 在网络连接非常多的情况下，执行非常缓慢。 后续的处理，可通过查看各种网络连接状态的梳理，来排查 TIME_WAIT 或者 CLOSE_WAIT，或者其他连接过高的问题，非常有用。 （2）网络状态统计 netstat -s \u003e $DUMP_DIR/netstat-s.dump 2\u003e\u00261 它能够按照各个协议进行统计输出，对把握当时整个网络状态，有非常大的作用。 sar -n DEV 1 2 \u003e $DUMP_DIR/sar-traffic.dump 2\u003e\u00261 在一些速度非常高的模块上，比如 Redis、Kafka，就经常发生跑满网卡的情况。表现形式就是网络通信非常缓慢。 （3）进程资源 lsof -p $PID \u003e $DUMP_DIR/lsof-$PID.dump 通过查看进程，能看到打开了哪些文件，可以以进程的维度来查看整个资源的使用情况，包括每条网络连接、每个打开的文件句柄。同时，也可以很容易的看到连接到了哪些服务器、使用了哪些资源。这个命令在资源非常多的情况下，输出稍慢，请耐心等待。 （4）CPU 资源 mpstat \u003e $DUMP_DIR/mpstat.dump 2\u003e\u00261 vmstat 1 3 \u003e $DUMP_DIR/vmstat.dump 2\u003e\u00261 sar -p ALL \u003e $DUMP_DIR/sar-cpu.dump 2\u003e\u00261 uptime \u003e $DUMP_DIR/uptime.dump 2\u003e\u00261 主要用于输出当前系统的 CPU 和负载，便于事后排查。 （5）I/O 资源 iostat -x \u003e $DUMP_DIR/iostat.dump 2\u003e\u00261 一般，以计算为主的服务节点，I/O 资源会比较正常，但有时也会发生问题，比如日志输出过多，或者磁盘问题等。此命令可以输出每块磁盘的基本性能信息，用来排查 I/O 问题。在第 8 课时介绍的 GC 日志分磁盘问题，就可以使用这个命令去发现。 （6）内存问题 free -h \u003e $DUMP_DIR/free.dump 2\u003e\u00261 free 命令能够大体展现操作系统的内存概况，这是故障排查中一个非常重要的点，比如 SWAP 影响了 GC，SLAB 区挤占了 JVM 的内存。 （7）其他全局 ps -ef \u003e $DUMP_DIR/ps.dump 2\u003e\u00261 dmesg \u003e $DUMP_DIR/dmesg.dump 2\u003e\u00261 sysctl -a \u003e $DUMP_DIR/sysctl.dump 2\u003e\u00261 dmesg 是许多静悄悄死掉的服务留下的最后一点线索。当然，ps 作为执行频率最高的一个命令，由于内核的配置参数，会对系统和 JVM 产生影响，所以我们也输出了一份。 （8）进程快照，最后的遗言（jinfo） ${JDK_BIN}jinfo $PID \u003e $DUMP_DIR/jinfo.dump 2\u003e\u00261 此命令将输出 Java 的基本进程信息，包括环境变量和参数配置，可以查看是否因为一些错误的配置造成了 JVM 问题。 （9）dump 堆信息 ${JDK_BIN}jstat -gcutil $PID \u003e $DUMP_DIR/jstat-gcutil.dump 2\u003e\u00261 ${JDK_BIN}jstat -gccapacity $PID \u003e $DUMP_DIR/jstat-gccapacity.dump 2\u003e\u00261 jstat 将输出当前的 gc 信息。一般，基本能大体看出一个端倪，如果不能，可将借助 jmap 来进行分析。 （10）堆信息 ${JDK_BIN}jmap $PID \u003e $DUMP_DIR/jmap.dump 2\u003e\u00261 ${JDK_BIN}jmap -heap $PID \u003e $DUMP_DIR/jmap-heap.dump 2\u003e\u00261 ${JDK_BIN}jmap -histo $PID \u003e $DUMP_DIR/jmap-histo.dump 2\u003e\u00261 ${JDK_BIN}jmap -dump:format=b,file=$DUMP_DIR/heap.bin $PID \u003e /dev/null 2\u003e\u00261 jmap 将会得到当前 Java 进程的 dump 信息。如上所示，其实最有用的就是第 4 个命令，但是前面三个能够让你初步对系统概况进行大体判断。因为，第 4 个命令产生的文件，一般都非常的大。而且，需要下载下来，导入 MAT 这样的工具进行深入分析，才能获取结果。这是分析内存泄漏一个必经的过程。 （11）JVM 执行栈 ${JDK_BIN}jstack $PID \u003e $DUMP_DIR/jstack.dump 2\u003e\u00261 jstack 将会获取当时的执行栈。一般会多次取值，我们这里取一次即可。这些信息非常有用，能够还原 Java 进程中的线程情况。 top -Hp $PID -b -n 1 -c \u003e $DUMP_DIR/top-$PID.dump 2\u003e\u00261 为了能够得到更加精细的信息，我们使用 top 命令，来获取进程中所有线程的 CPU 信息，这样，就可以看到资源到底耗费在什么地方了。 （12）高级替补 kill -3 $PID 有时候，jstack 并不能够运行，有很多原因，比如 Java 进程几乎不响应了等之类的情况。我们会尝试向进程发送 kill -3 信号，这个信号将会打印 jstack 的 trace 信息到日志文件中，是 jstack 的一个替补方案。 gcore -o $DUMP_DIR/core $PID 对于 jmap 无法执行的问题，也有替补，那就是 GDB 组件中的 gcore，将会生成一个 core 文件。我们可以使用如下的命令去生成 dump： ${JDK_BIN}jhsdb jmap --exe ${JDK}java --core $DUMP_DIR/core --binaryheap 内存泄漏的现象 稍微提一下 jmap 命令，它在 9 版本里被干掉了，取而代之的是 jhsdb，你可以像下面的命令一样使用。 jhsdb jmap --heap --pid 37340 jhsdb jmap --pid 37288 jhsdb jmap --histo --pid 37340 jhsdb jmap --binaryheap --pid 37340 一般内存溢出，表现形式就是 Old 区的占用持续上升，即使经过了多轮 GC 也没有明显改善。比如ThreadLocal里面的GC Roots，内存泄漏的根本就是，这些对象并没有切断和 GC Roots 的关系，可通过一些工具，能够看到它们的联系。 2、报表异常 | JVM调优 有一个报表系统，频繁发生内存溢出，在高峰期间使用时，还会频繁的发生拒绝服务，由于大多数使用者是管理员角色，所以很快就反馈到研发这里。 业务场景是由于有些结果集的字段不是太全，因此需要对结果集合进行循环，并通过 HttpClient 调用其他服务的接口进行数据填充。使用 Guava 做了 JVM 内缓存，但是响应时间依然很长。 初步排查，JVM 的资源太少。接口 A 每次进行报表计算时，都要涉及几百兆的内存，而且在内存里驻留很长时间，有些计算又非常耗 CPU，特别的“吃”资源。而我们分配给 JVM 的内存只有 3 GB，在多人访问这些接口的时候，内存就不够用了，进而发生了 OOM。在这种情况下，没办法，只有升级机器。把机器配置升级到 4C8G，给 JVM 分配 6GB 的内存，这样 OOM 问题就消失了。但随之而来的是频繁的 GC 问题和超长的 GC 时间，平均 GC 时间竟然有 5 秒多。 进一步，由于报表系统和高并发系统不太一样，它的对象，存活时长大得多，并不能仅仅通过增加年轻代来解决；而且，如果增加了年轻代，那么必然减少了老年代的大小，由于 CMS 的碎片和浮动垃圾问题，我们可用的空间就更少了。虽然服务能够满足目前的需求，但还有一些不太确定的风险。 第一，了解到程序中有很多缓存数据和静态统计数据，为了减少 MinorGC 的次数，通过分析 GC 日志打印的对象年龄分布，把 MaxTenuringThreshold 参数调整到了 3（特殊场景特殊的配置）。这个参数是让年轻代的这些对象，赶紧回到老年代去，不要老呆在年轻代里。 第二，我们的 GC 时间比较长，就一块开了参数 CMSScavengeBeforeRemark，使得在 CMS remark 前，先执行一次 Minor GC 将新生代清掉。同时配合上个参数，其效果还是比较好的，一方面，对象很快晋升到了老年代，另一方面，年轻代的对象在这种情况下是有限的，在整个 MajorGC 中占的时间也有限。 第三，由于缓存的使用，有大量的弱引用，拿一次长达 10 秒的 GC 来说。我们发现在 GC 日志里，处理 weak refs 的时间较长，达到了 4.5 秒。这里可以加入参数 ParallelRefProcEnabled 来并行处理Refe","date":"2022-06-03","objectID":"/posts/tech/interview/interview-nw-java/:4:10","tags":["Java学习随笔","interview"],"title":"内部-design-1","uri":"/posts/tech/interview/interview-nw-java/"},{"categories":["Java"],"content":"线程调度 1、线程状态 ​ 线程是cpu任务调度的最小执行单位，每个线程拥有自己独立的程序计数器、虚拟机栈、本地方法栈 线程状态：创建、就绪、运行、阻塞、死亡 2、线程状态切换 | 方法 | 作用 | 区别 | | ——— | —————————————————— | —————- | | start | 启动线程，由虚拟机自动调度执行run()方法 | 线程处于就绪状态 | | run | 线程逻辑代码块处理，JVM调度执行 | 线程处于运行状态 | | sleep | 让当前正在执行的线程休眠（暂停执行） | 不释放锁 | | wait | 使得当前线程等待 | 释放同步锁 | | notify | 唤醒在此对象监视器上等待的单个线程 | 唤醒单个线程 | | notifyAll | 唤醒在此对象监视器上等待的所有线程 | 唤醒多个线程 | | yiled | 停止当前线程，让同等优先权的线程运行 | 用Thread类调用 | | join | 使当前线程停下来等待，直至另一个调用join方法的线程终止 | 用线程对象调用 | 3、阻塞唤醒过程 阻塞： ​ 这三个方法的调用都会使当前线程阻塞。该线程将会被放置到对该Object的请求等待队列中，然后让出当前对Object所拥有的所有的同步请求。线程会一直暂停所有线程调度，直到下面其中一种情况发生： ① 其他线程调用了该Object的notify方法，而该线程刚好是那个被唤醒的线程； ② 其他线程调用了该Object的notifyAll方法； 唤醒： ​ 线程将会从等待队列中移除，重新成为可调度线程。它会与其他线程以常规的方式竞争对象同步请求。一旦它重新获得对象的同步请求，所有之前的请求状态都会恢复，也就是线程调用wait的地方的状态。线程将会在之前调用wait的地方继续运行下去。 为什么要出现在同步代码块中： ​ 由于wait()属于Object方法，调用之后会强制释放当前对象锁，所以在wait() 调用时必须拿到当前对象的监视器monitor对象。因此，wait()方法在同步方法/代码块中调用。 4、wait和sleep区别 wait 方法必须在 synchronized 保护的代码中使用，而 sleep 方法并没有这个要求。 wait 方法会主动释放 monitor 锁，在同步代码中执行 sleep 方法时，并不会释放 monitor 锁。 wait 方法意味着永久等待，直到被中断或被唤醒才能恢复，不会主动恢复，sleep 方法中会定义一个时间，时间到期后会主动恢复。 wait/notify 是 Object 类的方法，而 sleep 是 Thread 类的方法。 5、创建线程方式 实现 Runnable 接口（优先使用） public class RunnableThread implements Runnable { @Override public void run() {System.out.println('用实现Runnable接口实现线程');} } 实现Callable接口（有返回值可抛出异常） class CallableTask implements Callable\u003cInteger\u003e { @Override public Integer call() throws Exception { return new Random().nextInt();} } 继承Thread类（java不支持多继承） public class ExtendsThread extends Thread { @Override public void run() {System.out.println('用Thread类实现线程');} } 使用线程池（底层都是实现run方法） static class DefaultThreadFactory implements ThreadFactory { DefaultThreadFactory() { SecurityManager s = System.getSecurityManager(); group = (s != null) ? s.getThreadGroup() : Thread.currentThread().getThreadGroup(); namePrefix = \"pool-\" + poolNumber.getAndIncrement() +\"-thread-\"; } public Thread newThread(Runnable r) { Thread t = new Thread(group, r,namePrefix + threadNumber.getAndIncrement(),0); if (t.isDaemon()) t.setDaemon(false); //是否守护线程 if (t.getPriority() != Thread.NORM_PRIORITY) t.setPriority(Thread.NORM_PRIORITY); //线程优先级 return t; } } ","date":"2022-06-03","objectID":"/posts/tech/interview/interview-nw-java/:4:11","tags":["Java学习随笔","interview"],"title":"内部-design-1","uri":"/posts/tech/interview/interview-nw-java/"},{"categories":["Java"],"content":"线程池 优点：通过复用已创建的线程，降低资源损耗、线程可以直接处理队列中的任务加快响应速度、同时便于统一监控和管理。 1、线程池构造函数 /** * 线程池构造函数7大参数 */ public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime, TimeUnit unit,BlockingQueue\u003cRunnable\u003e workQueue,ThreadFactory threadFactory, RejectedExecutionHandler handler) {} 参数介绍： | 参数 | 作用 | | ———————— | ———————————————————— | | corePoolSize | 核心线程池大小 | | maximumPoolSize | 最大线程池大小 | | keepAliveTime | 线程池中超过 corePoolSize 数目的空闲线程最大存活时间； | | TimeUnit | keepAliveTime 时间单位 | | workQueue | 阻塞任务队列 | | threadFactory | 新建线程工厂 | | RejectedExecutionHandler | 拒绝策略。当提交任务数超过 maxmumPoolSize+workQueue 之和时，任务会交给RejectedExecutionHandler 来处理 | 2、线程处理任务过程： 当线程池小于corePoolSize，新提交任务将创建一个新线程执行任务，即使此时线程池中存在空闲线程。 当线程池达到corePoolSize时，新提交任务将被放入 workQueue 中，等待线程池中任务调度执行。 当workQueue已满，且 maximumPoolSize 大于 corePoolSize 时，新提交任务会创建新线程执行任务。 当提交任务数超过 maximumPoolSize 时，新提交任务由 RejectedExecutionHandler 处理。 当线程池中超过corePoolSize 线程，空闲时间达到 keepAliveTime 时，关闭空闲线程 。 3、线程拒绝策略 ​ 线程池中的线程已经用完了，无法继续为新任务服务，同时，等待队列也已经排满了，再也塞不下新任务了。这时候我们就需要拒绝策略机制合理的处理这个问题。 JDK 内置的拒绝策略如下： ​ **AbortPolicy：**直接抛出异常，阻止系统正常运行。可以根据业务逻辑选择重试或者放弃提交等策略。 ​ **CallerRunsPolicy ：**只要线程池未关闭，该策略直接在调用者线程中，运行当前被丢弃的任务。 ​ 不会造成任务丢失，同时减缓提交任务的速度，给执行任务缓冲时间。 ​ **DiscardOldestPolicy ：**丢弃最老的一个请求，也就是即将被执行的任务，并尝试再次提交当前任务。 ​ **DiscardPolicy ：**该策略默默地丢弃无法处理的任务，不予任何处理。如果允许任务丢失，这是最好的一种方案。 4、Execuors类实现线程池 **newSingleThreadExecutor()：**只有一个线程的线程池，任务是顺序执行，适用于一个一个任务执行的场景 **newCachedThreadPool()：**线程池里有很多线程需要同时执行，60s内复用，适用执行很多短期异步的小程序或者负载较轻的服务 **newFixedThreadPool()：**拥有固定线程数的线程池，如果没有任务执行，那么线程会一直等待，适用执行长期的任务。 **newScheduledThreadPool()：**用来调度即将执行的任务的线程池 newWorkStealingPool()：底层采用forkjoin的Deque，采用独立的任务队列可以减少竞争同时加快任务处理 因为以上方式都存在弊端： ​ FixedThreadPool 和 SingleThreadExecutor ： 允许请求的队列⻓度为 Integer.MAX_VALUE，会导致OOM。 ​ CachedThreadPool 和 ScheduledThreadPool ： 允许创建的线程数量为 Integer.MAX_VALUE，会导致OOM。 手动创建的线程池底层使用的是ArrayBlockingQueue可以防止OOM。 5、线程池大小设置 CPU 密集型（n+1） ​ CPU 密集的意思是该任务需要大量的运算，而没有阻塞，CPU 一直全速运行。 ​ CPU 密集型任务尽可能的少的线程数量，一般为 CPU 核数 + 1 个线程的线程池。 IO 密集型（2*n） ​ 由于 IO 密集型任务线程并不是一直在执行任务，可以多分配一点线程数，如 CPU * 2 ​ 也可以使用公式：CPU 核心数 *（1+平均等待时间/平均工作时间）。 ","date":"2022-06-03","objectID":"/posts/tech/interview/interview-nw-java/:4:12","tags":["Java学习随笔","interview"],"title":"内部-design-1","uri":"/posts/tech/interview/interview-nw-java/"},{"categories":["Java"],"content":"线程安全 1、乐观锁，CAS思想 java乐观锁机制： ​ 乐观锁体现的是悲观锁的反面。它是一种积极的思想，它总是认为数据是不会被修改的，所以是不会对数据上锁的。但是乐观锁在更新的时候会去判断数据是否被更新过。乐观锁的实现方案一般有两种（版本号机制和CAS）。乐观锁适用于读多写少的场景，这样可以提高系统的并发量。在Java中 java.util.concurrent.atomic下的原子变量类就是使用了乐观锁的一种实现方式CAS实现的。 乐观锁，大多是基于数据版本 (Version)记录机制实现。即为数据增加一个版本标识，在基于数据库表的版本解决方案中，一般是通过为数据库表增加一个 “version” 字段来 实现。 读取出数据时，将此版本号一同读出，之后更新时，对此版本号加一。此时，将提 交数据的版本数据与数据库表对应记录的当前版本信息进行比对，如果提交的数据 版本号大于数据库表当前版本号，则予以更新，否则认为是过期数据。 CAS思想： ​ CAS就是compare and swap（比较交换），是一种很出名的无锁的算法，就是可以不使用锁机制实现线程间的同步。使用CAS线程是不会被阻塞的，所以又称为非阻塞同步。CAS算法涉及到三个操作： ​ 需要读写内存值V；进行比较的值A；准备写入的值B ​ 当且仅当V的值等于A的值等于V的值的时候，才用B的值去更新V的值，否则不会执行任何操作（比较和替换是一个原子操作-A和V比较，V和B替换），一般情况下是一个自旋操作，即不断重试 缺点： ​ ABA问题-知乎 ​ 高并发的情况下，很容易发生并发冲突，如果CAS一直失败，那么就会一直重试，浪费CPU资源 原子性： ​ 功能限制CAS是能保证单个变量的操作是原子性的，在Java中要配合使用volatile关键字来保证线程的安全；当涉及到多个变量的时候CAS无能为力；除此之外CAS实现需要硬件层面的支持，在Java的普通用户中无法直接使用，只能借助atomic包下的原子类实现，灵活性受到了限制 2、synchronized底层实现 **使用方法：**主要的三种使⽤⽅式 ​ 修饰实例⽅法: 作⽤于当前对象实例加锁，进⼊同步代码前要获得当前对象实例的锁 ​ 修饰静态⽅法: 也就是给当前类加锁，会作⽤于类的所有对象实例，因为静态成员不属于任何⼀个实例对象，是类成员。 ​ 修饰代码块: 指定加锁对象，对给定对象加锁，进⼊同步代码库前要获得给定对象的锁。 ​ 总结：synchronized锁住的资源只有两类：一个是对象，一个是类。 底层实现： ​ 对象头是我们需要关注的重点，它是synchronized实现锁的基础，因为synchronized申请锁、上锁、释放锁都与对象头有关。对象头主要结构是由Mark Word 组成，其中Mark Word存储对象的hashCode、锁信息或分代年龄或GC标志等信息。 ​ 锁也分不同状态，JDK6之前只有两个状态：无锁、有锁（重量级锁），而在JDK6之后对synchronized进行了优化，新增了两种状态，总共就是四个状态：无锁状态、偏向锁、轻量级锁、重量级锁，其中无锁就是一种状态了。锁的类型和状态在对象头Mark Word中都有记录，在申请锁、锁升级等过程中JVM都需要读取对象的Mark Word数据。 ​ 同步代码块是利用 monitorenter 和 monitorexit 指令实现的，而同步方法则是利用 flags 实现的。 3、ReenTrantLock底层实现 ​ 由于ReentrantLock是java.util.concurrent包下提供的一套互斥锁，相比Synchronized，ReentrantLock类提供了一些高级功能 使用方法： ​ 基于API层面的互斥锁，需要lock()和unlock()方法配合try/finally语句块来完成 底层实现： ​ ReenTrantLock的实现是一种自旋锁，通过循环调用CAS操作来实现加锁。它的性能比较好也是因为避免了使线程进入内核态的阻塞状态。想尽办法避免线程进入内核的阻塞状态是我们去分析和理解锁设计的关键钥匙。 和synchronized区别： ​ 1、底层实现：synchronized 是JVM层面的锁，是Java关键字，通过monitor对象来完成（monitorenter与monitorexit），ReentrantLock 是从jdk1.5以来（java.util.concurrent.locks.Lock）提供的API层面的锁。 ​ 2、实现原理**：synchronized 的实现涉及到锁的升级，具体为无锁、偏向锁、自旋锁、向OS申请重量级锁；ReentrantLock实现则是通过利用CAS（CompareAndSwap）自旋机制保证线程操作的原子性和volatile保证数据可见性以实现锁的功能。 ​ 3、是否可手动释放：synchronized 不需要用户去手动释放锁，synchronized 代码执行完后系统会自动让线程释放对锁的占用； ReentrantLock则需要用户去手动释放锁，如果没有手动释放锁，就可能导致死锁现象。 ​ 4、是否可中断synchronized是不可中断类型的锁，除非加锁的代码中出现异常或正常执行完成； ReentrantLock则可以中断，可通过trylock(long timeout,TimeUnit unit)设置超时方法或者将lockInterruptibly()放到代码块中，调用interrupt方法进行中断。 ​ 5、是否公平锁synchronized为非公平锁 ReentrantLock则即可以选公平锁也可以选非公平锁，通过构造方法new ReentrantLock时传入boolean值进行选择，为空默认false非公平锁，true为公平锁,公平锁性能非常低。 4、公平锁和非公平锁区别 公平锁： ​ 公平锁自然是遵循FIFO（先进先出）原则的，先到的线程会优先获取资源，后到的会进行排队等待 ​ **优点：**所有的线程都能得到资源，不会饿死在队列中。适合大任务 ​ **缺点：**吞吐量会下降，队列里面除了第一个线程，其他的线程都会阻塞，cpu唤醒阻塞线程的开销大 非公平锁： ​ 多个线程去获取锁的时候，会直接去尝试获取，获取不到，再去进入等待队列，如果能获取到，就直接获取到锁。 ​ **优点：**可以减少CPU唤醒线程的开销，整体的吞吐效率会高点，CPU也不必取唤醒所有线程，会减少唤起线程的数量。 ​ **缺点：**你们可能也发现了，这样可能导致队列中间的线程一直获取不到锁或者长时间获取不到锁 公平锁效率低原因： ​ 公平锁要维护一个队列，后来的线程要加锁，即使锁空闲，也要先检查有没有其他线程在 wait，如果有自己要挂起，加到队列后面，然后唤醒队列最前面线程。这种情况下相比较非公平锁多了一次挂起和唤醒。 ​ 线程切换的开销，其实就是非公平锁效率高于公平锁的原因，因为非公平锁减少了线程挂起的几率，后来的线程有一定几率逃离被挂起的开销。 5、使用层面锁优化 ​ 【1】减少锁的时间： ​ 不需要同步执行的代码，能不放在同步快里面执行就不要放在同步快内，可以让锁尽快释放； ​ 【2】减少锁的粒度： ​ 它的思想是将物理上的一个锁，拆成逻辑上的多个锁，增加并行度，从而降低锁竞争。它的思想也是用空间来换时间；java中很多数据结构都是采用这种方法提高并发操作的效率，比如： ​ ConcurrentHashMap： ​ java中的ConcurrentHashMap在jdk1.8之前的版本，使用一个Segment 数组：Segment\u003c K,V \u003e[] segments ​ Segment继承自ReenTrantLock，所以每个Segment是个可重入锁，每个Segment 有一个HashEntry\u003c K,V \u003e数组用来存放数据，put操作时，先确定往哪个Segment放数据，只需要锁定这个Segment，执行put，其它的Segment不会被锁定；所以数组中有多少个Segment就允许同一时刻多少个线程存放数据，这样增加了并发能力。 ​ 【3】锁粗化： ​ 大部分情况下我们是要让锁的粒度最小化，锁的粗化则是要增大锁的粒度; ​ 假如有一个循环，循环内的操作需要加锁，我们应该把锁放到循环外面，否则每次进出循环，都进出一次临界区，效率是非常差的； ​ 【4】使用读写锁： ​ ReentrantReadWriteLock 是一个读写锁，读操作加读锁，可并发读，写操作使用写锁，只能单线程写； ​ 【5】使用CAS： ​ 如果需要同步的操作执行速度非常快，并且线程竞争并不激烈，这时候使用cas效率会更高，因为加锁会导致线程的上下文切换，如果上下文切换的耗时比同步操作本身更耗时，且线程对资源的竞争不激烈，使用volatiled+cas操作会是非常高效的选择； 6、系统层面锁优化 自适应自旋锁： ​ 自旋锁可以避免等待竞争锁进入阻塞挂起状态被唤醒造成的内核态和用户态之间的切换的损耗，它们只需要等一等（自旋），但是如果锁被其他线程长时间占用，一直不释放CPU，死等会带来更多的性能开销；自旋次数默认值是10 ​ 对上面自旋锁优化方式的进一步优化，它的自旋的次数不再固定，其自旋的次数由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定，这就解决了自旋锁带来的缺点 锁消除： ​ 锁削除是指虚拟机即时编译器在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行削除。Netty中无锁化设计pipeline中channelha","date":"2022-06-03","objectID":"/posts/tech/interview/interview-nw-java/:4:13","tags":["Java学习随笔","interview"],"title":"内部-design-1","uri":"/posts/tech/interview/interview-nw-java/"},{"categories":["Java"],"content":"内存模型 ​ Java 内存模型（Java Memory Model，JMM）就是一种符合内存模型规范的，屏蔽了各种硬件和操作系统的访问差异的，保证了 Java 程序在各种平台下对内存的访问都能保证效果一致的机制及规范。 ​ JMM 是一种规范，是解决由于多线程通过共享内存进行通信时，存在的本地内存数据不一致、编译器会对代码指令重排序、处理器会对代码乱序执行等带来的问题。目的是保证并发编程场景中的原子性、可见性和有序性。 原子性： ​ 在 Java 中，为了保证原子性，提供了两个高级的字节码指令 Monitorenter 和 Monitorexit。这两个字节码，在 Java 中对应的关键字就是 Synchronized。因此，在 Java 中可以使用 Synchronized 来保证方法和代码块内的操作是原子性的。 可见性： ​ Java 中的 Volatile 关键字修饰的变量在被修改后可以立即同步到主内存。被其修饰的变量在每次使用之前都从主内存刷新。因此，可以使用 Volatile 来保证多线程操作时变量的可见性。除了 Volatile，Java 中的 Synchronized 和 Final 两个关键字也可以实现可见性。只不过实现方式不同 有序性 ​ 在 Java 中，可以使用 Synchronized 和 Volatile 来保证多线程之间操作的有序性。区别：Volatile 禁止指令重排。Synchronized 保证同一时刻只允许一条线程操作。 1、volatile底层实现 作用： ​ 保证数据的“可见性”：被volatile修饰的变量能够保证每个线程能够获取该变量的最新值，从而避免出现数据脏读的现象。 ​ 禁止指令重排：在多线程操作情况下，指令重排会导致计算结果不一致 底层实现： ​ “观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile关键字时，会多出一个lock前缀指令” lock前缀指令实际上相当于一个内存屏障（也成内存栅栏），内存屏障会提供3个功能： 1）它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面； 2）它会强制将对缓存的修改操作立即写入主存； 3）如果是写操作，它会导致其他CPU中对应的缓存行无效。 单例模式中volatile的作用： 防止代码读取到instance不为null时，instance引用的对象有可能还没有完成初始化。 class Singleton{ private volatile static Singleton instance = null; //禁止指令重排 private Singleton() { } public static Singleton getInstance() { if(instance==null) { //减少加锁的损耗 synchronized (Singleton.class) { if(instance==null) //确认是否初始化完成 instance = new Singleton(); } } return instance; } } 2、AQS思想 ​ AQS的全称为（AbstractQueuedSynchronizer）抽象的队列式的同步器，是⼀个⽤来构建锁和同步器的框架，使⽤AQS能简单且⾼效地构造出应⽤⼴泛的⼤量的同步器，如：基于AQS实现的lock, CountDownLatch、CyclicBarrier、Semaphore需解决的问题： 状态的原子性管理 线程的阻塞与解除阻塞 队列的管理 ​ AQS核⼼思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的⼯作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占⽤，那么就需要⼀套线程阻塞等待以及被唤醒时锁分配的机制，这个机制AQS是⽤**CLH（虚拟的双向队列）**队列锁实现的，即将暂时获取不到锁的线程加⼊到队列中。 lock： ​ 是一种可重入锁，除了能完成 synchronized 所能完成的所有工作外，还提供了诸如可响应中断锁、可轮询锁请求、定时锁等避免多线程死锁的方法。默认为非公平锁，但可以初始化为公平锁； 通过方法 lock()与 unlock()来进行加锁与解锁操作； CountDownLatch： ​ 通过计数法（倒计时器），让一些线程堵塞直到另一个线程完成一系列操作后才被唤醒；该⼯具通常⽤来控制线程等待，它可以让某⼀个线程等待直到倒计时结束，再开始执⾏。具体可以使用countDownLatch.await()来等待结果。多用于多线程信息汇总。 CompletableFuture： ​ 通过设置参数，可以完成CountDownLatch同样的多平台响应问题，但是可以针对其中部分返回结果做更加灵活的展示。 CyclicBarrier： ​ 字面意思是可循环(Cyclic)使用的屏障（Barrier）。他要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活，线程进入屏障通过CyclicBarrier的await()方法。可以用于批量发送消息队列信息、异步限流。 Semaphore： ​ 信号量主要用于两个目的，一个是用于多个共享资源的互斥作用，另一个用于并发线程数的控制。SpringHystrix限流的思想 3、happens-before ​ 用来描述和可见性相关问题：如果第一个操作 happens-before 第二个操作，那么我们就说第一个操作对于第二个操作是可见的 ​ 常见的happens-before：volatile 、锁、线程生命周期。 四、MySQL篇 ","date":"2022-06-03","objectID":"/posts/tech/interview/interview-nw-java/:4:14","tags":["Java学习随笔","interview"],"title":"内部-design-1","uri":"/posts/tech/interview/interview-nw-java/"},{"categories":["Java"],"content":"WhyMysql？ NoSQL数据库四大家族 列存储 Hbase K-V存储 Redis 图像存储 Neo4j 文档存储 MongoDB 云存储OSS 海量Aerospike ​ Aerospike（简称AS）是一个分布式，可扩展的键值存储的NoSQL数据库。T级别大数据高并发的结构化**数据存储，**采用混合架构，索引存储在内存中，而数据可存储在机械硬盘(HDD)或固态硬盘(SSD) 上，读写操作达微妙级，99%的响应可在1毫秒内实现。 | | Aerospike | Redis | | ——– | ———————————— | —————————- | | 类型 | Nosql数据库 | 缓存 | | 线程数 | 多线程 | 单线程 | | 数据分片 | 自动处理相当于分片 | 提供分片算法、平衡各分片数据 | | 数据扩容 | 动态增加数据卷平衡流量 | 需停机 | | 数据同步 | 设置复制因子后可以透明的完成故障转移 | 手动故障转移和数据同步 | | 载体 | 内存存储索引+SSD存储数据 | 内存 | ​ Aerospike作为一个大容量的NoSql解决方案，适合对容量要求比较大，QPS相对低一些的场景，主要用在广告行业，个性化推荐厂告是建立在了和掌握消费者独特的偏好和习性的基础之上，对消费者的购买需求做出准确的预测或引导，在合适的位置、合适的时间，以合适的形式向消费者呈现与其需求高度吻合的广告，以此来促进用户的消费行为。 ​ （ETL数据仓库技术）抽取（extract）、转换（transform）、加载（load） 用户行为日志收集系统收集日志之后推送到ETL做数据的清洗和转换 把ETL过后的数据发送到推荐引擎计算每个消费者的推荐结果，其中推荐逻辑包括规则和算法两部分 收集用户最近浏览、最长停留等特征，分析商品相似性、用户相似性、相似性等算法。 把推荐引擎的结果存入Aerospike集群中，并提供给广告投放引擎实时获取 分别通过HDFS和HBASE对日志进行离线和实时的分析，然后把用户画像的标签(tag : 程序猿、宅男…)结果存入高性能的Nosql数据库Aerospike中，同时把数据备份到异地数据中心。前端广告投放请求通过决策引擎（投放引擎）向用户画像数据库中读取相应的用户画像数据，然后根据竞价算法出价进行竞价。竞价成功之后就可以展现广告了。而在竞价成功之后，具体给用户展现什么样的广告，就是有上面说的个性化推荐广告来完成的。 | | Aerospike | Mysql | | —- | ————– | ——– | | 库名 | Namespace | Database | | 表名 | Set | Table | | 记录 | Bin | Column | | 字段 | Record | Row | | 索引 | key 、 pk 、kv | pk | 图谱Neo4j Neo4j是一个开源基于java开发的图形noSql数据库，它将结构化数据存储在图中而不是表中。它是一个嵌入式的、基于磁盘的、具备完全的事务特性的Java持久化引擎。程序数据是在一个面向对象的、灵活的网络结构下，而不是严格的表中，但具备完全的事务特性、企业级的数据库的所有好处。 一种基于图的数据结构，由节点(Node)和边(Edge)组成。其中节点即实体，由一个全局唯一的ID标示，边就是关系用于连接两个节点。通俗地讲，知识图谱就是把所有不同种类的信息，连接在一起而得到的一个关系网络。知识图谱提供了从“关系”的角度去分析问题的能力。 互联网、大数据的背景下，谷歌、百度、搜狗等搜索引擎纷纷基于该背景，创建自己的知识图Knowledge Graph（谷歌）、知心（百度）和知立方（搜狗），主要用于改进搜索质量。 自己项目主要用作好友推荐，图数据库(Graph database)指的是以图数据结构的形式来存储和查询数据的数据库。关系图谱中，关系的组织形式采用的就是图结构，所以非常适合用图库进行存储。 优势总结: 性能上，使用cql查询，对长程关系的查询速度快 擅于发现隐藏的关系，例如通过判断图上两点之间有没有走的通的路径，就可以发现事物间的关联 // 查询三层级关系节点如下：with可以将前面查询结果作为后面查询条件 match (na:Person)-[re]-(nb:Person) where na.name=\"林婉儿\" WITH na,re,nb match (nb:Person)- [re2:Friends]-\u003e(nc:Person) return na,re,nb,re2,nc // 直接拼接关系节点查询 match data=(na:Person{name:\"范闲\"})-[re]-\u003e(nb:Person)-[re2]-\u003e(nc:Person) return data // 使用深度运算符 显然使用以上方式比较繁琐,可变数量的关系-\u003e节点可以使用-[:TYPE*minHops..maxHops]-。 match data=(na:Person{name:\"范闲\"})-[*1..2]-(nb:Person) return data 文档MongoDB MongoDB 是一个基于分布式文件存储的数据库，是非关系数据库中功能最丰富、最像关系数据库的。在高负载的情况下，通过添加更多的节点，可以保证服务器性能。由 C++ 编写，可以为 WEB 应用提供可扩展、高性能、易部署的数据存储解决方案。 什么是BSON {key:value,key2:value2}和Json类似，是一种二进制形式的存储格式，支持内嵌的文档对象和数组对象，但是BSON有JSON没有的一些数据类型，比如 value包括字符串,double,Array,DateBSON可以做为网络数据交换的一种存储形式,它的优点是灵活性高，但它的缺点是空间利用率不是很理想。 BSON有三个特点：轻量性、可遍历性、高效性 /* 查询 find() 方法可以传入多个键(key)，每个键(key)以逗号隔开*/ db.collection.find({key1:value1, key2:value2}).pretty() /* 更新 $set ：设置字段值 $unset :删除指定字段 $inc：对修改的值进行自增*/ db.collection.update({where},{$set:{字段名:值}},{multi:true}) /* 删除 justOne :如果设为true，只删除一个文档，默认false，删除所有匹配条件的文档*/ db.collection.remove({where}, {justOne: \u003cboolean\u003e, writeConcern: \u003c回执\u003e } ) 优点： 文档结构的存储方式，能够更便捷的获取数据。 对于一个层级式的数据结构来说，使用扁平式的，表状的结构来查询保存数据非常的困难。 内置GridFS，支持大容量的存储。 GridFS是一个出色的分布式文件系统，支持海量的数据存储，满足对大数据集的快速范围查询。 性能优越 千万级别的文档对象，近10G的数据，对有索引的ID的查询 不会比mysql慢，而对非索引字段的查询，则是全面胜出。 mysql实际无法胜任大数据量下任意字段的查询，而mongodb的查询性能实在牛逼。写入性能同样很令人满意，同样写入百万级别的数据，mongodb基本10分钟以下可以解决。 缺点： 不支持事务 磁盘占用空间大 MySQL 8.0 版本 1. 性能：MySQL 8.0 的速度要比 MySQL 5.7 快 2 倍。 2. NoSQL：MySQL 从 5.7 版本开始提供 NoSQL 存储功能，在 8.0 版本中nosql得到了更大的改进。 3. 窗口函数：实现若干新的查询方式。窗口函数与 SUM()、COUNT() 这种集合函数类似，但它不会将多行查询结果合并为一行，而是将结果放回多行当中，即窗口函数不需要 GROUP BY。 4. 隐藏索引：在 MySQL 8.0 中，索引可以被“隐藏”和“显示”。当对索引进行隐藏时，它不会被查询优化器所使用。我们可以使用这个特性用于性能调试，例如我们先隐藏一个索引，然后观察其对数据库的影响。如果数据库性能有所下降，说明这个索引是有用的，然后将其“恢复显示”即可；如果数据库性能看不出变化，说明这个索引是多余的，可以考虑删掉。 云存储 | | OSS | 自建 | | —— | ———————————————————— | ———————————————————— | | 可靠性 | 可用性不低于99.995%数据设计持久性不低于99.9999999999%（12个9） | 受限于硬件可靠性，易出问题，一旦出现磁盘坏道，容易出现不可逆转的数据丢失。人工数据恢复困难、耗时、耗力。 | | 安全 | 服务端加密、客户端加密、防盗链、IP黑白名单等。多用户资源隔离机制，支持异地容灾机制。 | 需要另外购买清洗和黑洞设备。需要单独实现安全机制。 | | 成本 | 多线BGP骨干网络，无带宽限制，上行流量免费。无需运维人员与托管费用，0成本运维。 | 单线或双线接入速度慢，有带宽限制，峰值时期需人工扩容。需专人运维，成本高。 | 使用步骤 ​ 1、开通服务 ​ 2、创建存储空间 ​ 3、上传文件、下载文件、删除文件 ​ 4、域名绑定、日志记录 ​ 5、根据开放接口进行鉴权访问 功能 ​ 图片编辑（裁剪、模糊、水印） ​ 视频截图 ​ 音频转码、视频修复 CDN加速 ​ 对象存储OSS与阿里云CDN服务结合，可优化静态热点文件下载加速的场景（即同","date":"2022-06-03","objectID":"/posts/tech/interview/interview-nw-java/:4:15","tags":["Java学习随笔","interview"],"title":"内部-design-1","uri":"/posts/tech/interview/interview-nw-java/"},{"categories":["Java"],"content":"事务 1、事务4大特性 **事务4大特性：**原子性、一致性、隔离性、持久性 ​ 原⼦性： 事务是最⼩的执⾏单位，不允许分割。事务的原⼦性确保动作要么全部完成，要么全不执行 ​ 一致性： 执⾏事务前后，数据保持⼀致，多个事务对同⼀个数据读取的结果是相同的； ​ 隔离性： 并发访问数据库时，⼀个⽤户的事务不被其他事务所⼲扰，各并发事务之间数据库是独⽴的； ​ 持久性： ⼀个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发⽣故障也不应该对其有任何影响。 实现保证： ​ MySQL的存储引擎InnoDB使用重做日志保证一致性与持久性，回滚日志保证原子性，使用各种锁来保证隔离性。 2、事务隔离级别 **读未提交：**最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。 **读已提交：**允许读取并发事务已经提交的数据，可以阻⽌脏读，但是幻读或不可重复读仍有可能发⽣。 **可重复读：**同⼀字段的多次读取结果都是⼀致的，除⾮数据是被本身事务⾃⼰所修改，可以阻⽌脏读和不可重复读，会有幻读。 **串行化：**最⾼的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执⾏，这样事务之间就完全不可能产⽣⼲扰。 | 隔离级别 | 并发问题 | | ——– | ——————————– | | 读未提交 | 可能会导致脏读、幻读或不可重复读 | | 读已提交 | 可能会导致幻读或不可重复读 | | 可重复读 | 可能会导致幻读 | | 可串行化 | 不会产⽣⼲扰 | ms 3、默认隔离级别-RR **默认隔离级别：**可重复读； ​ 同⼀字段的多次读取结果都是⼀致的，除⾮数据是被本身事务⾃⼰所修改； ​ 可重复读是有可能出现幻读的，如果要保证绝对的安全只能把隔离级别设置成SERIALIZABLE；这样所有事务都只能顺序执行，自然不会因为并发有什么影响了，但是性能会下降许多。 ​ 第二种方式，使用MVCC解决快照读幻读问题（如简单select），读取的不是最新的数据。维护一个字段作为version，这样可以控制到每次只能有一个人更新一个版本。 select id from table_xx where id = ? and version = V update id from table_xx where id = ? and version = V+1 ​ 第三种方式，如果需要读最新的数据，可以通过GapLock+Next-KeyLock可以解决当前读幻读问题， select id from table_xx where id \u003e 100 for update; select id from table_xx where id \u003e 100 lock in share mode; 4、RR和RC使用场景 ​ 事务隔离级别RC(read commit)和RR（repeatable read）两种事务隔离级别基于多版本并发控制MVCC(multi-version concurrency control）来实现。 | | RC | RR | | —— | ———————————— | ————————– | | 实现 | 多条查询语句会创建多个不同的ReadView | 仅需要一个版本的ReadView | | 粒度 | 语句级读一致性 | 事务级读一致性 | | 准确性 | 每次语句执行时间点的数据 | 第一条语句执行时间点的数据 | 5、行锁，表锁，意向锁 InnoDB⽀持⾏级锁(row-level locking)和表级锁,默认为⾏级锁 ​ InnoDB按照不同的分类的锁： ​ 共享/排它锁(Shared and Exclusive Locks)：行级别锁， ​ 意向锁(Intention Locks)，表级别锁 ​ 间隙锁(Gap Locks)，锁定一个区间 ​ 记录锁(Record Locks)，锁定一个行记录 表级锁：（串行化） ​ Mysql中锁定 粒度最大的一种锁，对当前操作的整张表加锁，实现简单 ，资源消耗也比较少，加锁快，不会出现死锁 。其锁定粒度最大，触发锁冲突的概率最高，并发度最低，MyISAM和 InnoDB引擎都支持表级锁。 行级锁：（RR、RC） ​ Mysql中锁定 粒度最小 的一种锁，只针对当前操作的行进行加锁。 行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。 InnoDB支持的行级锁，包括如下几种： ​ 记录锁（Record Lock）: 对索引项加锁，锁定符合条件的行。其他事务不能修改和删除加锁项； ​ 间隙锁（Gap Lock）: 对索引项之间的“间隙”加锁，锁定记录的范围，不包含索引项本身，其他事务不能在锁范围内插入数据。 ​ Next-key Lock： 锁定索引项本身和索引范围。即Record Lock和Gap Lock的结合。可解决幻读问题。 InnoDB 支持多粒度锁（multiple granularity locking），它允许行级锁与表级锁共存，而意向锁就是其中的一种表锁。 共享锁（ shared lock, S ）锁允许持有锁读取行的事务。加锁时将自己和子节点全加S锁，父节点直到表头全加IS锁 排他锁（ exclusive lock， X ）锁允许持有锁修改行的事务。 加锁时将自己和子节点全加X锁，父节点直到表头全加IX锁 意向共享锁（intention shared lock, IS）：事务有意向对表中的某些行加共享锁（S锁） 意向排他锁（intention exclusive lock, IX）：事务有意向对表中的某些行加排他锁（X锁） | 互斥性 | 共享锁（S） | 排它锁（X） | 意向共享锁IS | 意向排他锁IX | | ———— | ———– | ———– | ———— | ———— | | 共享锁（S） | ✅ | ❌ | ✅ | ❌ | | 排它锁（X） | ❌ | ❌ | ❌ | ❌ | | 意向共享锁IS | ✅ | ❌ | ✅ | ✅ | | 意向排他锁IX | ❌ | ❌ | ✅ | ✅ | 6、MVCC多版本并发控制 ​ MVCC是一种多版本并发控制机制，通过事务的可见性看到自己预期的数据，能降低其系统开销.（RC和RR级别工作） ​ InnoDB的MVCC,是通过在每行记录后面保存系统版本号(可以理解为事务的ID)，每开始一个新的事务，系统版本号就会自动递增，事务开始时刻的系统版本号会作为事务的ID。这样可以确保事务读取的行，要么是在事务开始前已经存在的，要么是事务自身插入或者修改过的，防止幻读的产生。 ​ 1.MVCC手段只适用于Msyql隔离级别中的读已提交（Read committed）和可重复读（Repeatable Read）. ​ 2.Read uncimmitted由于存在脏读，即能读到未提交事务的数据行，所以不适用MVCC. ​ 3.简单的select快照度不会加锁，删改及select for update等需要当前读的场景会加锁 ​ 原因是MVCC的创建版本和删除版本只要在事务提交后才会产生。客观上，mysql使用的是乐观锁的一整实现方式，就是每行都有版本号，保存时根据版本号决定是否成功。Innodb的MVCC使用到的快照存储在Undo日志中，该日志通过回滚指针把一个数据行所有快照连接起来。 版本链 在InnoDB引擎表中，它的聚簇索引记录中有两个必要的隐藏列： trx_id 这个id用来存储的每次对某条聚簇索引记录进行修改的时候的事务id。 roll_pointer 每次对哪条聚簇索引记录有修改的时候，都会把老版本写入undo日志中。这个roll_pointer就是存了一个指针，它指向这条聚簇索引记录的上一个版本的位置，通过它来获得上一个版本的记录信息。(注意插入操作的undo日志没有这个属性，因为它没有老版本) 每次修改都会在版本链中记录。**SELECT可以去版本链中拿记录，这就实现了读-写，写-读的并发执行，**提升了系统的性能。 ","date":"2022-06-03","objectID":"/posts/tech/interview/interview-nw-java/:4:16","tags":["Java学习随笔","interview"],"title":"内部-design-1","uri":"/posts/tech/interview/interview-nw-java/"},{"categories":["Java"],"content":"索引 1、Innodb和Myisam引擎 **Myisam：**支持表锁，适合读密集的场景，不支持外键，不支持事务，索引与数据在不同的文件 **Innodb：**支持行、表锁，默认为行锁，适合并发场景，支持外键，支持事务，索引与数据同一文件 2、哈希索引 ​ 哈希索引用索引列的值计算该值的hashCode，然后在hashCode相应的位置存执该值所在行数据的物理位置，因为使用散列算法，因此访问速度非常快，但是一个值只能对应一个hashCode，而且是散列的分布方式，因此哈希索引不支持范围查找和排序的功能 3、B+树索引 优点： ​ B+树的磁盘读写代价低，更少的查询次数，查询效率更加稳定，有利于对数据库的扫描 ​ B+树是B树的升级版，B+树只有叶节点存放数据，其余节点用来索引。索引节点可以全部加入内存，增加查询效率，叶子节点可以做双向链表，从而提高范围查找的效率，增加的索引的范围 ​ 在大规模数据存储的时候，红黑树往往出现由于树的深度过大而造成磁盘IO读写过于频繁，进而导致效率低下的情况。所以，只要我们通过某种较好的树结构减少树的结构尽量减少树的高度，B树与B+树可以有多个子女，从几十到上千，可以降低树的高度。 ​ 磁盘预读原理：将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入。为了达到这个目的，在实际实现B-Tree还需要使用如下技巧：每次新建节点时，直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页里，加之计算机存储分配都是按页对齐的，就实现了一个node只需一次I/O。 4、创建索引 CREATE [UNIQUE | FULLTEXT] INDEX 索引名 ON 表名(字段名) [USING 索引方法]； 说明： UNIQUE:可选。表示索引为唯一性索引。 FULLTEXT:可选。表示索引为全文索引。 INDEX和KEY:用于指定字段为索引，两者选择其中之一就可以了，作用是一样的。 索引名:可选。给创建的索引取一个新名称。 字段名1:指定索引对应的字段的名称，该字段必须是前面定义好的字段。 注：索引方法默认使用B+TREE。 5、聚簇索引和非聚簇索引 ​ **聚簇索引：**将数据存储与索引放到了一块，索引结构的叶子节点保存了行数据（主键索引） ​ **非聚簇索引：**将数据与索引分开存储，索引结构的叶子节点指向了数据对应的位置（辅助索引） ​ 聚簇索引的叶子节点就是数据节点，而非聚簇索引的叶子节点仍然是索引节点，只不过有指向对应数据块的指针。 6、最左前缀问题 ​ 最左前缀原则主要使用在联合索引中，联合索引的B+Tree是按照第一个关键字进行索引排列的。 ​ 联合索引的底层是一颗B+树，只不过联合索引的B+树节点中存储的是键值。由于构建一棵B+树只能根据一个值来确定索引关系，所以数据库依赖联合索引最左的字段来构建。 ​ 采用\u003e、\u003c等进行匹配都会导致后面的列无法走索引，因为通过以上方式匹配到的数据是不可知的。 ","date":"2022-06-03","objectID":"/posts/tech/interview/interview-nw-java/:4:17","tags":["Java学习随笔","interview"],"title":"内部-design-1","uri":"/posts/tech/interview/interview-nw-java/"},{"categories":["Java"],"content":"SQL查询 1、SQL语句的执行过程 查询语句： select * from student A where A.age='18' and A.name='张三'; 结合上面的说明，我们分析下这个语句的执行流程： ①通过客户端/服务器通信协议与 MySQL 建立连接。并查询是否有权限 ②Mysql8.0之前开看是否开启缓存，开启了 Query Cache 且命中完全相同的 SQL 语句，则将查询结果直接返回给客户端； ③由解析器进行语法语义解析，并生成解析树。如查询是select、表名tb_student、条件是id=‘1’ ④查询优化器生成执行计划。根据索引看看是否可以优化 ⑤查询执行引擎执行 SQL 语句，根据存储引擎类型，得到查询结果。若开启了 Query Cache，则缓存，否则直接返回。 2、回表查询和覆盖索引 普通索引（唯一索引+联合索引+全文索引）需要扫描两遍索引树 （1）先通过普通索引定位到主键值id=5； （2）在通过聚集索引定位到行记录； 这就是所谓的回表查询，先定位主键值，再定位行记录，它的性能较扫一遍索引树更低。 覆盖索引：主键索引==聚簇索引==覆盖索引 ​ 如果where条件的列和返回的数据在一个索引中，那么不需要回查表，那么就叫覆盖索引。 实现覆盖索引：常见的方法是，将被查询的字段，建立到联合索引里去。 3、Explain及优化 参考：https://www.jianshu.com/p/8fab76bbf448 mysql\u003e explain select * from staff; +----+-------------+-------+------+---------------+------+---------+------+------+-------+ | id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra | +----+-------------+-------+------+---------------+------+---------+------+------+-------+ | 1 | SIMPLE | staff | ALL | NULL | 索引 | NULL | NULL | 2 | NULL | +----+-------------+-------+------+---------------+------+---------+------+------+-------+ 1 row in set 索引优化： ​ ①最左前缀索引：like只用于’string%’，语句中的=和in会动态调整顺序 ​ ②唯一索引：唯一键区分度在0.1以上 ​ ③无法使用索引：!= 、is null 、 or、\u003e\u003c 、（5.7以后根据数量自动判定）in 、not in ​ ④联合索引：避免select * ，查询列使用覆盖索引 SELECT uid From user Where gid = 2 order by ctime asc limit 10 ALTER TABLE user add index idx_gid_ctime_uid(gid,ctime,uid) #创建联合覆盖索引，避免回表查询 语句优化： ​ ①char固定长度查询效率高，varchar第一个字节记录数据长度 ​ ②应该针对Explain中Rows增加索引 ​ ③group/order by字段均会涉及索引 ​ ④Limit中分页查询会随着start值增大而变缓慢，通过子查询+表连接解决 select * from mytbl order by id limit 100000,10 改进后的SQL语句如下： select * from mytbl where id \u003e= ( select id from mytbl order by id limit 100000,1 ) limit 10 select * from mytbl inner ori join (select id from mytbl order by id limit 100000,10) as tmp on tmp.id=ori.id; ​ ⑤count会进行全表扫描，如果估算可以使用explain ​ ⑥delete删除表时会增加大量undo和redo日志， 确定删除可使用trancate 表结构优化： ​ ①单库不超过200张表 ​ ②单表不超过500w数据 ​ ③单表不超过40列 ​ ④单表索引不超过5个 数据库范式 ： ​ ①第一范式（1NF）列不可分割 ​ ②第二范式（2NF）属性完全依赖于主键 [ 消除部分子函数依赖 ] ​ ③第三范式（3NF）属性不依赖于其它非主属性 [ 消除传递依赖 ] 配置优化： ​ 配置连接数、禁用Swap、增加内存、升级SSD硬盘 4、JOIN查询 left join(左联接) 返回包括左表中的所有记录和右表中关联字段相等的记录 right join(右联接) 返回包括右表中的所有记录和左表中关联字段相等的记录 inner join(等值连接) 只返回两个表中关联字段相等的行 ","date":"2022-06-03","objectID":"/posts/tech/interview/interview-nw-java/:4:18","tags":["Java学习随笔","interview"],"title":"内部-design-1","uri":"/posts/tech/interview/interview-nw-java/"},{"categories":["Java"],"content":"集群 1、主从复制过程 MySQl主从复制： 原理：将主服务器的binlog日志复制到从服务器上执行一遍，达到主从数据的一致状态。 过程：从库开启一个I/O线程，向主库请求Binlog日志。主节点开启一个binlog dump线程，检查自己的二进制日志，并发送给从节点；从库将接收到的数据保存到中继日志（Relay log）中，另外开启一个SQL线程，把Relay中的操作在自身机器上执行一遍 优点： 作为备用数据库，并且不影响业务 可做读写分离，一个写库，一个或多个读库，在不同的服务器上，充分发挥服务器和数据库的性能，但要保证数据的一致性 **binlog记录格式：**statement、row、mixed ​ 基于语句statement的复制、基于行row的复制、基于语句和行（mix）的复制。其中基于row的复制方式更能保证主从库数据的一致性，但日志量较大，在设置时考虑磁盘的空间问题 2、数据一致性问题 “主从复制有延时”，这个延时期间读取从库，可能读到不一致的数据。 缓存记录写key法： ​ 在cache里记录哪些记录发生过的写请求，来路由读主库还是读从库 异步复制： ​ 在异步复制中，主库执行完操作后，写入binlog日志后，就返回客户端，这一动作就结束了，并不会验证从库有没有收到，完不完整，所以这样可能会造成数据的不一致。 半同步复制： ​ 当主库每提交一个事务后，不会立即返回，而是等待其中一个从库接收到Binlog并成功写入Relay-log中才返回客户端，通过一份在主库的Binlog，另一份在其中一个从库的Relay-log，可以保证了数据的安全性和一致性。 全同步复制： ​ 指当主库执行完一个事务，所有的从库都执行了该事务才返回给客户端。因为需要等待所有从库执行完该事务才能返回，所以全同步复制的性能必然会收到严重的影响。 3、集群架构 Keepalived + VIP + MySQL 主从/双主 ​ 当写节点 Master db1 出现故障时，由 MMM Monitor 或 Keepalived 触发切换脚本，将 VIP 漂移到可用的 Master db2 上。当出现网络抖动或网络分区时，MMM Monitor 会误判，严重时来回切换写 VIP 导致集群双写，当数据复制延迟时，应用程序会出现数据错乱或数据冲突的故障。有效避免单点失效的架构就是采用共享存储，单点故障切换可以通过分布式哨兵系统监控。 **架构选型：**MMM 集群 -\u003e MHA集群 -\u003e MHA+Arksentinel。 4、故障转移和恢复 转移方式及恢复方法 1. 虚拟IP或DNS服务 （Keepalived +VIP/DNS 和 MMM 架构） ​ 问题：在虚拟 IP 运维过程中，刷新ARP过程中有时会出现一个 VIP 绑定在多台服务器同时提供连接的问题。这也是为什么要避免使用 Keepalived+VIP 和 MMM 架构的原因之一，因为它处理不了这类问题而导致集群多点写入。 2. 提升备库为主库（MHA、QMHA） ​ 尝试将原 Master 设置 read_only 为 on，避免集群多点写入。借助 binlog server 保留 Master 的 Binlog；当出现数据延迟时，再提升 Slave 为新 Master 之前需要进行数据补齐，否则会丢失数据。 ","date":"2022-06-03","objectID":"/posts/tech/interview/interview-nw-java/:4:19","tags":["Java学习随笔","interview"],"title":"内部-design-1","uri":"/posts/tech/interview/interview-nw-java/"},{"categories":["Java"],"content":"面试题 分库分表 如何进行分库分表 分表用户id进行分表，每个表控制在300万数据。 分库根据业务场景和地域分库，每个库并发不超过2000 Sharding-jdbc 这种 client 层方案的优点在于不用部署，运维成本低，不需要代理层的二次转发请求，性能很高，但是各个系统都需要耦合 Sharding-jdbc 的依赖，升级比较麻烦 Mycat 这种 proxy 层方案的缺点在于需要部署，自己运维一套中间件，运维成本高，但是好处在于对于各个项目是透明的，如果遇到升级之类的都是自己中间件那里搞就行了 水平拆分：一个表放到多个库，分担高并发，加快查询速度 id保证业务在关联多张表时可以在同一库上操作 range方便扩容和数据统计 hash可以使得数据更加平均 垂直拆分：一个表拆成多个表，可以将一些冷数据拆分到冗余库中 不是写瓶颈优先进行分表 分库数据间的数据无法再通过数据库直接查询了。会产生深分页的问题 分库越多，出现问题的可能性越大，维护成本也变得更高。 分库后无法保障跨库间事务，只能借助其他中间件实现最终一致性。 分库首先需考虑满足业务最核心的场景： 1、订单数据按用户分库，可以提升用户的全流程体验 2、超级客户导致数据倾斜可以使用最细粒度唯一标识进行hash拆分 3、按照最细粒度如订单号拆分以后，数据库就无法进行单库排重了 三个问题： 富查询：采用分库分表之后，如何满足跨越分库的查询？使用ES的宽表 借助分库网关+分库业务虽然能够实现多维度查询的能力，但整体上性能不佳且对正常的写入请求有一定的影响。业界应对多维度实时查询的最常见方式便是借助 ElasticSearch 数据倾斜：数据分库基础上再进行分表 分布式事务：跨多库的修改及多个微服务间的写操作导致的分布式事务问题？ 深分页问题：按游标查询，或者叫每次查询都带上上一次查询经过排序后的最大 ID 如何将老数据进行迁移 双写不中断迁移 线上系统里所有写库的地方，增删改操作，除了对老库增删改，都加上对新库的增删改 系统部署以后，还需要跑程序读老库数据写新库，写的时候需要判断updateTime 循环执行，直至两个库的数据完全一致，最后重新部署分库分表的代码就行了 系统性能的评估及扩容 和家亲目前有1亿用户：场景 10万写并发，100万读并发，60亿数据量 设计时考虑极限情况，32库*32表~64个表，一共1000 ~ 2000张表 支持3万的写并发，配合MQ实现每秒10万的写入速度 读写分离6万读并发，配合分布式缓存每秒100读并发 2000张表每张300万，可以最多写入60亿的数据 32张用户表，支撑亿级用户，后续最多也就扩容一次 动态扩容的步骤 推荐是 32 库 * 32 表，对于我们公司来说，可能几年都够了。 配置路由的规则，uid % 32 = 库，uid / 32 % 32 = 表 扩容的时候，申请增加更多的数据库服务器，呈倍数扩容 由 DBA 负责将原先数据库服务器的库，迁移到新的数据库服务器上去 修改一下配置，重新发布系统，上线，原先的路由规则变都不用变 直接可以基于 n 倍的数据库服务器的资源，继续进行线上系统的提供服务。 如何生成自增的id主键 使用redis可以 并发不高可以单独起一个服务，生成自增id 设置数据库step自增步长可以支撑水平伸缩 UUID适合文件名、编号，但是不适合做主键 snowflake雪花算法，综合了41时间（ms）、10机器、12序列号（ms内自增） 其中机器预留的10bit可以根据自己的业务场景配置 ","date":"2022-06-03","objectID":"/posts/tech/interview/interview-nw-java/:4:20","tags":["Java学习随笔","interview"],"title":"内部-design-1","uri":"/posts/tech/interview/interview-nw-java/"},{"categories":["Java"],"content":"线上故障及优化 更新失败 | 主从同步延时 以前线上确实处理过因为主从同步延时问题而导致的线上的 bug，属于小型的生产事故。 是这个么场景。有个同学是这样写代码逻辑的。先插入一条数据，再把它查出来，然后更新这条数据。在生产环境高峰期，写并发达到了 2000/s，这个时候，主从复制延时大概是在小几十毫秒。线上会发现，每天总有那么一些数据，我们期望更新一些重要的数据状态，但在高峰期时候却没更新。用户跟客服反馈，而客服就会反馈给我们。 我们通过 MySQL 命令： show slave status 查看 Seconds_Behind_Master ，可以看到从库复制主库的数据落后了几 ms。 一般来说，如果主从延迟较为严重，有以下解决方案： 分库，拆分为多个主库，每个主库的写并发就减少了几倍，主从延迟可以忽略不计。 重写代码，写代码的同学，要慎重，插入数据时立马查询可能查不到。 如果确实是存在必须先插入，立马要求就查询到，然后立马就要反过来执行一些操作，对这个查询设置直连主库或者延迟查询。主从复制延迟一般不会超过50ms 应用崩溃 | 分库分表优化 ​ 我们有一个线上通行记录的表，由于数据量过大，进行了分库分表，当时分库分表初期经常产生一些问题。典型的就是通行记录查询中使用了深分页，通过一些工具如MAT、Jstack追踪到是由于sharding-jdbc内部引用造成的。 ​ 通行记录数据被存放在两个库中。如果没有提供切分键，查询语句就会被分发到所有的数据库中，比如查询语句是 limit 10、offset 1000，最终结果只需要返回 10 条记录，但是数据库中间件要完成这种计算，则需要 (1000+10)*2=2020 条记录来完成这个计算过程。如果 offset 的值过大，使用的内存就会暴涨。虽然 sharding-jdbc 使用归并算法进行了一些优化，但在实际场景中，深分页仍然引起了内存和性能问题。 ​ 这种在中间节点进行归并聚合的操作，在分布式框架中非常常见。比如在 ElasticSearch 中，就存在相似的数据获取逻辑，不加限制的深分页，同样会造成 ES 的内存问题。 业界解决方案： 方法一：全局视野法 （1）将order by time offset X limit Y，改写成order by time offset 0 limit X+Y （2）服务层对得到的N*(X+Y)条数据进行内存排序，内存排序后再取偏移量X后的Y条记录 这种方法随着翻页的进行，性能越来越低。 方法二：业务折衷法-禁止跳页查询 （1）用正常的方法取得第一页数据，并得到第一页记录的time_max （2）每次翻页，将order by time offset X limit Y，改写成order by time where time\u003e$time_max limit Y 以保证每次只返回一页数据，性能为常量。 方法三：业务折衷法-允许模糊数据 （1）将order by time offset X limit Y，改写成order by time offset X/N limit Y/N 方法四：二次查询法 （1）将order by time offset X limit Y，改写成order by time offset X/N limit Y （2）找到最小值time_min （3）between二次查询，order by time between $time_min and $time_i_max （4）设置虚拟time_min，找到time_min在各个分库的offset，从而得到time_min在全局的offset （5）得到了time_min在全局的offset，自然得到了全局的offset X limit Y 查询异常 | SQL 调优 分库分表前，有一段用用户名来查询某个用户的 SQL 语句： select * from user where name = \"xxx\" and community=\"other\"; 为了达到动态拼接的效果，这句 SQL 语句被一位同事进行了如下修改。他的本意是，当 name 或者 community 传入为空的时候，动态去掉这些查询条件。这种写法，在 MyBaits 的配置文件中，也非常常见。大多数情况下，这种写法是没有问题的，因为结果集合是可以控制的。但随着系统的运行，用户表的记录越来越多，当传入的 name 和 community 全部为空时，悲剧的事情发生了: select * from user where 1=1 数据库中的所有记录，都会被查询出来，载入到 JVM 的内存中。由于数据库记录实在太多，直接把内存给撑爆了。由于这种原因引起的内存溢出，发生的频率非常高，比如导入Excel文件时。 通常的解决方式是强行加入分页功能，或者对一些必填的参数进行校验 Controller 层 现在很多项目都采用前后端分离架构，所以 Controller 层的方法，一般使用 @ResponseBody 注解，把查询的结果，解析成 JSON 数据返回。这在数据集非常大的情况下，会占用很多内存资源。假如结果集在解析成 JSON 之前，占用的内存是 10MB，那么在解析过程中，有可能会使用 20M 或者更多的内存 因此，保持结果集的精简，是非常有必要的，这也是 DTO（Data Transfer Object）存在的必要。互联网环境不怕小结果集的高并发请求，却非常恐惧大结果集的耗时请求，这是其中一方面的原因。 Service 层 Service 层用于处理具体的业务，更加贴合业务的功能需求。一个 Service，可能会被多个 Controller 层所使用，也可能会使用多个 dao 结构的查询结果进行计算、拼装。 int getUserSize() { List\u003cUser\u003e users = dao.getAllUser(); return null == users ? 0 : users.size(); } 代码review中发现了定时炸弹，这种在数据量达到一定程度后，才会暴露问题。 ORM 层 比如使用Mybatis时，有一个批量导入服务，在 MyBatis 执行批量插入的时候，竟然产生了内存溢出，按道理这种插入操作是不会引起额外内存占用的，最后通过源码追踪到了问题。 这是因为 MyBatis 循环处理 batch 的时候，操作对象是数组，而我们在接口定义的时候，使用的是 List；当传入一个非常大的 List 时，它需要调用 List 的 toArray 方法将列表转换成数组（浅拷贝）；在最后的拼装阶段，又使用了 StringBuilder 来拼接最终的 SQL，所以实际使用的内存要比 List 多很多。 事实证明，不论是插入操作还是查询动作，只要涉及的数据集非常大，就容易出现问题。由于项目中众多框架的引入，想要分析这些具体的内存占用，就变得非常困难。所以保持小批量操作和结果集的干净，是一个非常好的习惯。 五、Redis篇 ","date":"2022-06-03","objectID":"/posts/tech/interview/interview-nw-java/:4:21","tags":["Java学习随笔","interview"],"title":"内部-design-1","uri":"/posts/tech/interview/interview-nw-java/"},{"categories":["Java"],"content":"WhyRedis ​ 速度快，完全基于内存，使用C语言实现，网络层使用epoll解决高并发问题，单线程模型避免了不必要的上下文切换及竞争条件； | | GuavaCache | Tair | EVCache | Aerospike | | —— | ———– | ———- | ———— | —————– | | 类别 | 本地JVM缓存 | 分布式缓存 | 分布式缓存 | 分布式nosql数据库 | | 应用 | 本地缓存 | 淘宝 | Netflix、AWS | 广告 | | 性能 | 非常高 | 较高 | 很高 | 较高 | | 持久化 | 无 | 有 | 有 | 有 | | 集群 | 无 | 灵活配置 | 有 | 自动扩容 | ​ 与传统数据库不同的是 Redis 的数据是存在内存中的，所以读写速度非常快，因此 redis 被广泛应用于缓存方向，每秒可以处理超过 10万次读写操作，是已知性能最快的Key-Value DB。另外，Redis 也经常用来做分布式锁。除此之外，Redis 支持事务 、持久化、LUA脚本、LRU驱动事件、多种集群方案。 1、简单高效 ​ 1）完全基于内存，绝大部分请求是纯粹的内存操作。数据存在内存中，类似于 HashMap，查找和操作的时间复杂度都是O(1)； ​ 2）数据结构简单，对数据操作也简单，Redis 中的数据结构是专门进行设计的； ​ 3）采用单线程，避免了多线程不必要的上下文切换和竞争条件，不存在加锁释放锁操作，减少了因为锁竞争导致的性能消耗；（6.0以后多线程） ​ 4）使用EPOLL多路 I/O 复用模型，非阻塞 IO； ​ 5）使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis 直接自己构建了 VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求； 2、Memcache | redis | Memcached | | ————————————- | ————————– | | 内存高速数据库 | 高性能分布式内存缓存数据库 | | 支持hash、list、set、zset、string结构 | 只支持key-value结构 | | 将大部分数据放到内存 | 全部数据放到内存中 | | 支持持久化、主从复制备份 | 不支持数据持久化及数据备份 | | 数据丢失可通过AOF恢复 | 挂掉后，数据不可恢复 | | 单线程（2~4万TPS） | 多线程（20-40万TPS） | 使用场景： ​ 1、如果有持久方面的需求或对数据类型和处理有要求的应该选择redis。 ​ 2、如果简单的key/value 存储应该选择memcached。 3、Tair ​ Tair(Taobao Pair)是淘宝开发的分布式Key-Value存储引擎，既可以做缓存也可以做数据源（三种引擎切换） MDB（Memcache）属于内存型产品,支持kv和类hashMap结构,性能最优 RDB（Redis）支持List.Set.Zset等复杂的数据结构,性能次之,可提供缓存和持久化存储两种模式 LDB（levelDB）属于持久化产品,支持kv和类hashmap结构,性能较前两者稍低,但持久化可靠性最高 分布式缓存 大访问少量临时数据的存储（kb左右） 用于缓存，降低对后端数据库的访问压力 session场景 高速访问某些数据结构的应用和计算（rdb） 数据源存储 快速读取数据（fdb） 持续大数据量的存入读取（ldb），交易快照 高频度的更新读取（ldb），库存 痛点：redis集群中，想借用缓存资源必须得指明redis服务器地址去要。这就增加了程序的维护复杂度。因为redis服务器很可能是需要频繁变动的。所以人家淘宝就想啊，为什么不能像操作分布式数据库或者hadoop那样。增加一个中央节点，让他去代理所有事情。在tair中程序只要跟tair中心节点交互就OK了。同时tair里还有配置服务器概念。又免去了像操作hadoop那样，还得每台hadoop一套一模一样配置文件。改配置文件得整个集群都跟着改。 4、Guava ​ 分布式缓存一致性更好一点，用于集群环境下多节点使用同一份缓存的情况；有网络IO，吞吐率与缓存的数据大小有较大关系； ​ 本地缓存非常高效，本地缓存会占用堆内存，影响垃圾回收、影响系统性能。 本地缓存设计： ​ 以 Java 为例，使用自带的 map 或者 guava 实现的是本地缓存，最主要的特点是轻量以及快速，生命周期随着 jvm 的销毁而结束，并且在多实例的情况，每个实例都需要各自保存一份缓存，缓存不具有一致性。 解决缓存过期： ​ 1、将缓存过期时间调为永久 ​ 2、将缓存失效时间分散开，不要将缓存时间长度都设置成一样；比如我们可以在原有的失效时间基础上增加一个随机值，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。 解决内存溢出： ​ 第一步，修改JVM启动参数，直接增加内存。(-Xms，-Xmx参数一定不要忘记加。) 第二步，检查错误日志，查看“OutOfMemory”错误前是否有其它异常或错误。 第三步，对代码进行走查和分析，找出可能发生内存溢出的位置。 Google Guava Cache 自己设计本地缓存痛点： 不能按照一定的规则淘汰数据，如 LRU，LFU，FIFO 等。 清除数据时的回调通知 并发处理能力差，针对并发可以使用CurrentHashMap，但缓存的其他功能需要自行实现 缓存过期处理，缓存数据加载刷新等都需要手工实现 Guava Cache 的场景： 对性能有非常高的要求 不经常变化，占用内存不大 有访问整个集合的需求 数据允许不实时一致 Guava Cache 的优势： 缓存过期和淘汰机制 在GuavaCache中可以设置Key的过期时间，包括访问过期和创建过期。GuavaCache在缓存容量达到指定大小时，采用LRU的方式，将不常使用的键值从Cache中删除 并发处理能力 GuavaCache类似CurrentHashMap，是线程安全的。提供了设置并发级别的api，使得缓存支持并发的写入和读取，采用分离锁机制，分离锁能够减小锁力度，提升并发能力，分离锁是分拆锁定，把一个集合看分成若干partition, 每个partiton一把锁。更新锁定 防止缓存击穿 一般情况下，在缓存中查询某个key，如果不存在，则查源数据，并回填缓存。（Cache Aside Pattern）在高并发下会出现，多次查源并重复回填缓存，可能会造成源的宕机（DB），性能下降 GuavaCache可以在CacheLoader的load方法中加以控制，对同一个key，只让一个请求去读源并回填缓存，其他请求阻塞等待。（相当于集成数据源，方便用户使用） 监控缓存加载/命中情况 统计 问题： ​ OOM-\u003e设置过期时间、使用弱引用、配置过期策略 5、EVCache EVCache是一个Netflflix（网飞）公司开源、快速的分布式缓存，是基于Memcached的内存存储实现的，用以构建超大容量、高性能、低延时、跨区域的全球可用的缓存数据层。 E：Ephemeral：数据存储是短暂的，有自身的存活时间 V：Volatile：数据可以在任何时候消失 EVCache典型地适合对强一致性没有必须要求的场合 典型用例：Netflflix向用户推荐用户感兴趣的电影 EVCache集群在峰值每秒可以处理200kb的请求， Netflflix生产系统中部署的EVCache经常要处理超过每秒3000万个请求，存储数十亿个对象， 跨数千台memcached服务器。整个EVCache集群每天处理近2万亿个请求。 EVCache集群响应平均延时大约是1-5毫秒，最多不会超过20毫秒。 EVCache集群的缓存命中率在99%左右。 典型部署 EVCache 是线性扩展的，可以在一分钟之内完成扩容，在几分钟之内完成负载均衡和缓存预热。 1、集群启动时，EVCache向服务注册中心（Zookeeper、Eureka）注册各个实例 2、在web应用启动时，查询命名服务中的EVCache服务器列表，并建立连接。 3、客户端通过key使用一致性hash算法，将数据分片到集群上。 6、ETCD ​ 和Zookeeper一样，CP模型追求数据一致性，越来越多的系统开始用它保存关键数据。比如，秒杀系统经常用它保存各节点信息，以便控制消费 MQ 的服务数量。还有些业务系统的配置数据，也会通过 etcd 实时同步给业务系统的各节点，比如，秒杀管理后台会使用 etcd 将秒杀活动的配置数据实时同步给秒杀 API 服务各节点。 ","date":"2022-06-03","objectID":"/posts/tech/interview/interview-nw-java/:4:22","tags":["Java学习随笔","interview"],"title":"内部-design-1","uri":"/posts/tech/interview/interview-nw-java/"},{"categories":["Java"],"content":"Redis底层 1、redis数据类型 | 类型 | 底层 | 应用场景 | 编码类型 | | —— | ——— | ———————————————- | ——————— | | String | SDS数组 | 帖子、评论、热点数据、输入缓冲 | RAW « EMBSTR « INT | | List | QuickList | 评论列表、商品列表、发布与订阅、慢查询、监视器 | LINKEDLIST « ZIPLIST | | Set | intSet | 适合交集、并集、查集操作，例如朋友关系 | HT « INSET | | Zset | 跳跃表 | 去重后排序，适合排名场景 | SKIPLIST « ZIPLIST | | Hash | 哈希 | 结构化数据，比如存储对象 | HT « ZIPLIST | | Stream | 紧凑列表 | 消息队列 | | 2、相关API http://redisdoc.com | | | | | | | | | | | | —— | —– | —— | ——— | —– | ——- | —— | ——– | —– | ——— | | String | SET | SETNX | SETEX | GET | GETSET | INCR | DECR | MSET | MGET | | Hash | HSET | HSETNX | HGET | HDEL | HLEN | HMSET | HMGET | HKEYS | HGETALL | | LIST | LPUSH | LPOP | RPUSH | RPOP | LINDEX | LREM | LRANGE | LLEN | RPOPLPUSH | | ZSET | ZADD | ZREM | ZSCORE | ZCARD | ZRANGE | ZRANK | ZREVRANK | | ZREVRANGE | | SET | SADD | SREM | SISMEMBER | SCARD | SINTER | SUNION | SDIFF | SPOP | SMEMBERS | | 事务 | MULTI | EXEC | DISCARD | WATCH | UNWATCH | | | | | 3、redis底层结构 SDS数组结构，用于存储字符串和整型数据及输入缓冲。 struct sdshdr{ int len;//记录buf数组中已使用字节的数量 int free; //记录 buf 数组中未使用字节的数量 char buf[];//字符数组，用于保存字符串 } 跳跃表：将有序链表中的部分节点分层，每一层都是一个有序链表。 ​ 1、可以快速查找到需要的节点 O(logn) ，额外存储了一倍的空间 ​ 2、可以在O(1)的时间复杂度下，快速获得跳跃表的头节点、尾结点、长度和高度。 字典dict: 又称散列表(hash)，是用来存储键值对的一种数据结构。 ​ Redis整个数据库是用字典来存储的(K-V结构) —Hash+数组+链表 ​ Redis字典实现包括:字典(dict)、Hash表(dictht)、Hash表节点(dictEntry)。 ​ 字典达到存储上限(阈值 0.75)，需要rehash(扩容) ​ 1、初次申请默认容量为4个dictEntry，非初次申请为当前hash表容量的一倍。 ​ 2、rehashidx=0表示要进行rehash操作。 ​ 3、新增加的数据在新的hash表h[1] 、修改、删除、查询在老hash表h[0] ​ 4、将老的hash表h[0]的数据重新计算索引值后全部迁移到新的hash表h[1]中，这个过程称为 rehash。 ​ 渐进式rehash 由于当数据量巨大时rehash的过程是非常缓慢的，所以需要进行优化。 可根据服务器空闲程度批量rehash部分节点 压缩列表zipList ​ 压缩列表(ziplist)是由一系列特殊编码的连续内存块组成的顺序型数据结构，节省内容 ​ sorted-set和hash元素个数少且是小整数或短字符串(直接使用) ​ list用快速链表(quicklist)数据结构存储，而快速链表是双向列表与压缩列表的组合。(间接使用) 整数集合intSet ​ 整数集合(intset)是一个有序的(整数升序)、存储整数的连续存储结构。 ​ 当Redis集合类型的元素都是整数并且都处在64位有符号整数范围内(2^64)，使用该结构体存储。 快速列表quickList ​ 快速列表(quicklist)是Redis底层重要的数据结构。是Redis3.2列表的底层实现。 ​ (在Redis3.2之前，Redis采 用双向链表(adlist)和压缩列表(ziplist)实现。) Redis Stream的底层主要使用了listpack(紧凑列表)和Rax树(基数树)。 ​ listpack表示一个字符串列表的序列化，listpack可用于存储字符串或整数。用于存储stream的消息内 容。 ​ Rax树是一个有序字典树 (基数树 Radix Tree)，按照 key 的字典序排列，支持快速地定位、插入和删除操 作。 4、Zset底层实现 ​ 跳表(skip List)是一种随机化的数据结构，基于并联的链表，实现简单，插入、删除、查找的复杂度均为O(logN)。简单说来跳表也是链表的一种，只不过它在链表的基础上增加了跳跃功能，正是这个跳跃的功能，使得在查找元素时，跳表能够提供O(logN)的时间复杂度 ​ Zset数据量少的时候使用压缩链表ziplist实现，有序集合使用紧挨在一起的压缩列表节点来保存，第一个节点保存member，第二个保存score。ziplist内的集合元素按score从小到大排序，score较小的排在表头位置。 数据量大的时候使用跳跃列表skiplist和哈希表hash_map结合实现，查找删除插入的时间复杂度都是O(longN) ​ Redis使用跳表而不使用红黑树，是因为跳表的索引结构序列化和反序列化更加快速，方便持久化。 搜索 ​ 跳跃表按 score 从小到大保存所有集合元素，查找时间复杂度为平均 O(logN)，最坏 O(N) 。 插入 选用链表作为底层结构支持，为了高效地动态增删。因为跳表底层的单链表是有序的，为了维护这种有序性，在插入前需要遍历链表，找到该插入的位置，单链表遍历查找的时间复杂度是O(n)，同理可得，跳表的遍历也是需要遍历索引数，所以是O(logn)。 删除 如果该节点还在索引中，删除时不仅要删除单链表中的节点，还要删除索引中的节点；单链表在知道删除的节点是谁时，时间复杂度为O(1)，但针对单链表来说，删除时都需要拿到前驱节点O(logN)才可改变引用关系从而删除目标节点。 ","date":"2022-06-03","objectID":"/posts/tech/interview/interview-nw-java/:4:23","tags":["Java学习随笔","interview"],"title":"内部-design-1","uri":"/posts/tech/interview/interview-nw-java/"},{"categories":["Java"],"content":"Redis可用性 1、redis持久化 持久化就是把内存中的数据持久化到本地磁盘，防止服务器宕机了内存数据丢失 Redis 提供两种持久化机制 RDB（默认） 和 AOF 机制，Redis4.0以后采用混合持久化，用 AOF 来保证数据不丢失，作为数据恢复的第一选择; 用 RDB 来做不同程度的冷备 **RDB：**是Redis DataBase缩写快照 ​ RDB是Redis默认的持久化方式。按照一定的时间将内存的数据以快照的形式保存到硬盘中，对应产生的数据文件为dump.rdb。通过配置文件中的save参数来定义快照的周期。 ​ 优点： ​ 1）只有一个文件 dump.rdb，方便持久化； ​ 2）容灾性好，一个文件可以保存到安全的磁盘。 ​ 3）性能最大化，fork 子进程来进行持久化写操作，让主进程继续处理命令，只存在毫秒级不响应请求。 ​ 4）相对于数据集大时，比 AOF 的启动效率更高。 ​ 缺点： ​ 数据安全性低，RDB 是间隔一段时间进行持久化，如果持久化之间 redis 发生故障，会发生数据丢失。 AOF：持久化 ​ AOF持久化(即Append Only File持久化)，则是将Redis执行的每次写命令记录到单独的日志文件中，当重启Redis会重新将持久化的日志中文件恢复数据。 ​ 优点： ​ 1）数据安全，aof 持久化可以配置 appendfsync 属性，有 always，每进行一次 命令操作就记录到 aof 文件中一次。 ​ 2）通过 append 模式写文件，即使中途服务器宕机，可以通过 redis-check-aof 工具解决数据一致性问题。 缺点： ​ 1）AOF 文件比 RDB 文件大，且恢复速度慢。 ​ 2）数据集大的时候，比 rdb 启动效率低。 2、redis事务 ​ 事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。 Redis事务的概念 ​ Redis 事务的本质是通过MULTI、EXEC、WATCH等一组命令的集合。事务支持一次执行多个命令，一个事务中所有命令都会被序列化。在事务执行过程，会按照顺序串行化执行队列中的命令，其他客户端提交的命令请求不会插入到事务执行命令序列中。总结说：redis事务就是一次性、顺序性、排他性的执行一个队列中的一系列命令。 Redis的事务总是具有ACID中的一致性和隔离性，其他特性是不支持的。当服务器运行在AOF持久化模式下，并且appendfsync选项的值为always时，事务也具有耐久性。 Redis事务功能是通过MULTI、EXEC、DISCARD和WATCH 四个原语实现的 事务命令： **MULTI：**用于开启一个事务，它总是返回OK。MULTI执行之后，客户端可以继续向服务器发送任意多条命令，这些命令不会立即被执行，而是被放到一个队列中，当EXEC命令被调用时，所有队列中的命令才会被执行。 **EXEC：**执行所有事务块内的命令。返回事务块内所有命令的返回值，按命令执行的先后顺序排列。当操作被打断时，返回空值 nil 。 **WATCH ：**是一个乐观锁，可以为 Redis 事务提供 check-and-set （CAS）行为。可以监控一个或多个键，一旦其中有一个键被修改（或删除），之后的事务就不会执行，监控一直持续到EXEC命令。（秒杀场景） **DISCARD：**调用该命令，客户端可以清空事务队列，并放弃执行事务，且客户端会从事务状态中退出。 UNWATCH：命令可以取消watch对所有key的监控。 3、redis失效策略 内存淘汰策略 1）全局的键空间选择性移除 ​ noeviction：当内存不足以容纳新写入数据时，新写入操作会报错。（字典库常用） ​ allkeys-lru：在键空间中，移除最近最少使用的key。（缓存常用） ​ allkeys-random：在键空间中，随机移除某个key。 2）设置过期时间的键空间选择性移除 ​ volatile-lru：在设置了过期时间的键空间中，移除最近最少使用的key。 ​ volatile-random：在设置了过期时间的键空间中，随机移除某个key。 ​ volatile-ttl：在设置了过期时间的键空间中，有更早过期时间的key优先移除。 缓存失效策略 ​ **定时清除：**针对每个设置过期时间的key都创建指定定时器 ​ **惰性清除：**访问时判断，对内存不友好 ​ **定时扫描清除：**定时100ms随机20个检查过期的字典，若存在25%以上则继续循环删除。 4、redis读写模式 ​ CacheAside旁路缓存 写请求更新数据库后删除缓存数据。读请求不命中查询数据库，查询完成写入缓存 ​ 业务端处理所有数据访问细节，同时利用 Lazy 计算的思想，更新 DB 后，直接删除 cache 并通过 DB 更新，确保数据以 DB 结果为准，则可以大幅降低 cache 和 DB 中数据不一致的概率 ​ 如果没有专门的存储服务，同时是对数据一致性要求比较高的业务，或者是缓存数据更新比较复杂的业务，适合使用 Cache Aside 模式。如微博发展初期，不少业务采用这种模式 // 延迟双删，用以保证最终一致性,防止小概率旧数据读请求在第一次删除后更新数据库 public void write(String key,Object data){ redis.delKey(key); db.updateData(data); Thread.sleep(1000); redis.delKey(key); } 高并发下保证绝对的一致，先删缓存再更新数据，需要用到内存队列做异步串行化。非高并发场景，先更新数据再删除缓存，延迟双删策略基本满足了 先更新db后删除redis：删除redis失败则出现问题 先删redis后更新db：删除redis瞬间，旧数据被回填redis 先删redis后更新db休眠后删redis：同第二点，休眠后删除redis 可能宕机 java内部jvm队列：不适用分布式场景且降低并发 ​ Read/Write Though（读写穿透） ​ 先查询缓存中数据是否存在,如果存在则直接返回,如果不存在,则由缓存组件负责从数据库中同步加载数据. ​ ​ 先查询要写入的数据在缓存中是否已经存在,如果已经存在,则更新缓存中的数据，并且由缓存组件同步更新到数据库中。 ​ ​ 用户读操作较多.相较于Cache aside而言更适合缓存一致的场景。使用简单屏蔽了底层数据库的操作,只是操作缓存. 场景： 微博 Feed 的 Outbox Vector（即用户最新微博列表）就采用这种模式。一些粉丝较少且不活跃的用户发表微博后，Vector 服务会首先查询 Vector Cache，如果 cache 中没有该用户的 Outbox 记录，则不写该用户的 cache 数据，直接更新 DB 后就返回，只有 cache 中存在才会通过 CAS 指令进行更新。 ​ Write Behind Caching（异步缓存写入） 比如对一些计数业务，一条 Feed 被点赞 1万 次，如果更新 1万 次 DB 代价很大，而合并成一次请求直接加 1万，则是一个非常轻量的操作。但这种模型有个显著的缺点，即数据的一致性变差，甚至在一些极端场景下可能会丢失数据。 5、多级缓存 **浏览器本地内存缓存：**专题活动，一旦上线，在活动期间是不会随意变更的。 **浏览器本地磁盘缓存：**Logo缓存，大图片懒加载 **服务端本地内存缓存：**由于没有持久化，重启时必定会被穿透 服务端网络内存缓存：Redis等，针对穿透的情况下可以继续分层，必须保证数据库不被压垮 为什么不是使用服务器本地磁盘做缓存？ ​ 当系统处理大量磁盘 IO 操作的时候，由于 CPU 和内存的速度远高于磁盘，可能导致 CPU 耗费太多时间等待磁盘返回处理的结果。对于这部分 CPU 在 IO 上的开销，我们称为 iowait ","date":"2022-06-03","objectID":"/posts/tech/interview/interview-nw-java/:4:24","tags":["Java学习随笔","interview"],"title":"内部-design-1","uri":"/posts/tech/interview/interview-nw-java/"},{"categories":["Java"],"content":"Redis七大经典问题 1、缓存雪崩 ​ 指缓存同一时间大面积的失效，所以，后面的请求都会落到数据库上，造成数据库短时间内承受大量请求而崩掉。 ​ 解决方案： Redis 高可用，主从+哨兵，Redis cluster，避免全盘崩溃 本地 ehcache 缓存 + hystrix 限流\u0026降级，避免 MySQL 被打死 缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。 逻辑上永不过期给每一个缓存数据增加相应的缓存标记，缓存标记失效则更新数据缓存 多级缓存，失效时通过二级更新一级，由第三方插件更新二级缓存。 2、缓存穿透 ​ https://blog.csdn.net/lin777lin/article/details/105666839 ​ 缓存穿透是指缓存和数据库中都没有的数据，导致所有的请求都落到数据库上，造成数据库短时间内承受大量请求而崩掉。 ​ 解决方案： ​ 1）接口层增加校验，如用户鉴权校验，id做基础校验，id\u003c=0的直接拦截； ​ 2）从缓存取不到的数据，在数据库中也没有取到，这时也可以将key-value对写为key-null，缓存有效时间可以设置短点，如30秒。这样可以防止攻击用户反复用同一个id暴力攻击； ​ 3）采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的 bitmap 中，一个一定不存在的数据会被这个 bitmap 拦截掉，从而避免了对底层存储系统的查询压力。（宁可错杀一千不可放过一人） 3、缓存击穿 ​ 这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力。和缓存雪崩不同的是，缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库 ​ 解决方案： ​ 1）设置热点数据永远不过期，异步线程处理。 ​ 2）加写回操作加互斥锁，查询失败默认值快速返回。 ​ 3）缓存预热 ​ 系统上线后，将相关**可预期（例如排行榜）**热点数据直接加载到缓存。 ​ 写一个缓存刷新页面，手动操作热点数据**（例如广告推广）**上下线。 4、数据不一致 ​ 在缓存机器的带宽被打满，或者机房网络出现波动时，缓存更新失败，新数据没有写入缓存，就会导致缓存和 DB 的数据不一致。缓存 rehash 时，某个缓存机器反复异常，多次上下线，更新请求多次 rehash。这样，一份数据存在多个节点，且每次 rehash 只更新某个节点，导致一些缓存节点产生脏数据。 Cache 更新失败后，可以进行重试，则将重试失败的 key 写入mq，待缓存访问恢复后，将这些 key 从缓存删除。这些 key 在再次被查询时，重新从 DB 加载，从而保证数据的一致性 缓存时间适当调短，让缓存数据及早过期后，然后从 DB 重新加载，确保数据的最终一致性。 不采用 rehash 漂移策略，而采用缓存分层策略，尽量避免脏数据产生。 5、数据并发竞争 ​ 数据并发竞争在大流量系统也比较常见，比如车票系统，如果某个火车车次缓存信息过期，但仍然有大量用户在查询该车次信息。又比如微博系统中，如果某条微博正好被缓存淘汰，但这条微博仍然有大量的转发、评论、赞。上述情况都会造成并发竞争读取的问题。 ​ 加写回操作加互斥锁，查询失败默认值快速返回。 ​ 对缓存数据保持多个备份，减少并发竞争的概率 ​ 6、热点key问题 ​ 明星结婚、离婚、出轨这种特殊突发事件，比如奥运、春节这些重大活动或节日，还比如秒杀、双12、618 等线上促销活动，都很容易出现 Hot key 的情况。 如何提前发现HotKey？ 对于重要节假日、线上促销活动这些提前已知的事情，可以提前评估出可能的热 key 来。 而对于突发事件，无法提前评估，可以通过 Spark，对应流任务进行实时分析，及时发现新发布的热点 key。而对于之前已发出的事情，逐步发酵成为热 key 的，则可以通过 Hadoop 对批处理任务离线计算，找出最近历史数据中的高频热 key。 解决方案： 这 n 个 key 分散存在多个缓存节点，然后 client 端请求时，随机访问其中某个后缀的 hotkey，这样就可以把热 key 的请求打散，避免一个缓存节点过载 缓存集群可以单节点进行主从复制和垂直扩容 利用应用内的前置缓存，但是需注意需要设置上限 延迟不敏感，定时刷新，实时感知用主动刷新 和缓存穿透一样，限制逃逸流量，单请求进行数据回源并刷新前置 无论如何设计，最后都要写一个兜底逻辑，千万级流量说来就来 7、BigKey问题 ​ 比如互联网系统中需要保存用户最新 1万 个粉丝的业务，比如一个用户个人信息缓存，包括基本资料、关系图谱计数、发 feed 统计等。微博的 feed 内容缓存也很容易出现，一般用户微博在 140 字以内，但很多用户也会发表 1千 字甚至更长的微博内容，这些长微博也就成了大 key 首先Redis底层数据结构里，根据Value的不同，会进行数据结构的重新选择 可以扩展新的数据结构，进行序列化构建，然后通过 restore 一次性写入 将大 key 分拆为多个 key，设置较长的过期时间 ","date":"2022-06-03","objectID":"/posts/tech/interview/interview-nw-java/:4:25","tags":["Java学习随笔","interview"],"title":"内部-design-1","uri":"/posts/tech/interview/interview-nw-java/"},{"categories":["Java"],"content":"Redis分区容错 1、redis数据分区 Hash：（不稳定） ​ 客户端分片：哈希+取余 ​ 节点伸缩：数据节点关系变化，导致数据迁移 ​ 迁移数量和添加节点数量有关：建议翻倍扩容 ​ 一个简单直观的想法是直接用Hash来计算，以Key做哈希后对节点数取模。可以看出，在key足够分散的情况下，均匀性可以获得，但一旦有节点加入或退出，所有的原有节点都会受到影响，稳定性无从谈起。 一致性Hash：（不均衡） ​ 客户端分片：哈希+顺时针（优化取余） ​ 节点伸缩：只影响邻近节点，但是还是有数据迁移 ​ 翻倍伸缩：保证最小迁移数据和负载均衡 ​ 一致性Hash可以很好的解决稳定问题，可以将所有的存储节点排列在收尾相接的Hash环上，每个key在计算Hash后会顺时针找到先遇到的一组存储节点存放。而当有节点加入或退出时，仅影响该节点在Hash环上顺时针相邻的后续节点，将数据从该节点接收或者给予。但这又带来均匀性的问题，即使可以将存储节点等距排列，也会在存储节点个数变化时带来数据的不均匀。 Codis的Hash槽 ​ Codis 将所有的 key 默认划分为 1024 个槽位(slot)，它首先对客户端传过来的 key 进行 crc32 运算计算 哈希值，再将 hash 后的整数值对 1024 这个整数进行取模得到一个余数，这个余数就是对应 key 的槽位。 RedisCluster ​ Redis-cluster把所有的物理节点映射到[0-16383]个slot上,对key采用crc16算法得到hash值后对16384取模，基本上采用平均分配和连续分配的方式。 2、主从模式=简单 ​ 主从模式最大的优点是部署简单，最少两个节点便可以构成主从模式，并且可以通过读写分离避免读和写同时不可用。不过，一旦 Master 节点出现故障，主从节点就无法自动切换，直接导致 SLA 下降。所以，主从模式一般适合业务发展初期，并发量低，运维成本低的情况 主从复制原理： ​ ①通过从服务器发送到PSYNC命令给主服务器 ​ ②如果是首次连接，触发一次全量复制。此时主节点会启动一个后台线程，生成 RDB 快照文件 ​ ③主节点会将这个 RDB 发送给从节点，slave 会先写入本地磁盘，再从本地磁盘加载到内存中 ​ ④master会将此过程中的写命令写入缓存，从节点实时同步这些数据 ​ ⑤如果网络断开了连接，自动重连后主节点通过命令传播增量复制给从节点部分缺少的数据 缺点 ​ 所有的slave节点数据的复制和同步都由master节点来处理，会照成master节点压力太大，使用主从从结构来解决，redis4.0中引入psync2 解决了slave重启后仍然可以增量同步。 3、哨兵模式=读多 ​ 由一个或多个sentinel实例组成sentinel集群可以监视一个或多个主服务器和多个从服务器。哨兵模式适合读请求远多于写请求的业务场景，比如在秒杀系统中用来缓存活动信息。 如果写请求较多，当集群 Slave 节点数量多了后，Master 节点同步数据的压力会非常大。 当主服务器进入下线状态时，sentinel可以将该主服务器下的某一从服务器升级为主服务器继续提供服务，从而保证redis的高可用性。 检测主观下线状态 ​ Sentinel每秒一次向所有与它建立了命令连接的实例(主服务器、从服务器和其他Sentinel)发送PING命 令 ​ 实例在down-after-milliseconds毫秒内返回无效回复Sentinel就会认为该实例主观下线(SDown) 检查客观下线状态 ​ 当一个Sentinel将一个主服务器判断为主观下线后 ，Sentinel会向监控这个主服务器的所有其他Sentinel发送查询主机状态的命令 ​ 如果达到Sentinel配置中的quorum数量的Sentinel实例都判断主服务器为主观下线，则该主服务器就会被判定为客观下线(ODown)。 选举Leader Sentinel ​ 当一个主服务器被判定为客观下线后，监视这个主服务器的所有Sentinel会通过选举算法(raft)，选出一个Leader Sentinel去执行**failover(故障转移)**操作。 ​ Raft算法 ​ Raft协议是用来解决分布式系统一致性问题的协议。 Raft协议描述的节点共有三种状态:Leader, Follower, Candidate。 Raft协议将时间切分为一个个的Term(任期)，可以认为是一种“逻辑时间”。 选举流程: ①Raft采用心跳机制触发Leader选举系统启动后，全部节点初始化为Follower，term为0 ​ ②节点如果收到了RequestVote或者AppendEntries，就会保持自己的Follower身份 ​ ③节点如果一段时间内没收到AppendEntries消息，在该节点的超时时间内还没发现Leader，Follower就会转换成Candidate，自己开始竞选Leader。 一旦转化为Candidate，该节点立即开始下面几件事情: ​ –增加自己的term，启动一个新的定时器 ​ –给自己投一票，向所有其他节点发送RequestVote，并等待其他节点的回复。 ​ ④如果在计时器超时前，节点收到多数节点的同意投票，就转换成Leader。同时通过 AppendEntries，向其他节点发送通知。 ​ ⑤每个节点在一个term内只能投一票，采取先到先得的策略，Candidate投自己， Follower会投给第一个收到RequestVote的节点。 ​ ⑥Raft协议的定时器采取随机超时时间（选举的关键），先转为Candidate的节点会先发起投票，从而获得多数票。 主服务器的选择 ​ 当选举出Leader Sentinel后，Leader Sentinel会根据以下规则去从服务器中选择出新的主服务器。 过滤掉主观、客观下线的节点 选择配置slave-priority最高的节点，如果有则返回没有就继续选择 选择出复制偏移量最大的系节点，因为复制偏移量越大则数据复制的越完整 选择run_id最小的节点，因为run_id越小说明重启次数越少 故障转移 ​ 当Leader Sentinel完成新的主服务器选择后，Leader Sentinel会对下线的主服务器执行故障转移操作，主要有三个步骤: ​ 1、它会将失效 Master 的其中一个 Slave 升级为新的 Master , 并让失效 Master 的其他 Slave 改为复制新的 Master ; ​ 2、当客户端试图连接失效的 Master 时，集群会向客户端返回新 Master 的地址，使得集群当前状态只有一个Master。 ​ 3、Master 和 Slave 服务器切换后， Master 的 redis.conf 、 Slave 的 redis.conf 和 sentinel.conf 的配置文件的内容都会发生相应的改变，即 Master 主服务器的 redis.conf配置文件中会多一行 replicaof 的配置， sentinel.conf 的监控目标会随之调换。 4、集群模式=写多 ​ 为了避免单一节点负载过高导致不稳定，集群模式采用一致性哈希算法或者哈希槽的方法将 Key 分布到各个节点上。其中，每个 Master 节点后跟若干个 Slave 节点，用于出现故障时做主备切换，客户端可以连接任意 Master 节点，集群内部会按照不同 key 将请求转发到不同的 Master 节点 ​ 集群模式是如何实现高可用的呢？集群内部节点之间会互相定时探测对方是否存活，如果多数节点判断某个节点挂了，则会将其踢出集群，然后从 Slave 节点中选举出一个节点替补挂掉的 Master 节点。整个原理基本和哨兵模式一致 ​ 虽然集群模式避免了 Master 单节点的问题，但集群内同步数据时会占用一定的带宽。所以，只有在写操作比较多的情况下人们才使用集群模式，其他大多数情况，使用哨兵模式都能满足需求 5、分布式锁 利用Watch实现Redis乐观锁 ​ 乐观锁基于CAS(Compare And Swap)比较并替换思想，不会产生锁等待而消耗资源，但是需要反复的重试，但也是因为重试的机制，能比较快的响应。因此我们可以利用redis来实现乐观锁**（秒杀）**。具体思路如下: 1、利用redis的watch功能，监控这个redisKey的状态值 2、获取redisKey的值，创建redis事务，给这个key的值+1 3、执行这个事务，如果key的值被修改过则回滚，key不加1 利用setnx防止库存超卖 分布式锁是控制分布式系统之间同步访问共享资源的一种方式。 利用Redis的单线程特性对共享资源进行串行化处理 // 获取锁推荐使用set的方式 String result = jedis.set(lockKey, requestId, \"NX\", \"EX\", expireTime); String result = jedis.setnx(lockKey, requestId); //如线程死掉，其他线程无法获取到锁 // 释放锁，非原子操作，可能会释放其他线程刚加上的锁 if (requestId.equals(jedis.get(lockKey))) { jedis.del(lockKey); } // 推荐使用redis+lua脚本 String lua = \"if redis.call('get',KEYS[1]) == ARGV[1] then return redis.c","date":"2022-06-03","objectID":"/posts/tech/interview/interview-nw-java/:4:26","tags":["Java学习随笔","interview"],"title":"内部-design-1","uri":"/posts/tech/interview/interview-nw-java/"},{"categories":["Java"],"content":"Redis实战 1、Redis优化 读写方式 简单来说就是不用keys等，用range、contains之类。比如，用户粉丝数，大 V 的粉丝更是高达几千万甚至过亿，因此，获取粉丝列表只能部分获取。另外在判断某用户是否关注了另外一个用户时，也只需要关注列表上进行检查判断，然后返回 True/False 或 0/1 的方式更为高效。 KV size 如果单个业务的 KV size 过大，需要分拆成多个 KV 来缓存。拆分时应考虑访问频率 key 的数量 如果数据量巨大，则在缓存中尽可能只保留频繁访问的热数据，对于冷数据直接访问 DB。 读写峰值 如果小于 10万 级别，简单分拆到独立 Cache 池即可 如果达到 100万 级的QPS，则需要对 Cache 进行分层处理，可以同时使用 Local-Cache 配合远程 cache，甚至远程缓存内部继续分层叠加分池进行处理。（多级缓存） 命中率 缓存的命中率对整个服务体系的性能影响甚大。对于核心高并发访问的业务，需要预留足够的容量，确保核心业务缓存维持较高的命中率。比如微博中的 Feed Vector Cache（热点资讯），常年的命中率高达 99.5% 以上。为了持续保持缓存的命中率，缓存体系需要持续监控，及时进行故障处理或故障转移。同时在部分缓存节点异常、命中率下降时，故障转移方案，需要考虑是采用一致性 Hash 分布的访问漂移策略，还是采用数据多层备份策略。 过期策略 ​ 可以设置较短的过期时间，让冷 key 自动过期；也可以让 key 带上时间戳，同时设置较长的过期时间，比如很多业务系统内部有这样一些 key：key_20190801。 缓存穿透时间 平均缓存穿透加载时间在某些业务场景下也很重要，对于一些缓存穿透后，加载时间特别长或者需要复杂计算的数据，而且访问量还比较大的业务数据，要配置更多容量，维持更高的命中率，从而减少穿透到 DB 的概率，来确保整个系统的访问性能。 缓存可运维性 对于缓存的可运维性考虑，则需要考虑缓存体系的集群管理，如何进行一键扩缩容，如何进行缓存组件的升级和变更，如何快速发现并定位问题，如何持续监控报警，最好有一个完善的运维平台，将各种运维工具进行集成。 缓存安全性 对于缓存的安全性考虑，一方面可以限制来源 IP，只允许内网访问，同时加密鉴权访问。 2、Redis热升级 在 Redis 需要升级版本或修复 bug 时，如果直接重启变更，由于需要数据恢复，这个过程需要近 10 分钟的时间，时间过长，会严重影响系统的可用性。面对这种问题，可以对 Redis 扩展热升级功能，从而在毫秒级完成升级操作，完全不影响业务访问。 热升级方案如下，首先构建一个 Redis 壳程序，将 redisServer 的所有属性（包括redisDb、client等）保存为全局变量。然后将 Redis 的处理逻辑代码全部封装到动态连接库 so 文件中。Redis 第一次启动，从磁盘加载恢复数据，在后续升级时，通过指令，壳程序重新加载 Redis 新的 redis-4.so 到 redis-5.so 文件，即可完成功能升级，毫秒级完成 Redis 的版本升级。而且整个过程中，所有 Client 连接仍然保留，在升级成功后，原有 Client 可以继续进行读写操作，整个过程对业务完全透明。 六、Kafka篇 ","date":"2022-06-03","objectID":"/posts/tech/interview/interview-nw-java/:4:27","tags":["Java学习随笔","interview"],"title":"内部-design-1","uri":"/posts/tech/interview/interview-nw-java/"},{"categories":["Java"],"content":"Why kafka 消息队列的作用：异步、削峰填谷、解耦 中小型公司，技术实力较为一般，技术挑战不是特别高，用 RabbitMQ （开源、社区活跃）是不错的选择；大型公司，基础架构研发实力较强，用 RocketMQ（Java二次开发） 是很好的选择。 如果是大数据领域的实时计算、日志采集等场景，用 Kafka 是业内标准的，绝对没问题，社区活跃度很高，绝对不会黄，何况几乎是全世界这个领域的事实性规范。 RabbitMQ RabbitMQ开始是用在电信业务的可靠通信的，也是少有的几款支持AMQP协议的产品之一。 优点： 轻量级，快速，部署使用方便 支持灵活的路由配置。RabbitMQ中，在生产者和队列之间有一个交换器模块。根据配置的路由规则，生产者发送的消息可以发送到不同的队列中。路由规则很灵活，还可以自己实现。 RabbitMQ的客户端支持大多数的编程语言，支持AMQP协议。 缺点： 如果有大量消息堆积在队列中，性能会急剧下降 每秒处理几万到几十万的消息。如果应用要求高的性能，不要选择RabbitMQ。 RabbitMQ是Erlang开发的，功能扩展和二次开发代价很高。 RocketMQ 借鉴了Kafka的设计并做了很多改进，几乎具备了消息队列应该具备的所有特性和功能。 RocketMQ主要用于有序，事务，流计算，消息推送，日志流处理，binlog分发等场景。 经过了历次的双11考验，性能，稳定性可靠性没的说。 java开发，阅读源代码、扩展、二次开发很方便。 对电商领域的响应延迟做了很多优化。 每秒处理几十万的消息，同时响应在毫秒级。如果应用很关注响应时间，可以使用RocketMQ。 性能比RabbitMQ高一个数量级，。 支持死信队列，DLX 是一个非常有用的特性。它可以处理异常情况下，消息不能够被消费者正确消费而被置入死信队列中的情况，后续分析程序可以通过消费这个死信队列中的内容来分析当时所遇到的异常情况，进而可以改善和优化系统。 缺点： ​ 跟周边系统的整合和兼容不是很好。 Kafka 高可用，几乎所有相关的开源软件都支持，满足大多数的应用场景，尤其是大数据和流计算领域， Kafka高效，可伸缩，消息持久化。支持分区、副本和容错。 对批处理和异步处理做了大量的设计，因此Kafka可以得到非常高的性能。 每秒处理几十万异步消息消息，如果开启了压缩，最终可以达到每秒处理2000w消息的级别。 但是由于是异步的和批处理的，延迟也会高，不适合电商场景。 ","date":"2022-06-03","objectID":"/posts/tech/interview/interview-nw-java/:4:28","tags":["Java学习随笔","interview"],"title":"内部-design-1","uri":"/posts/tech/interview/interview-nw-java/"},{"categories":["Java"],"content":"What Kafka Producer API：允许应用程序将记录流发布到一个或多个Kafka主题。 Consumer API：允许应用程序订阅一个或多个主题并处理为其生成的记录流。 Streams API：允许应用程序充当流处理器，将输入流转换为输出流。 消息Message ​ Kafka的数据单元称为消息。可以把消息看成是数据库里的一个“数据行”或一条“记录”。 批次 ​ 为了提高效率，消息被分批写入Kafka。提高吞吐量却加大了响应时间 主题Topic ​ 通过主题进行分类，类似数据库中的表， 分区Partition ​ Topic可以被分成若干分区分布于kafka集群中，方便扩容 ​ 单个分区内是有序的，partition设置为一才能保证全局有序 副本Replicas ​ 每个主题被分为若干个分区，每个分区有多个副本。 生产者Producer ​ 生产者在默认情况下把消息均衡地分布到主题的所有分区上： 直接指定消息的分区 根据消息的key散列取模得出分区 轮询指定分区。 消费者Comsumer ​ 消费者通过偏移量来区分已经读过的消息，从而消费消息。把每个分区最后读取的消息偏移量保存在Zookeeper 或Kafka上，如果消费者关闭或重启，它的读取状态不会丢失。 消费组ComsumerGroup ​ 消费组保证每个分区只能被一个消费者使用，避免重复消费。如果群组内一个消费者失效，消费组里的其他消费者可以接管失效消费者的工作再平衡，重新分区 节点Broker ​ 连接生产者和消费者，单个broker可以轻松处理数千个分区以及每秒百万级的消息量。 broker接收来自生产者的消息，为消息设置偏移量，并提交消息到磁盘保存。 broker为消费者提供服务，响应读取分区的请求，返回已经提交到磁盘上的消息。 集群 ​ 每隔分区都有一个首领，当分区被分配给多个broker时，会通过首领进行分区复制。 生产者Offset ​ 消息写入的时候，每一个分区都有一个offset，即每个分区的最新最大的offset。 消费者Offset ​ 不同消费组中的消费者可以针对一个分区存储不同的Offset，互不影响 LogSegment 一个分区由多个LogSegment组成， 一个LogSegment由.log .index .timeindex组成 .log追加是顺序写入的，文件名是以文件中第一条message的offset来命名的 .Index进行日志删除的时候和数据查找的时候可以快速定位。 .timeStamp则根据时间戳查找对应的偏移量。 ","date":"2022-06-03","objectID":"/posts/tech/interview/interview-nw-java/:4:29","tags":["Java学习随笔","interview"],"title":"内部-design-1","uri":"/posts/tech/interview/interview-nw-java/"},{"categories":["Java"],"content":"How Kafka 优点 高吞吐量：单机每秒处理几十上百万的消息量。即使存储了TB及消息，也保持稳定的性能。 零拷贝 减少内核态到用户态的拷贝，磁盘通过sendfile实现DMA 拷贝Socket buffer 顺序读写 充分利用磁盘顺序读写的超高性能 页缓存mmap，将磁盘文件映射到内存, 用户通过修改内存就能修改磁盘文件。 高性能：单节点支持上千个客户端，并保证零停机和零数据丢失。 持久化：将消息持久化到磁盘。通过将数据持久化到硬盘以及replication防止数据丢失。 分布式系统，易扩展。所有的组件均为分布式的，无需停机即可扩展机器。 可靠性 - Kafka是分布式，分区，复制和容错的。 客户端状态维护：消息被处理的状态是在Consumer端维护，当失败时能自动平衡。 应用场景 **日志收集：**用Kafka可以收集各种服务的Log，通过大数据平台进行处理； **消息系统：**解耦生产者和消费者、缓存消息等； 用户活动跟踪：Kafka经常被用来记录Web用户或者App用户的各种活动，如浏览网页、搜索、点击等活动，这些活动信息被各个服务器发布到Kafka的Topic中，然后消费者通过订阅这些Topic来做运营数据的实时的监控分析，也可保存到数据库； ","date":"2022-06-03","objectID":"/posts/tech/interview/interview-nw-java/:4:30","tags":["Java学习随笔","interview"],"title":"内部-design-1","uri":"/posts/tech/interview/interview-nw-java/"},{"categories":["Java"],"content":"生产消费基本流程 Producer创建时，会创建一个Sender线程并设置为守护线程。 生产的消息先经过拦截器-\u003e序列化器-\u003e分区器，然后将消息缓存在缓冲区。 批次发送的条件为：缓冲区数据大小达到batch.size或者linger.ms达到上限。 批次发送后，发往指定分区，然后落盘到broker； acks=0只要将消息放到缓冲区，就认为消息已经发送完成。 acks=1表示消息只需要写到主分区即可。在该情形下，如果主分区收到消息确认之后就宕机了，而副本分区还没来得及同步该消息，则该消息丢失。 acks=all （默认）首领分区会等待所有的ISR副本分区确认记录。该处理保证了只要有一个ISR副本分区存活，消息就不会丢失。 如果生产者配置了retrires参数大于0并且未收到确认，那么客户端会对该消息进行重试。 落盘到broker成功，返回生产元数据给生产者。 Leader选举 Kafka会在Zookeeper上针对每个Topic维护一个称为ISR（in-sync replica）的集合 当集合中副本都跟Leader中的副本同步了之后，kafka才会认为消息已提交 只有这些跟Leader保持同步的Follower才应该被选作新的Leader 假设某个topic有N+1个副本，kafka可以容忍N个服务器不可用，冗余度较低 如果ISR中的副本都丢失了，则： 可以等待ISR中的副本任何一个恢复，接着对外提供服务，需要时间等待 从OSR中选出一个副本做Leader副本，此时会造成数据丢失 副本消息同步 ​ 首先，Follower 发送 FETCH 请求给 Leader。接着，Leader 会读取底层日志文件中的消 息数据，再更新它内存中的 Follower 副本的 LEO 值，更新为 FETCH 请求中的 fetchOffset 值。最后，尝试更新分区高水位值。Follower 接收到 FETCH 响应之后，会把消息写入到底层日志，接着更新 LEO 和 HW 值。 相关概念：LEO和HW。 LEO：即日志末端位移(log end offset)，记录了该副本日志中下一条消息的位移值。如果LEO=10，那么表示该副本保存了10条消息，位移值范围是[0, 9] HW：水位值HW（high watermark）即已备份位移。对于同一个副本对象而言，其HW值不会大于LEO值。小于等于HW值的所有消息都被认为是“已备份”的（replicated） Rebalance 组成员数量发生变化 订阅主题数量发生变化 订阅主题的分区数发生变化 leader选举完成后，当以上三种情况发生时，Leader根据配置的RangeAssignor开始分配消费方案，即哪个consumer负责消费哪些topic的哪些partition。一旦完成分配，leader会将这个方案封装进SyncGroup请求中发给coordinator，非leader也会发SyncGroup请求，只是内容为空。coordinator接收到分配方案之后会把方案塞进SyncGroup的response中发给各个consumer。这样组内的所有成员就都知道自己应该消费哪些分区了。 分区分配算法RangeAssignor 原理是按照消费者总数和分区总数进行整除运算平均分配给所有的消费者。 订阅Topic的消费者按照名称的字典序排序，分均分配，剩下的字典序从前往后分配 增删改查 kafka-topics.sh --zookeeper localhost:2181/myKafka --create --topic topic_x --partitions 1 --replication-factor 1 kafka-topics.sh --zookeeper localhost:2181/myKafka --delete --topic topic_x kafka-topics.sh --zookeeper localhost:2181/myKafka --alter --topic topic_x --config max.message.bytes=1048576 kafka-topics.sh --zookeeper localhost:2181/myKafka --describe --topic topic_x 如何查看偏移量为23的消息？ 通过查询跳跃表ConcurrentSkipListMap，定位到在00000000000000000000.index ，通过二分法在偏移量索引文件中找到不大于 23 的最大索引项，即offset 20 那栏，然后从日志分段文件中的物理位置为320 开始顺序查找偏移量为 23 的消息。 切分文件 大小分片 当前日志分段文件的大小超过了 broker 端参数 log.segment.bytes 配置的值 时间分片 当前日志分段中消息的最大时间戳与系统的时间戳的差值大于log.roll.ms配置的值 索引分片 偏移量或时间戳索引文件大小达到broker端 log.index.size.max.bytes配置的值 偏移分片 追加的消息的偏移量与当前日志分段的偏移量之间的差值大于 Integer.MAX_VALUE ","date":"2022-06-03","objectID":"/posts/tech/interview/interview-nw-java/:4:31","tags":["Java学习随笔","interview"],"title":"内部-design-1","uri":"/posts/tech/interview/interview-nw-java/"},{"categories":["Java"],"content":"一致性 幂等性 保证在消息重发的时候，消费者不会重复处理。即使在消费者收到重复消息的时候，重复处理，也 要保证最终结果的一致性。所谓幂等性，数学概念就是： f(f(x)) = f(x) 如何实现？ ​ 添加唯一ID，类似于数据库的主键，用于唯一标记一个消息。 ProducerID：#在每个新的Producer初始化时，会被分配一个唯一的PID SequenceNumber：#对于每个PID发送数据的每个Topic都对应一个从0开始单调递增的SN值 如何选举 使用 Zookeeper 的分布式锁选举控制器，并在节点加入集群或退出集群时通知控制器。 控制器负责在节点加入或离开集群时进行分区Leader选举。 控制器使用epoch忽略小的纪元来避免脑裂：两个节点同时认为自己是当前的控制器。 ","date":"2022-06-03","objectID":"/posts/tech/interview/interview-nw-java/:4:32","tags":["Java学习随笔","interview"],"title":"内部-design-1","uri":"/posts/tech/interview/interview-nw-java/"},{"categories":["Java"],"content":"可用性 创建Topic的时候可以指定 –replication-factor 3 ，表示不超过broker的副本数 只有Leader是负责读写的节点，Follower定期地到Leader上Pull数据。 ISR是Leader负责维护的与其保持同步的Replica列表，即当前活跃的副本列表。如果一个Follow落后太多，Leader会将它从ISR中移除。选举时优先从ISR中挑选Follower。 设置 acks=all 。Leader收到了ISR中所有Replica的ACK，才向Producer发送ACK。 ","date":"2022-06-03","objectID":"/posts/tech/interview/interview-nw-java/:4:33","tags":["Java学习随笔","interview"],"title":"内部-design-1","uri":"/posts/tech/interview/interview-nw-java/"},{"categories":["Java"],"content":"面试题 线上问题rebalance 因集群架构变动导致的消费组内重平衡，如果kafka集内节点较多，比如数百个，那重平衡可能会耗时导致数分钟到数小时，此时kafka基本处于不可用状态，对kafka的TPS影响极大 产生的原因： 组成员数量发生变化 订阅主题数量发生变化 订阅主题的分区数发生变化 **组成员崩溃和组成员主动离开是两个不同的场景。**因为在崩溃时成员并不会主动地告知coordinator此事，coordinator有可能需要一个完整的session.timeout周期(心跳周期)才能检测到这种崩溃，这必然会造成consumer的滞后。可以说离开组是主动地发起rebalance；而崩溃则是被动地发起rebalance。 解决方案： 加大超时时间 session.timout.ms=6s 加大心跳频率 heartbeat.interval.ms=2s 增长推送间隔 max.poll.interval.ms=t+1 minutes 这些年，为了进阿里背过的面试题 ZooKeeper 的作用 目前，Kafka 使用 ZooKeeper 存放集群元数据、成员管理、Controller 选举，以及其他一些管理类任务。之后，等 KIP-500 提案完成后，Kafka 将完全不再依赖于 ZooKeeper。 存放元数据是指主题分区的所有数据都保存在 ZooKeeper 中，其他“人”都要与它保持对齐。 成员管理是指 Broker 节点的注册、注销以及属性变更等 。 Controller 选举是指选举集群 Controller，包括但不限于主题删除、参数配置等。 一言以蔽之:KIP-500 ，是使用社区自研的基于 Raft 的共识算法，实现 Controller 自选举。 同样是存储元数据，这几年基于Raft算法的etcd认可度越来越高 ​ 越来越多的系统开始用它保存关键数据。比如，秒杀系统经常用它保存各节点信息，以便控制消费 MQ 的服务数量。还有些业务系统的配置数据，也会通过 etcd 实时同步给业务系统的各节点，比如，秒杀管理后台会使用 etcd 将秒杀活动的配置数据实时同步给秒杀 API 服务各节点。 Replica副本的作用 Kafka 只有 Leader 副本才能 对外提供读写服务，响应 Clients 端的请求。Follower 副本只是采用拉(PULL)的方 式，被动地同步 Leader 副本中的数据，并且在 Leader 副本所在的 Broker 宕机后，随时准备应聘 Leader 副本。 自 Kafka 2.4 版本开始，社区可以通过配置参数，允许 Follower 副本有限度地提供读服务。 之前确保一致性的主要手段是高水位机制， 但高水位值无法保证 Leader 连续变更场景下的数据一致性，因此，社区引入了 Leader Epoch 机制，来修复高水位值的弊端。 为什么不支持读写分离? 自 Kafka 2.4 之后，Kafka 提供了有限度的读写分离。 场景不适用。读写分离适用于那种读负载很大，而写操作相对不频繁的场景。 同步机制。Kafka 采用 PULL 方式实现 Follower 的同步，同时复制延迟较大。 如何防止重复消费 代码层面每次消费需提交offset 通过Mysql的唯一键约束，结合Redis查看id是否被消费，存Redis可以直接使用set方法 量大且允许误判的情况下，使用布隆过滤器也可以 如何保证数据不会丢失 生产者生产消息可以通过comfirm配置ack=all解决 Broker同步过程中leader宕机可以通过配置ISR副本+重试解决 消费者丢失可以关闭自动提交offset功能，系统处理完成时提交offset 如何保证顺序消费 单 topic，单partition，单 consumer，单线程消费，吞吐量低，不推荐 如只需保证单key有序，为每个key申请单独内存 queue，每个线程分别消费一个内存 queue 即可，这样就能保证单key（例如用户id、活动id）顺序性。 【线上】如何解决积压消费 修复consumer，使其具备消费能力，并且扩容N台 写一个分发的程序，将Topic均匀分发到临时Topic中 同时起N台consumer，消费不同的临时Topic 如何避免消息积压 提高消费并行度 批量消费 减少组件IO的交互次数 优先级消费 if (maxOffset - curOffset \u003e 100000) { // TODO 消息堆积情况的优先处理逻辑 // 未处理的消息可以选择丢弃或者打日志 return ConsumeConcurrentlyStatus.CONSUME_SUCCESS; } // TODO 正常消费过程 return ConsumeConcurrentlyStatus.CONSUME_SUCCESS; 如何设计消息队列 需要支持快速水平扩容，broker+partition，partition放不同的机器上，增加机器时将数据根据topic做迁移，分布式需要考虑一致性、可用性、分区容错性 **一致性：**生产者的消息确认、消费者的幂等性、Broker的数据同步 **可用性：**数据如何保证不丢不重、数据如何持久化、持久化时如何读写 **分区容错：**采用何种选举机制、如何进行多副本同步 **海量数据：**如何解决消息积压、海量Topic性能下降 性能上，可以借鉴时间轮、零拷贝、IO多路复用、顺序读写、压缩批处理 七、Spring篇 ","date":"2022-06-03","objectID":"/posts/tech/interview/interview-nw-java/:4:34","tags":["Java学习随笔","interview"],"title":"内部-design-1","uri":"/posts/tech/interview/interview-nw-java/"},{"categories":["Java"],"content":"设计思想\u0026Beans 1、IOC 控制反转 ​ IoC（Inverse of Control:控制反转）是⼀种设计思想，就是将原本在程序中⼿动创建对象的控制权，交由Spring框架来管理。 IoC 在其他语⾔中也有应⽤，并⾮ Spring 特有。 ​ IoC 容器是 Spring⽤来实现 IoC 的载体， IoC 容器实际上就是个Map（key，value）,Map 中存放的是各种对象。将对象之间的相互依赖关系交给 IoC 容器来管理，并由 IoC 容器完成对象的注⼊。这样可以很⼤程度上简化应⽤的开发，把应⽤从复杂的依赖关系中解放出来。 IoC 容器就像是⼀个⼯⼚⼀样，当我们需要创建⼀个对象的时候，只需要配置好配置⽂件/注解即可，完全不⽤考虑对象是如何被创建出来的。 DI 依赖注入 ​ DI:（Dependancy Injection：依赖注入)站在容器的角度，将对象创建依赖的其他对象注入到对象中。 2、AOP 动态代理 ​ AOP(Aspect-Oriented Programming:⾯向切⾯编程)能够将那些与业务⽆关，却为业务模块所共同调⽤的逻辑或责任（例如事务处理、⽇志管理、权限控制等）封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性。 ​ Spring AOP就是基于动态代理的，如果要代理的对象，实现了某个接⼝，那么Spring AOP会使⽤JDKProxy，去创建代理对象，⽽对于没有实现接⼝的对象，就⽆法使⽤ JDK Proxy 去进⾏代理了，这时候Spring AOP会使⽤基于asm框架字节流的Cglib动态代理 ，这时候Spring AOP会使⽤ Cglib ⽣成⼀个被代理对象的⼦类来作为代理。 3、Bean生命周期 单例对象： singleton 总结：单例对象的生命周期和容器相同 多例对象： prototype 出生：使用对象时spring框架为我们创建 活着：对象只要是在使用过程中就一直活着 死亡：当对象长时间不用且没有其它对象引用时，由java的垃圾回收机制回收 IOC容器初始化加载Bean流程： @Override public void refresh() throws BeansException, IllegalStateException { synchronized (this.startupShutdownMonitor) { // 第一步:刷新前的预处理 prepareRefresh(); //第二步: 获取BeanFactory并注册到 BeanDefitionRegistry ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory(); // 第三步:加载BeanFactory的预准备工作(BeanFactory进行一些设置，比如context的类加载器等) prepareBeanFactory(beanFactory); try { // 第四步:完成BeanFactory准备工作后的前置处理工作 postProcessBeanFactory(beanFactory); // 第五步:实例化BeanFactoryPostProcessor接口的Bean invokeBeanFactoryPostProcessors(beanFactory); // 第六步:注册BeanPostProcessor后置处理器，在创建bean的后执行 registerBeanPostProcessors(beanFactory); // 第七步:初始化MessageSource组件(做国际化功能;消息绑定，消息解析); initMessageSource(); // 第八步:注册初始化事件派发器 initApplicationEventMulticaster(); // 第九步:子类重写这个方法，在容器刷新的时候可以自定义逻辑 onRefresh(); // 第十步:注册应用的监听器。就是注册实现了ApplicationListener接口的监听器 registerListeners(); //第十一步:初始化所有剩下的非懒加载的单例bean 初始化创建非懒加载方式的单例Bean实例(未设置属性) finishBeanFactoryInitialization(beanFactory); //第十二步: 完成context的刷新。主要是调用LifecycleProcessor的onRefresh()方法，完成创建 finishRefresh(); } …… } 总结： 四个阶段 实例化 Instantiation 属性赋值 Populate 初始化 Initialization 销毁 Destruction 多个扩展点 影响多个Bean BeanPostProcessor InstantiationAwareBeanPostProcessor 影响单个Bean Aware 完整流程 实例化一个Bean－－也就是我们常说的new； 按照Spring上下文对实例化的Bean进行配置－－也就是IOC注入； 如果这个Bean已经实现了BeanNameAware接口，会调用它实现的setBeanName(String)方法，也就是根据就是Spring配置文件中Bean的id和name进行传递 如果这个Bean已经实现了BeanFactoryAware接口，会调用它实现setBeanFactory(BeanFactory)也就是Spring配置文件配置的Spring工厂自身进行传递； 如果这个Bean已经实现了ApplicationContextAware接口，会调用setApplicationContext(ApplicationContext)方法，和4传递的信息一样但是因为ApplicationContext是BeanFactory的子接口，所以更加灵活 如果这个Bean关联了BeanPostProcessor接口，将会调用postProcessBeforeInitialization()方法，BeanPostProcessor经常被用作是Bean内容的更改，由于这个是在Bean初始化结束时调用那个的方法，也可以被应用于内存或缓存技术 如果Bean在Spring配置文件中配置了init-method属性会自动调用其配置的初始化方法。 如果这个Bean关联了BeanPostProcessor接口，将会调用postProcessAfterInitialization()，打印日志或者三级缓存技术里面的bean升级 以上工作完成以后就可以应用这个Bean了，那这个Bean是一个Singleton的，所以一般情况下我们调用同一个id的Bean会是在内容地址相同的实例，当然在Spring配置文件中也可以配置非Singleton，这里我们不做赘述。 当Bean不再需要时，会经过清理阶段，如果Bean实现了DisposableBean这个接口，或者根据spring配置的destroy-method属性，调用实现的destroy()方法 4、Bean作用域 | 名称 | 作用域 | | ————– | ———————————————————— | | singleton | 单例对象，默认值的作用域 | | prototype | 每次获取都会创建⼀个新的 bean 实例 | | request | 每⼀次HTTP请求都会产⽣⼀个新的bean，该bean仅在当前HTTP request内有效。 | | session | 在一次 HTTP session 中，容器将返回同一个实例 | | global-session | 将对象存入到web项目集群的session域中,若不存在集群,则global session相当于session | 默认作用域是singleton，多个线程访问同一个bean时会存在线程不安全问题 保障线程安全方法： 在Bean对象中尽量避免定义可变的成员变量（不太现实）。 在类中定义⼀个ThreadLocal成员变量，将需要的可变成员变量保存在 ThreadLocal 中 ThreadLocal： ​ 每个线程中都有一个自己的ThreadLocalMap类对象，可以将线程自己的对象保持到其中，各管各的，线程可以正确的访问到自己的对象。 ​ 将一个共用的ThreadLocal静态实例作为key，将不同对象的引用保存到不同线程的ThreadLocalMap中，然后在线程执行的各处通过这个静态ThreadLocal实例的get()方法取得自己线程保存的那个对象，避免了将这个对象作为参数传递的麻烦。 5、循环依赖 ​ 循环依赖其实就是循环引用，也就是两个或者两个以上的 Bean 互相持有对方，最终形成闭环。比如A 依赖于B，B又依赖于A Spring中循环依赖场景有: prototype 原型 bean循环依赖 构造器的循环依赖（构造器注入） Field 属性的循环依赖（set注入） 其中，构造器的循环依赖问题无法解决，在解决属性循环依赖时，可以使用懒加载，spring采用的是提前暴露对象的方法。 懒加载@Lazy解决循环依赖问题 ​ Spring 启动的时候会把所有bean信息(包括XML和注解)解析转化成Spring能够识别的BeanDefinition并存到Hashmap里供下面的初始化时用，然后对每个 BeanDefinition 进行处理。普通 Bean 的初始化是在容器启动初始化阶段执行的，而被lazy","date":"2022-06-03","objectID":"/posts/tech/interview/interview-nw-java/:4:35","tags":["Java学习随笔","interview"],"title":"内部-design-1","uri":"/posts/tech/interview/interview-nw-java/"},{"categories":["Java"],"content":"Spring注解 1、@SpringBoot ​ 声明bean的注解 ​ @Component 通⽤的注解，可标注任意类为 Spring 组件 ​ @Service 在业务逻辑层使用（service层） ​ @Repository 在数据访问层使用（dao层） ​ @Controller 在展现层使用，控制器的声明（controller层） ​ 注入bean的注解 ​ @Autowired：默认按照类型来装配注入，@Qualifier：可以改成名称 ​ @Resource：默认按照名称来装配注入，JDK的注解，新版本已经弃用 @Autowired注解原理 ​ @Autowired的使用简化了我们的开发， ​ 实现 AutowiredAnnotationBeanPostProcessor 类，该类实现了 Spring 框架的一些扩展接口。 ​ 实现 BeanFactoryAware 接口使其内部持有了 BeanFactory（可轻松的获取需要依赖的的 Bean）。 ​ 实现 MergedBeanDefinitionPostProcessor 接口，实例化Bean 前获取到 里面的 @Autowired 信息并缓存下来； ​ 实现 postProcessPropertyValues 接口， 实例化Bean 后从缓存取出注解信息，通过反射将依赖对象设置到 Bean 属性里面。 @SpringBootApplication @SpringBootApplication public class JpaApplication { public static void main(String[] args) { SpringApplication.run(JpaApplication.class, args); } } @SpringBootApplication注解等同于下面三个注解： @SpringBootConfiguration： 底层是Configuration注解，说白了就是支持JavaConfig的方式来进行配置 @EnableAutoConfiguration：开启自动配置功能 @ComponentScan：就是扫描注解，默认是扫描当前类下的package 其中@EnableAutoConfiguration是关键(启用自动配置)，内部实际上就去加载META-INF/spring.factories文件的信息，然后筛选出以EnableAutoConfiguration为key的数据，加载到IOC容器中，实现自动配置功能！ 它主要加载了@SpringBootApplication注解主配置类，这个@SpringBootApplication注解主配置类里边最主要的功能就是SpringBoot开启了一个@EnableAutoConfiguration注解的自动配置功能。 @EnableAutoConfiguration作用： 它主要利用了一个 EnableAutoConfigurationImportSelector选择器给Spring容器中来导入一些组件。 @Import(EnableAutoConfigurationImportSelector.class) public @interface EnableAutoConfiguration 2、@SpringMVC @Controller 声明该类为SpringMVC中的Controller @RequestMapping 用于映射Web请求 @ResponseBody 支持将返回值放在response内，而不是一个页面，通常用户返回json数据 @RequestBody 允许request的参数在request体中，而不是在直接连接在地址后面。 @PathVariable 用于接收路径参数 @RequestMapping(\"/hello/{name}\")申明的路径，将注解放在参数中前，即可获取该值，通常作为Restful的接口实现方法。 SpringMVC原理 客户端（浏览器）发送请求，直接请求到 DispatcherServlet 。 DispatcherServlet 根据请求信息调⽤ HandlerMapping ，解析请求对应的 Handler 。 解析到对应的 Handler （也就是 Controller 控制器）后，开始由HandlerAdapter 适配器处理。 HandlerAdapter 会根据 Handler 来调⽤真正的处理器开处理请求，并处理相应的业务逻辑。 处理器处理完业务后，会返回⼀个 ModelAndView 对象， Model 是返回的数据对象 ViewResolver 会根据逻辑 View 查找实际的 View 。 DispaterServlet 把返回的 Model 传给 View （视图渲染）。 把 View 返回给请求者（浏览器） 3、@SpringMybatis @Insert ： 插入sql ,和xml insert sql语法完全一样 @Select ： 查询sql, 和xml select sql语法完全一样 @Update ： 更新sql, 和xml update sql语法完全一样 @Delete ： 删除sql, 和xml delete sql语法完全一样 @Param ： 入参 @Results ： 设置结果集合@Result ： 结果 @ResultMap ： 引用结果集合 @SelectKey ： 获取最新插入id mybatis如何防止sql注入？ ​ 简单的说就是#{}是经过预编译的，是安全的，${}是未经过预编译的，仅仅是取变量的值，是非安全的，存在SQL注入。在编写mybatis的映射语句时，尽量采用**“#{xxx}”这样的格式。如果需要实现动态传入表名、列名，还需要做如下修改：添加属性statementType=“STATEMENT”，同时sql里的属有变量取值都改成${xxxx}** Mybatis和Hibernate的区别 Hibernate 框架： ​ Hibernate是一个开放源代码的对象关系映射框架,它对JDBC进行了非常轻量级的对象封装,建立对象与数据库表的映射。是一个全自动的、完全面向对象的持久层框架。 Mybatis框架： ​ Mybatis是一个开源对象关系映射框架，原名：ibatis,2010年由谷歌接管以后更名。是一个半自动化的持久层框架。 区别： 开发方面 ​ 在项目开发过程当中，就速度而言： ​ hibernate开发中，sql语句已经被封装，直接可以使用，加快系统开发； ​ Mybatis 属于半自动化，sql需要手工完成，稍微繁琐； ​ 但是，凡事都不是绝对的，如果对于庞大复杂的系统项目来说，复杂语句较多，hibernate 就不是好方案。 sql优化方面 ​ Hibernate 自动生成sql,有些语句较为繁琐，会多消耗一些性能； ​ Mybatis 手动编写sql，可以避免不需要的查询，提高系统性能； 对象管理比对 ​ Hibernate 是完整的对象-关系映射的框架，开发工程中，无需过多关注底层实现，只要去管理对象即可； ​ Mybatis 需要自行管理映射关系； 4、@Transactional @EnableTransactionManagement @Transactional 注意事项： ​ ①事务函数中不要处理耗时任务，会导致长期占有数据库连接。 ​ ②事务函数中不要处理无关业务，防止产生异常导致事务回滚。 事务传播属性 1) REQUIRED（默认属性） 如果存在一个事务，则支持当前事务。如果没有事务则开启一个新的事务。 MANDATORY 支持当前事务，如果当前没有事务，就抛出异常。 NEVER 以非事务方式执行，如果当前存在事务，则抛出异常。 NOT_SUPPORTED 以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。 REQUIRES_NEW 新建事务，如果当前存在事务，把当前事务挂起。 SUPPORTS 支持当前事务，如果当前没有事务，就以非事务方式执行。 7) NESTED （局部回滚） 支持当前事务，新增Savepoint点，与当前事务同步提交或回滚。 嵌套事务一个非常重要的概念就是内层事务依赖于外层事务。外层事务失败时，会回滚内层事务所做的动作。而内层事务操作失败并不会引起外层事务的回滚。 ","date":"2022-06-03","objectID":"/posts/tech/interview/interview-nw-java/:4:36","tags":["Java学习随笔","interview"],"title":"内部-design-1","uri":"/posts/tech/interview/interview-nw-java/"},{"categories":["Java"],"content":"Spring源码阅读 1、Spring中的设计模式 参考：spring中的设计模式 单例设计模式 : Spring 中的 Bean 默认都是单例的。 ⼯⼚设计模式 : Spring使⽤⼯⼚模式通过 BeanFactory 、 ApplicationContext 创建bean 对象。 代理设计模式 : Spring AOP 功能的实现。 观察者模式： Spring 事件驱动模型就是观察者模式很经典的⼀个应⽤。 **适配器模式：**Spring AOP 的增强或通知(Advice)使⽤到了适配器模式、spring MVC 中也是⽤到了适配器模式适配 Controller 。 八、SpringCloud篇 Why SpringCloud ​ Spring cloud 是一系列框架的有序集合。它利用 spring boot 的开发便利性巧妙地简化了分布式系统基础设施的开发，如服务发现注册、配置中心、消息总线、负载均衡、断路器、数据监控等，都可以用 spring boot 的开发风格做到一键启动和部署。 | SpringCloud（微服务解决方案） | Dubbo（分布式服务治理框架） | | ——————————– | ————————— | | Rest API （轻量、灵活、swagger） | RPC远程调用（高效、耦合） | | Eureka、Nacos | Zookeeper | | 使用方便 | 性能好 | | 即将推出SpringCloud2.0 | 断档5年后17年重启 | ​ SpringBoot是Spring推出用于解决传统框架配置文件冗余,装配组件繁杂的基于Maven的解决方案,旨在快速搭建单个微服务，SpringCloud是依赖于SpringBoot的,而SpringBoot并不是依赖与SpringCloud,甚至还可以和Dubbo进行优秀的整合开发 ​ MartinFlower 提出的微服务之间是通过RestFulApi进行通信，具体实现 RestTemplate：基于HTTP协议 Feign：封装了ribbon和Hystrix 、RestTemplate 简化了客户端开发工作量 RPC：基于TCP协议，序列化和传输效率提升明显 MQ：异步解耦微服务之间的调用 Spring Boot Spring Boot 通过简单的步骤就可以创建一个 Spring 应用。 Spring Boot 为 Spring 整合第三方框架提供了开箱即用功能。 Spring Boot 的核心思想是约定大于配置。 Spring Boot 解决的问题 搭建后端框架时需要手动添加 Maven 配置，涉及很多 XML 配置文件，增加了搭建难度和时间成本。 将项目编译成 war 包，部署到 Tomcat 中，项目部署依赖 Tomcat，这样非常不方便。 应用监控做的比较简单，通常都是通过一个没有任何逻辑的接口来判断应用的存活状态。 Spring Boot 优点 **自动装配：**Spring Boot 会根据某些规则对所有配置的 Bean 进行初始化。可以减少了很多重复性的工作。 ​ 比如使用 MongoDB 时，只需加入 MongoDB 的 Starter 包，然后配置 的连接信息，就可以直接使用 MongoTemplate 自动装配来操作数据库了。简化了 Maven Jar 包的依赖，降低了烦琐配置的出错几率。 **内嵌容器：**Spring Boot 应用程序可以不用部署到外部容器中，比如 Tomcat。 ​ 应用程序可以直接通过 Maven 命令编译成可执行的 jar 包，通过 java-jar 命令启动即可，非常方便。 **应用监控：**Spring Boot 中自带监控功能 Actuator，可以实现对程序内部运行情况进行监控， ​ 比如 Bean 加载情况、环境变量、日志信息、线程信息等。当然也可以自定义跟业务相关的监控，通过Actuator 的端点信息进行暴露。 spring-boot-starter-web //用于快速构建基于 Spring MVC 的 Web 项目。 spring-boot-starter-data-redis //用于快速整合并操作 Redis。 spring-boot-starter-data-mongodb //用于对 MongoDB 的集成。 spring-boot-starter-data-jpa //用于操作 MySQL。 自定义一个Starter 创建 Starter 项目，定义 Starter 需要的配置（Properties）类，比如数据库的连接信息； 编写自动配置类，自动配置类就是获取配置，根据配置来自动装配 Bean； 编写 spring.factories 文件加载自动配置类，Spring 启动的时候会扫描 spring.factories 文件，； 编写配置提示文件 spring-configuration-metadata.json（不是必须的），在添加配置的时候，我们想要知道具体的配置项是什么作用，可以通过编写提示文件来提示； 在项目中引入自定义 Starter 的 Maven 依赖，增加配置值后即可使用。 Spring Boot Admin（将 actuator 提供的数据进行可视化） 显示应用程序的监控状态、查看 JVM 和线程信息 应用程序上下线监控 可视化的查看日志、动态切换日志级别 HTTP 请求信息跟踪等实用功能 GateWay / Zuul GateWay⽬标是取代Netflflix Zuul，它基于Spring5.0+SpringBoot2.0+WebFlux等技术开发，提供统⼀的路由⽅式（反向代理）并且基于 Filter(定义过滤器对请求过滤，完成⼀些功能) 链的⽅式提供了⽹关基本的功能，例如：鉴权、流量控制、熔断、路径重写、⽇志监控。 组成： 路由route： ⽹关最基础的⼯作单元。路由由⼀个ID、⼀个⽬标URL、⼀系列的断⾔（匹配条件判断）和Filter过滤器组成。如果断⾔为true，则匹配该路由。 **断⾔predicates：**参考了Java8中的断⾔Predicate，匹配Http请求中的所有内容（类似于nginx中的location匹配⼀样），如果断⾔与请求相匹配则路由。 **过滤器filter：**标准的Spring webFilter，使⽤过滤器在请求之前或者之后执⾏业务逻辑。 请求前pre类型过滤器：做参数校验、权限校验、流量监控、⽇志输出、协议转换等， 请求前post类型的过滤器：做响应内容、响应头的修改、⽇志的输出、流量监控等。 GateWayFilter 应⽤到单个路由路由上 、GlobalFilter 应⽤到所有的路由上 Eureka / Zookeeper 服务注册中⼼本质上是为了解耦服务提供者和服务消费者，为了⽀持弹性扩缩容特性，⼀个微服务的提供者的数量和分布往往是动态变化的。 | 区别 | Zookeeper | Eureka | Nacos | | —— | —————- | —————————- | —————— | | CAP | CP | AP | CP/AP切换 | | 可用性 | 选举期间不可用 | 自我保护机制，数据不是最新的 | | | 组成 | Leader和Follower | 节点平等 | | | 优势 | 分布式协调 | 注册与发现 | 注册中心和配置中心 | | 底层 | 进程 | 服务 | Jar包 | Eureka通过⼼跳检测、健康检查和客户端缓存等机制，提⾼系统的灵活性、可伸缩性和可⽤性。 us-east-1c、us-east-1d，us-east-1e代表不同的机房，每⼀个Eureka Server都是⼀个集群。 Service作为服务提供者向Eureka中注册服务，Eureka接受到注册事件会在集群和分区中进⾏数据同步，Client作为消费端（服务消费者）可以从Eureka中获取到服务注册信息，进⾏服务调⽤。 微服务启动后，会周期性地向Eureka发送⼼跳（默认周期为30秒）以续约⾃⼰的信息 Eureka在⼀定时间内**（默认90秒）没有接收**到某个微服务节点的⼼跳，Eureka将会注销该微服务节点 Eureka Client会缓存Eureka Server中的信息。即使所有的Eureka Server节点都宕掉，服务消费者依然可以使⽤缓存中的信息找到服务提供者 Eureka缓存 新服务上线后，服务消费者不能立即访问到刚上线的新服务，需要过⼀段时间后才能访问？或是将服务下线后，服务还是会被调⽤到，⼀段时候后才彻底停⽌服务，访问前期会导致频繁报错！ ​ 服务注册到注册中⼼后，服务实例信息是存储在Registry表中的，也就是内存中。但Eureka为了提⾼响应速度，在内部做了优化，加⼊了两层的缓存结构，将Client需要的实例信息，直接缓存起来，获取的时候直接从缓存中拿数据然后响应给 Client。 第⼀层缓存是readOnlyCacheMap，采⽤ConcurrentHashMap来存储数据的，主要负责定时与readWriteCacheMap进⾏数据同步，默认同步时间为 30 秒⼀次。 第⼆层缓存是readWriteCacheMap，采⽤Guava来实现缓存。缓存过期时间默认为180秒，当服务下线、过期、注册、状态变更等操作都会清除此缓存中的数据。 如果两级缓存都无法查询，会触发缓存的加载，从存储层拉取数据到缓存中，然后再返回给 Client。 Eureka之所以设计⼆级缓存机制，也是为了提⾼ Eureka S","date":"2022-06-03","objectID":"/posts/tech/interview/interview-nw-java/:4:37","tags":["Java学习随笔","interview"],"title":"内部-design-1","uri":"/posts/tech/interview/interview-nw-java/"},{"categories":["Java"],"content":"安全认证 Session 认证中最常用的一种方式，也是最简单的。存在多节点session丢失的情况，可通过nginx粘性Cookie和Redis集中式Session存储解决 HTTP Basic Authentication 服务端针对请求头中base64加密的Authorization 和用户名和密码进行校验。 Token Session 只是一个 key，会话信息存储在后端。而 Token 中会存储用户的信息，然后通过加密算法进行加密，只有服务端才能解密，服务端拿到 Token 后进行解密获取用户信息。 JWT认证 JWT（JSON Web Token）用户提供用户名和密码给认证服务器，服务器验证用户提交信息的合法性；如果验证成功，会产生并返回一个 Token，用户可以使用这个 Token 访问服务器上受保护的资源。 认证服务提供认证的 API，校验用户信息，返回认证结果 通过JWTUtils中的RSA算法，生成JWT token，token里封装用户id和有效期 服务间参数通过请求头进行传递，服务内部通过 ThreadLocal 进行上下文传递。 Hystrix导致ThreadLocal失效的问题可以通过，重写 Hystrix 的 Callable 方法，传递需要的数据。 Token最佳实践 设置较短（合理）的过期时间。 注销的 Token 及时清除（放入 Redis 中做一层过滤）。 虽然不能修改 Token 的信息，但是能在验证层面做一层过滤来进行处理。 监控 Token 的使用频率。 为了防止数据被别人爬取，最常见的就是监控使用频率，程序写出来的爬虫程序访问频率是有迹可循的 核心功能敏感操作可以使用动态验证（验证码）。 比如提现的功能，要求在提现时再次进行验证码的验证，防止不是本人操作。 网络环境、浏览器信息等识别。 银行 APP 对环境有很高的要求，使用时如果断网，APP 会自动退出，重新登录，因为网络环境跟之前使用的不一样了，还有一些浏览器的信息之类的判断，这些都是可以用来保证后端 API 的安全。 加密密钥支持动态修改。 如果 Token 的加密密钥泄露了，也就意味着别人可以伪造你的 Token，可以将密钥存储在配置中心，以支持动态修改刷新，需要注意的是建议在流量低峰的时候去做更换的操作，否则 Token 全部失效，所有在线的请求都会重新申请 Token，并发量会比较大。 ","date":"2022-06-03","objectID":"/posts/tech/interview/interview-nw-java/:4:38","tags":["Java学习随笔","interview"],"title":"内部-design-1","uri":"/posts/tech/interview/interview-nw-java/"},{"categories":["Java"],"content":"灰度发布 痛点： 服务数量多，业务变动频繁，一周一发布 灰度发布能降低发布失败风险，减少影响范围 通过灰度发布，先让一部分用户体验新的服务，或者只让测试人员进行测试，等功能正常后再全部发布，这样能降低发布失败带来的影响范围。 当发布出现故障时，可以快速回滚，不影响用户 灰度后如果发现这个节点有问题，那么只需回滚这个节点即可，当然不回滚也没关系，通过灰度策略隔离，也不会影响正常用户 可以通过Ribbon的负载均衡策略进行灰度发布，可以使用更可靠的Discovery Discovery 基于Discovery 服务注册发现、Ribbon 负载均衡、Feign 和 RestTemplate 调用等组件的企业级微服务开源解决方案，包括灰度发布、灰度路由、服务隔离等功能 首先将需要发布的服务从转发过程中移除，等流量剔除之后再发布。 部分机器中的版本进行升级，用户默认还是请求老的服务，通过版本来支持测试请求。 测试完成之后，让新的版本接收正常流量，然后部署下一个节点，以此类推。 grayVersions = {\"discovery-article-service\":[\"1.01\"]} ","date":"2022-06-03","objectID":"/posts/tech/interview/interview-nw-java/:4:39","tags":["Java学习随笔","interview"],"title":"内部-design-1","uri":"/posts/tech/interview/interview-nw-java/"},{"categories":["Java"],"content":"多版本隔离 本地复用测试服务-Eureka Zone亮点 ​ region 地理上的分区，比如北京、上海等 ​ zone 可以简单理解为 region 内的具体机房 ​ 在调用的过程中会优先选择相同的 zone 发起调用，当找不到相同名称的 zone 时会选择其他的 zone 进行调用，我们可以利用这个特性来解决本地需要启动多个服务的问题。 [^]: 当你访问修改的服务 A 时，这个服务依赖了 B、C 两个服务，B 和 C 本地没有启动，B 和 C 找不到相同的 zone 就会选择其他的 zone 进行调用，也就是会调用到测试环境部署的 B 和 C 服务，这样一来就解决了本地部署多个服务的问题。 各组件调优 当你对网关进行压测时，会发现并发量一直上不去，错误率也很高。因为你用的是默认配置，这个时候我们就需要去调整配置以达到最优的效果。 首先我们可以对容器进行调优，最常见的就是内置的 Tomcat 容器了， server.tomcat.accept-count //请求队列排队数 server.tomcat.max-threads //最大线程数 server.tomcat.max-connections //最大连接数 Hystrix 的信号量（semaphore）隔离模式，并发量上不去很大的原因都在这里，信号量默认值是 100，也就是最大并发只有 100，超过 100 就得等待。 //信号量 zuul.semaphore.max-semaphores //信号量：最大并发数 //线程池 hystrix.threadpool.default.coreSize //最大线程数 hystrix.threadpool.default.maximumSize //队列的大 hystrix.threadpool.default.maxQueueSize //等参数 配置Gateway并发信息， gateway.host.max-per-route-connections //每个路由的连接数 gateway.host.max-total-connections //总连接数 调整Ribbon 的并发配置， ribbon.MaxConnectionsPerHost //单服务并发数 ribbon.MaxTotalConnections //总并发数 修改Feign默认的HttpURLConnection 替换成 httpclient 来提高性能 feign.httpclient.max-connections-per-route//每个路由的连接数 feign.httpclient.max-connections //总连接数 Gateway+配置中心实现动态路由 Feign+配置中心实现动态日志 九、分布式篇 分布式系统是一个硬件或软件组件分布在不同的网络计算机上，彼此之间仅仅通过消息传递进行通信和协调的系统。 ","date":"2022-06-03","objectID":"/posts/tech/interview/interview-nw-java/:4:40","tags":["Java学习随笔","interview"],"title":"内部-design-1","uri":"/posts/tech/interview/interview-nw-java/"},{"categories":["Java"],"content":"发展历程 入口级负载均衡 网关负载均衡 客户端负载均衡 单应用架构 应用服务和数据服务分离 应用服务集群 应用服务中心化SAAS 数据库主备读写分离 全文搜索引擎加快数据统计 缓存集群缓解数据库读压力 分布式消息中间件缓解数据库写压力 数据库水平拆分适应微服务 数据库垂直拆分解决慢查询 划分上下文拆分微服务 服务注册发现（Eureka、Nacos） 配置动态更新（Config、Apollo） 业务灰度发布（Gateway、Feign） 统一安全认证（Gateway、Auth） 服务降级限流（Hystrix、Sentinel） 接口检查监控（Actuator、Prometheus） 服务全链路追踪（Sleuth、Zipkin） ","date":"2022-06-03","objectID":"/posts/tech/interview/interview-nw-java/:4:41","tags":["Java学习随笔","interview"],"title":"内部-design-1","uri":"/posts/tech/interview/interview-nw-java/"},{"categories":["Java"],"content":"CAP 一致性（2PC、3PC、Paxos、Raft） 强一致性：数据库一致性，牺牲了性能 ACID：原子性、一致性、隔离性、持久性 弱一致性：数据库和缓存，延迟双删、重试 单调读一致性：缓存一致性，ID或者IP哈希 最终一致性：边缘业务，消息队列 可用性（多级缓存、读写分离） BASE 基本可用：限流导致响应速度慢、降级导致用户体验差 Basically Availabe 基本可用 Soft state 软状态 Eventual Consistency 最终一致性 分区容忍性（一致性Hash解决扩缩容问题） ","date":"2022-06-03","objectID":"/posts/tech/interview/interview-nw-java/:4:42","tags":["Java学习随笔","interview"],"title":"内部-design-1","uri":"/posts/tech/interview/interview-nw-java/"},{"categories":["Java"],"content":"一致性 XA方案 2PC协议：两阶段提交协议，P是指准备阶段，C是指提交阶段 准备阶段：询问是否可以开始，写Undo、Redo日志，收到响应 提交阶段：执行Redo日志进行Commit，执行Undo日志进行Rollback 3PC协议：将提交阶段分为CanCommit、PreCommit、DoCommit三个阶段 CanCommit：发送canCommit请求，并开始等待 PreCommit：收到全部Yes，写Undo、Redo日志。超时或者No，则中断 DoCommit：执行Redo日志进行Commit，执行Undo日志进行Rollback 区别是第二步，参与者自身增加了超时，如果失败可以及时释放资源 Paxos算法 如何在一个发生异常的分布式系统中，快速且正确地在集群内部对某个数据的值达成一致 ​ 参与者（例如Kafka）的一致性可以由协调者（例如Zookeeper）来保证，协调者的一致性就只能由Paxos保证了 Paxos算法中的角色： Client：客户端、例如，对分布式文件服务器中文件的写请求。 Proposer：提案发起者，根据Accept返回选择最大N对应的V，发送[N+1,V] Acceptor：决策者，Accept以后会拒绝小于N的提案，并把自己的[N,V]返回给Proposer Learners：最终决策的学习者、学习者充当该协议的复制因素 //算法约束 P1:一个Acceptor必须接受它收到的第一个提案。 //考虑到半数以上才作数，一个Accpter得接受多个相同v的提案 P2a:如果某个v的提案被accept，那么被Acceptor接受编号更高的提案必须也是v P2b:如果某个v的提案被accept，那么从Proposal提出编号更高的提案必须也是v //如何确保v的提案Accpter被选定后，Proposal都能提出编号更高的提案呢 针对任意的[Mid,Vid]，有半数以上的Accepter集合S，满足以下二选一： S中接受的提案都大于Mid S中接受的提案若小于Mid，编号最大的那个值为Vid 面试题：如何保证Paxos算法活性 ​ 假设存在这样一种极端情况，有两个Proposer依次提出了一系列编号递增的提案，导致最终陷入死循环，没有value被选定 通过选取主Proposer，规定只有主Proposer才能提出议案。只要主Proposer和过半的Acceptor能够正常网络通信，主Proposer提出一个编号更高的提案，该提案终将会被批准。 每个Proposer发送提交提案的时间设置为一段时间内随机，保证不会一直死循环 ZAB算法 Raft算法 Raft 是一种为了管理复制日志的一致性算法 Raft使用心跳机制来触发选举。当server启动时，初始状态都是follower。每一个server都有一个定时器，超时时间为election timeout（一般为150-300ms），如果某server没有超时的情况下收到来自领导者或者候选者的任何消息，定时器重启，如果超时，它就开始一次选举。 Leader异常：异常期间Follower会超时选举，完成后Leader比较彼此步长 **Follower异常：**恢复后直接同步至Leader当前状态 **多个Candidate：**选举时失败，失败后超时继续选举 数据库和Redis的一致性 全量缓存保证高效读取 所有数据都存储在缓存里，读服务在查询时不会再降级到数据库里，所有的请求都完全依赖缓存。此时，因降级到数据库导致的毛刺问题就解决了。但全量缓存并没有解决更新时的分布式事务问题，反而把问题放大了。因为全量缓存对数据更新要求更加严格，要求所有数据库已有数据和实时更新的数据必须完全同步至缓存，不能有遗漏。对于此问题，一种有效的方案是采用订阅数据库的 Binlog 实现数据同步 ​ 现在很多开源工具（如阿里的 Canal等）可以模拟主从复制的协议。通过模拟协议读取主数据库的 Binlog 文件，从而获取主库的所有变更。对于这些变更，它们开放了各种接口供业务服务获取数据。 ​ 将 Binlog 的中间件挂载至目标数据库上，就可以实时获取该数据库的所有变更数据。对这些变更数据解析后，便可直接写入缓存里。优点还有： 大幅提升了读取的速度，降低了延迟 Binlog 的主从复制是基于 ACK 机制， 解决了分布式事务的问题 如果同步缓存失败了，被消费的 Binlog 不会被确认，下一次会重复消费，数据最终会写入缓存中 缺点不可避免：1、增加复杂度 2、消耗缓存资源 3、需要筛选和压缩数据 4、极端情况数据丢失 可以通过异步校准方案进行补齐，但是会损耗数据库性能。但是此方案会隐藏中间件使用错误的细节，线上环境前期更重要的是记录日志排查在做后续优化，不能本末倒置。 ","date":"2022-06-03","objectID":"/posts/tech/interview/interview-nw-java/:4:43","tags":["Java学习随笔","interview"],"title":"内部-design-1","uri":"/posts/tech/interview/interview-nw-java/"},{"categories":["Java"],"content":"可用性 心跳检测 以固定的频率向其他节点汇报当前节点状态的方式。收到心跳，说明网络和节点的状态是健康的。心跳汇报时，一般会携带一些附加的状态、元数据，以便管理 周期检测心跳机制：超时未返回 累计失效检测机制：重试超次数 多机房实时热备 两套缓存集群可以分别部署到不同城市的机房。读服务也相应地部署到不同城市或不同分区。在承接请求时，不同机房或分区的读服务只依赖同样属性的缓存集群。此方案有两个好处。 **提升了性能。**读服务不要分层，读服务要尽可能地和缓存数据源靠近。 **增加了可用。**当单机房出现故障时，可以秒级将所有流量都切换至存活的机房或分区 此方案虽然带来了性能和可用性的提升，但代价是资源成本的上升。 ","date":"2022-06-03","objectID":"/posts/tech/interview/interview-nw-java/:4:44","tags":["Java学习随笔","interview"],"title":"内部-design-1","uri":"/posts/tech/interview/interview-nw-java/"},{"categories":["Java"],"content":"分区容错性 分布式系统对于错误包容的能力 通过限流、降级、兜底、重试、负载均衡等方式增强系统的健壮性 日志复制 Leader把指令添加到日志中，发起 RPC 给其他的服务器，让他们复制这条信息 Leader会不断的重试，直到所有的 Follower响应了ACK并复制了所有的日志条目 通知所有的Follower提交，同时Leader该表这条日志的状态，并返回给客户端 主备（Master-Slave） ​ 主机宕机时，备机接管主机的一切工作，主机恢复正常后，以自动（热备）或手动（冷备）方式将服务切换到主机上运行，Mysql和Redis中常用。 ​ MySQL之间数据复制的基础是二进制日志文件（binary log fifile）。它的数据库中所有操作都会以**“事件”的方式记录在二进制日志中，其他数据库作为slave通过一个I/O线程与主服务器保持通信**，并监控master的二进制日志文件的变化，如果发现master二进制日志文件发生变化，则会把变化复制到自己的中继日志中，然后slave的一个SQL线程会把相关的“事件”执行到自己的数据库中，以此实现从数据库和主数据库的一致性，也就实现了主从复制 互备（Active-Active） ​ 指两台主机同时运行各自的服务工作且相互监测情况。在数据库高可用部分，常见的互备是MM模式。MM模式即Multi-Master模式，指一个系统存在多个master，每个master都具有read-write能力，会根据时间戳或业务逻辑合并版本。 集群（Cluster）模式 ​ 是指有多个节点在运行，同时可以通过主控节点分担服务请求。如Zookeeper。集群模式需要解决主控节点本身的高可用问题，一般采用主备模式。 ","date":"2022-06-03","objectID":"/posts/tech/interview/interview-nw-java/:4:45","tags":["Java学习随笔","interview"],"title":"内部-design-1","uri":"/posts/tech/interview/interview-nw-java/"},{"categories":["Java"],"content":"分布式事务 XA方案 两阶段提交 | 三阶段提交 准备阶段的资源锁定，存在性能问题，严重时会造成死锁问题 提交事务请求后，出现网络异常，部分数据收到并执行，会造成一致性问 TCC方案 Try Confirm Cancel / 短事务 Try 阶段：这个阶段说的是对各个服务的资源做检测以及对资源进行锁定或者预留 Confirm 阶段：这个阶段说的是在各个服务中执行实际的操作 Cancel 阶段：如果任何一个服务的业务方法执行出错，那么就需要进行补偿/回滚 Saga方案 事务性补偿 / 长事务 流程长、流程多、调用第三方业务 本地消息表（eBay） MQ最终一致性 比如阿里的 RocketMQ 就支持消息事务（核心：双端确认，重试幂等） A**(订单)** 系统先发送一个 prepared 消息到 mq，prepared 消息发送失败则取消操作不执行了 发送成功后，那么执行本地事务，执行成功和和失败发送确认和回滚消息到mq 如果发送了确认消息，那么此时 B**(仓储)** 系统会接收到确认消息，然后执行本地的事务 mq 会自动定时轮询所有 prepared 消息回调的接口，确认事务执行状态 B 的事务失败后自动不断重试直到成功，达到一定次数后发送报警由人工来手工回滚和补偿 最大努力通知方案（订单 -\u003e 积分） 系统 A 本地事务执行完之后，发送个消息到 MQ； 这里会有个专门消费 MQ 的最大努力通知服务，接着调用系统 B 的接口； 要是系统 B 执行失败了，就定时尝试重新调用系统 B，反复 N 次，最后还是不行就放弃 你找一个严格资金要求绝对不能错的场景，你可以说你是用的 TCC 方案； 如果是一般的分布式事务场景，例如积分数据，可以用可靠消息最终一致性方案 如果分布式场景允许不一致，可以使用最大努力通知方案 ","date":"2022-06-03","objectID":"/posts/tech/interview/interview-nw-java/:4:46","tags":["Java学习随笔","interview"],"title":"内部-design-1","uri":"/posts/tech/interview/interview-nw-java/"},{"categories":["Java"],"content":"面试题 分布式Session实现方案 基于JWT的Token，数据从cache或者数据库中获取 基于Tomcat的Redis，简单配置conf文件 基于Spring的Redis，支持SpringCloud和Springb ","date":"2022-06-03","objectID":"/posts/tech/interview/interview-nw-java/:4:47","tags":["Java学习随笔","interview"],"title":"内部-design-1","uri":"/posts/tech/interview/interview-nw-java/"},{"categories":["Tech"],"content":"leetcode leetcode-labuladong (109k) labuladong-算法讲解 宫水三叶-blog leetcode-宫水三叶 github-宫水三叶 soulmachine-leetcode 算法珠玑-在线刷题 github java Guide-1 java Guide-2 java Guide-git Java Family ","date":"2022-06-02","objectID":"/posts/tech/collection-material/:0:0","tags":["learning"],"title":"TODO- 搜集素材","uri":"/posts/tech/collection-material/"},{"categories":["Tech"],"content":"内网-这些年-姐妹篇 Collection Robin的博客 横云断岭的博客 横云断岭 github 个人博客 hugo 参考 git java 面试题 代码随想录 \u0026\u0026 刷题网站 githhub-demo 代码随想录 - github刷题整理- 适合2/3刷 github-刷题集合（含leecode） ","date":"2022-06-02","objectID":"/posts/tech/collection-material/:1:0","tags":["learning"],"title":"TODO- 搜集素材","uri":"/posts/tech/collection-material/"},{"categories":["Tech"],"content":"Mac ","date":"2022-05-01","objectID":"/posts/tech/setup/install-software-collection/:0:0","tags":["install"],"title":"Mac下开发工具安装","uri":"/posts/tech/setup/install-software-collection/"},{"categories":["Tech"],"content":"Tool Charles ","date":"2022-05-01","objectID":"/posts/tech/setup/install-software-collection/:1:0","tags":["install"],"title":"Mac下开发工具安装","uri":"/posts/tech/setup/install-software-collection/"},{"categories":["Tech"],"content":"DB mac-mysql安装-参考-1 mac-mysql安装-参考-2 mac-python3 安装-参考 mac-Homebrew 安装-参考 ","date":"2022-05-01","objectID":"/posts/tech/setup/install-software-collection/:2:0","tags":["install"],"title":"Mac下开发工具安装","uri":"/posts/tech/setup/install-software-collection/"},{"categories":["Tech"],"content":"如果我是一线主管 每周也要写周报，每年也要写绩效，也想晋升、加薪、诸如此类； 团队有五、六个人还好，十几个人的团队的话会希望有人可以站出来帮我; ","date":"2022-03-07","objectID":"/posts/job/management/beleader/:1:0","tags":[""],"title":"管理","uri":"/posts/job/management/beleader/"},{"categories":["Tech"],"content":"不抱怨 如果我是一线技术主管，不会喜欢团队喜欢抱怨的同学 我每天也很忙，听一个人抱怨会花时间； 一个人抱怨了，自然是有问题的，需要花一定的时间梳理出问题，需要及时给出解决方案，甚至要安抚对方情绪； 一个喜欢抱怨的人会影响整个团队的士气； 其实大部分开发抱怨的工作内容很相似，无非是自己做的业务是一堆x，xxx就是不配合我做事，PD提了无理的需求； 大促中我们的后端主管说过句很好理解的话，看到大促这么多问题很激动，这很好，问题越多机会才越大，如果都是稳定健壮的系统、完善的流程、合作良好的团队，要大促 PM 干什么呢？ ","date":"2022-03-07","objectID":"/posts/job/management/beleader/:2:0","tags":[""],"title":"管理","uri":"/posts/job/management/beleader/"},{"categories":["Tech"],"content":"向上管理 我会迫切希望团队有问题一定要说，甚至没有问题仅仅有想法可以说，保持有效沟通。 ","date":"2022-03-07","objectID":"/posts/job/management/beleader/:3:0","tags":[""],"title":"管理","uri":"/posts/job/management/beleader/"},{"categories":["Tech"],"content":"高效 我更希望团队和我交流的方式是优先让我做选择题、判断题，其次是问答题、思考题; ","date":"2022-03-07","objectID":"/posts/job/management/beleader/:3:1","tags":[""],"title":"管理","uri":"/posts/job/management/beleader/"},{"categories":["Tech"],"content":"主动 一个十几人的团队主管很难有精力面面俱到，了解所有人每天的细节，给大家找出合适方向和机会，甚至认真读完每个人的周报都要用一个下午，很难做到你有一个不错想法的时候主管恰好找你聊聊，如果我是—线主管，我更希望团队同学主动找我聊; 废话这么多，其实看看向上管理的一些理论知识就会有豁然开朗的感觉，知乎上 很接地气的总结; ","date":"2022-03-07","objectID":"/posts/job/management/beleader/:3:2","tags":[""],"title":"管理","uri":"/posts/job/management/beleader/"},{"categories":["Tech"],"content":"发现问题、解决问题 如果按照向上管理的思路，需要主管去分配任务的时候，就已经输了，甚至主管来找你问进度的时候也己经输了； 当然每个合格的主管都需要发现、解決团队人才培养的问题，不能放任问题发生。 ","date":"2022-03-07","objectID":"/posts/job/management/beleader/:4:0","tags":[""],"title":"管理","uri":"/posts/job/management/beleader/"},{"categories":["Tech"],"content":"什么样的人有积极性 能力强的人很好识别，那什么样的人才是有积极性的，看过一个牛逼的同学写的文章，他有个很好的习惯:无论大小难易，永远不满足于做出夹指定的事情，一定要给人惊喜 如果一个人可以在很多微不足道小事情上做出了惊喜，我们有理由相信这件更大的事情也可能做出惊喜。 ","date":"2022-03-07","objectID":"/posts/job/management/beleader/:4:1","tags":[""],"title":"管理","uri":"/posts/job/management/beleader/"},{"categories":["Tech"],"content":"我被分配了纯业务事情怎么办 上面也提到了简单分析只是业务需求，简单分析，在阿里将近五年见了太多事在人为的案例，每个人身边肯定也有不少这样的案例 我们以为自己在做业务，很多时候是因为两个误区 这不是技术项目 没有什么所谓的技木项目，所有的技术项目除非显而易见，否则肯定脱胎于业务，只有业务一线的同学才 可以抽象出来，做业务需求不是坏事情，拿着完成任务的心态做业务才是最要命的 没目标 所有做的事情都要契合自己的目标，而自己的目标大部分时候应该和团队目标 match，今天让我开发一个 前端组件，我要看到的是这个需求反应了我营销体系对某个分类能力的缺失，需求归纳到我营销可视化体 系完善的目标中，在阿里这种人才济济的环境中目标不清晰的人和咸鱼没什么区别 ","date":"2022-03-07","objectID":"/posts/job/management/beleader/:4:2","tags":[""],"title":"管理","uri":"/posts/job/management/beleader/"},{"categories":["Tech"],"content":"怎样才算业务负责人 我希望团队的业务负责人时刻在两个方面提醒自己 可衡量：很多时候说不出怎么衡量是因为对事情仅仅是简单直觉，没有经过逻辑推导； 体系化：当解决的问题足够复杂的时候，散点的创新不会有決定性的影响，层次的划分可以让方案更可 靠、全面，也能让人看到阶段性的成果，容易得到更多的资源的支持。 ","date":"2022-03-07","objectID":"/posts/job/management/beleader/:4:3","tags":[""],"title":"管理","uri":"/posts/job/management/beleader/"},{"categories":["生活"],"content":"攀爬 晶莹剔透 群山环绕 ","date":"2021-12-17","objectID":"/posts/life/sport/longwangshan/:1:0","tags":["龙王山","雾凇","户外"],"title":"[户外]龙王山-雾凇","uri":"/posts/life/sport/longwangshan/"},{"categories":["生活"],"content":"雾凇 对于没在山上长大的同学，能看到雾凇的机会不是太多； 近距离看雾凇 ","date":"2021-12-17","objectID":"/posts/life/sport/longwangshan/:2:0","tags":["龙王山","雾凇","户外"],"title":"[户外]龙王山-雾凇","uri":"/posts/life/sport/longwangshan/"},{"categories":["生活"],"content":"龙王山·雾凇（1587m） 到达山顶 ","date":"2021-12-17","objectID":"/posts/life/sport/longwangshan/:3:0","tags":["龙王山","雾凇","户外"],"title":"[户外]龙王山-雾凇","uri":"/posts/life/sport/longwangshan/"},{"categories":["生活"],"content":"记录 记录 ","date":"2021-12-17","objectID":"/posts/life/sport/longwangshan/:4:0","tags":["龙王山","雾凇","户外"],"title":"[户外]龙王山-雾凇","uri":"/posts/life/sport/longwangshan/"},{"categories":["读书笔记"],"content":"古语 子曰：“学而时习之，不亦说乎?有朋自远方来，不亦乐乎?人不知而不愠，不亦君子乎?”（《学而》） 曾子曰：“吾日三省吾身：为人谋而不忠乎？与朋友交而不信乎？传不习乎？”（《学而》） 子曰：“温故而知新，可以为师矣。”（《为政》） 子曰：“学而不思则罔,思而不学则殆。”（《为政》） 子曰：“由，诲女知之乎！知之为知之，不知为不知，是知也。”（《为政》） 子曰：“见贤思齐焉，见不贤而内自省也。”（《里仁》） 子曰：“三人行，必有我师焉。择其善者而从之，其不善者而改之。”（《述而》） 曾子曰：“士不可以不弘毅，任重而道远。仁以为己任，不亦重乎？死而后已，不亦远乎？”（《泰伯》） 子曰：“岁寒，然后知松柏之后凋也。”（《子罕》） 子贡问曰：“有一言而可以终身行之者乎？”子曰：“其恕乎！己所不欲，勿施于人。”（《卫灵公》） ","date":"2021-10-03","objectID":"/posts/book/famoussentence/:1:0","tags":["读书笔记"],"title":"[读书笔记] 吾日三省吾身","uri":"/posts/book/famoussentence/"},{"categories":["读书笔记"],"content":"今语 你永远都不会知道自己到底有多坚强，直到有一天你除了坚强别无选择！ ","date":"2021-10-03","objectID":"/posts/book/famoussentence/:2:0","tags":["读书笔记"],"title":"[读书笔记] 吾日三省吾身","uri":"/posts/book/famoussentence/"},{"categories":["读书笔记"],"content":"案例背景 中国正处在一个至关重要的十字路口上。制造廉价产品已使中国有了很大的发展，但上升的劳动力成本、环境问题、收入不平等以及对创新的需求都意味着重要的不是制造更廉价的产品，而是更好地进行产品营销。只有这样，中国才能赚更多的钱，才能在员工收入、环境保护和其他方面进行更大的投入。这意味着中国需要更好地掌握如何在顾客和潜在顾客的心智中建立品牌和认知，如何应对国内及国际上无处不在的竞争. 这也正是我的许多书能够发挥作用的地方。它们都是关于如何通过在众多竞争者中实现差昇化来定位自己的品牌；它们都是关于如何保持简单、如何运用常识以及如何寻求显而易见又强有力的概念。总的来讲，无论你想要销售什么，它们都会告诉你如何成为一个更好的营销者。 我的中国合伙人邓德隆先生正将其中的很多理论在中国加以运用，他甚至为企业家开设了 “定位”培训课程。但是，中国如果要建立自己的品牌，正如你们在日本、韩国和世界其他地方所看到的那些品牌，你们依然有很长的路要走。 但有一件事很明了：继续“制造更廉价的产品”只会死路一条，因为其他国家会想办法把价格压得更低。 ","date":"2021-08-21","objectID":"/posts/book/life_orientation/:1:0","tags":["规划"],"title":"[读书笔记] 《人生定位》","uri":"/posts/book/life_orientation/"},{"categories":["读书笔记"],"content":"新生产工具：定位 在此背景下，为组织准确定义成果的新生产工具一定位(positioning），在1969年被杰克•特芳特发明出来，掀起了第三次生产力革命。在谈到为何选择“定位”一词来命名这一新工具时，特劳特曾说：“《韦氏词典》对战略的定义是针对敌人（竞争对手），确立最具优势的位置 （position)。这正好是定位要做的工作。” 在顾客心智中针对竞争对手确定最具优势的位置，从而使品牌胜出竟争赢得优先选择，这就是企业需全力以赴抵达的成果，也是企业赖以存在的唯一理由。正如德鲁克在评价泰勒“四步工作法”时说：“泰勒的方法听起来没什么了不起有效的方法常常如此。其实这套方法花了泰勒整整20年的时间去试验，才整理发展出来。”这段话用来描述特劳特与定位同样适用。 ","date":"2021-08-21","objectID":"/posts/book/life_orientation/:2:0","tags":["规划"],"title":"[读书笔记] 《人生定位》","uri":"/posts/book/life_orientation/"},{"categories":["读书笔记"],"content":"定位四步工作法 第一步，分析整个外部环境，确定“我们的竞年对手是谁，竞争对手的价值是什么”（这与德鲁克在回答管理第一问“我们的业务是什么，应该是什么”时问的 “我们的顾客是谁，顾客的价值是什么”相反，因过多的选择、 有限的心智，决定了经营方式已从顾客导向转向了竞年导向）。 第二步，避开竞年对手在顾客心智中的强势，或是利用其强势中蕴含的弱点，确立品牌的优势位置-定位。 第三步，为这一定位寻求一个可靠的证明——信任状。 第四步，将这一定位整合进企业内部运营的方方面面，特别是传播上要有足够多的资源，以将这一定位植入顾客的心智 ","date":"2021-08-21","objectID":"/posts/book/life_orientation/:3:0","tags":["规划"],"title":"[读书笔记] 《人生定位》","uri":"/posts/book/life_orientation/"},{"categories":["leetcode"],"content":"一、数据结构的存储方式 数据结构的存储方式只有两种：数组（顺序存储）和链表（链式存储） 这句话怎么理解，不是还有散列表、栈、队列、堆、树、图等等各种数据结构吗？ 我们分析问题，一定要有递归的思想，自顶向下，从抽象到具体。你上来就列出这么多，那些都属于「上层建筑」，而数组和链表才是「结构基础」。因为那些多样化的数据结构，究其源头，都是在链表或者数组上的特殊操作，API 不同而已。 比如说「队列」、「栈」这两种数据结构既可以使用链表也可以使用数组实现。用数组实现，就要处理扩容缩容的问题；用链表实现，没有这个问题，但需要更多的内存空间存储节点指针。 「图」的两种表示方法，邻接表就是链表，邻接矩阵就是二维数组。邻接矩阵判断连通性迅速，并可以进行矩阵运算解决一些问题，但是如果图比较稀疏的话很耗费空间。邻接表比较节省空间，但是很多操作的效率上肯定比不过邻接矩阵。 「散列表」就是通过散列函数把键映射到一个大数组里。而且对于解决散列冲突的方法，拉链法需要链表特性，操作简单，但需要额外的空间存储指针；线性探查法就需要数组特性，以便连续寻址，不需要指针的存储空间，但操作稍微复杂些。 「树」，用数组实现就是「堆」，因为「堆」是一个完全二叉树，用数组存储不需要节点指针，操作也比较简单；用链表实现就是很常见的那种「树」，因为不一定是完全二叉树，所以不适合用数组存储。为此，在这种链表「树」结构之上，又衍生出各种巧妙的设计，比如二叉搜索树、AVL 树、红黑树、区间树、B 树等等，以应对不同的问题。 了解 Redis 数据库的朋友可能也知道，Redis 提供列表、字符串、集合等等几种常用数据结构，但是对于每种数据结构，底层的存储方式都至少有两种，以便于根据存储数据的实际情况使用合适的存储方式。 综上，数据结构种类很多，甚至你也可以发明自己的数据结构，但是底层存储无非数组或者链表，二者的优缺点如下： 数组由于是紧凑连续存储,可以随机访问，通过索引快速找到对应元素，而且相对节约存储空间。但正因为连续存储，内存空间必须一次性分配够，所以说数组如果要扩容，需要重新分配一块更大的空间，再把数据全部复制过去，时间复杂度 O(N)；而且你如果想在数组中间进行插入和删除，每次必须搬移后面的所有数据以保持连续，时间复杂度 O(N)。 链表因为元素不连续，而是靠指针指向下一个元素的位置，所以不存在数组的扩容问题；如果知道某一元素的前驱和后驱，操作指针即可删除该元素或者插入新元素，时间复杂度 O(1)。但是正因为存储空间不连续，你无法根据一个索引算出对应元素的地址，所以不能随机访问；而且由于每个元素必须存储指向前后元素位置的指针，会消耗相对更多的储存空间。 ","date":"2021-08-18","objectID":"/posts/tech/leetcode/algorithm/:1:0","tags":["算法","leetcode"],"title":"算法概述","uri":"/posts/tech/leetcode/algorithm/"},{"categories":["leetcode"],"content":"二、数据结构的基本操作 对于任何数据结构，其基本操作无非遍历 + 访问，再具体一点就是：增删查改。 数据结构种类很多，但它们存在的目的都是在不同的应用场景，尽可能高效地增删查改。话说这不就是数据结构的使命么？ 如何遍历 + 访问？我们仍然从最高层来看，各种数据结构的遍历 + 访问无非两种形式：线性的和非线性的。 线性就是 for/while 迭代为代表，非线性就是递归为代表。再具体一步，无非以下几种框架： 数组遍历框架，典型的线性迭代结构： void traverse(int[] arr) { for (int i = 0; i \u003c arr.length; i++) { // 迭代访问 arr[i] } } 链表遍历框架，兼具迭代和递归结构： /* 基本的单链表节点 */ class ListNode { int val; ListNode next; } void traverse(ListNode head) { for (ListNode p = head; p != null; p = p.next) { // 迭代访问 p.val } } void traverse(ListNode head) { // 递归访问 head.val traverse(head.next); } 二叉树遍历框架，典型的非线性递归遍历结构： /* 基本的二叉树节点 */ class TreeNode { int val; TreeNode left, right; } void traverse(TreeNode root) { traverse(root.left); traverse(root.right); } 你看二叉树的递归遍历方式和链表的递归遍历方式，相似不？再看看二叉树结构和单链表结构，相似不？如果再多几条叉，N 叉树你会不会遍历？ 二叉树框架可以扩展为 N 叉树的遍历框架： /* 基本的 N 叉树节点 */ class TreeNode { int val; TreeNode[] children; } void traverse(TreeNode root) { for (TreeNode child : root.children) traverse(child); } N 叉树的遍历又可以扩展为图的遍历，因为图就是好几 N 叉棵树的结合体。你说图是可能出现环的？这个很好办，用个布尔数组 visited 做标记就行了，这里就不写代码了。 所谓框架，就是套路。不管增删查改，这些代码都是永远无法脱离的结构，你可以把这个结构作为大纲，根据具体问题在框架上添加代码就行了，下面会具体举例。 ","date":"2021-08-18","objectID":"/posts/tech/leetcode/algorithm/:2:0","tags":["算法","leetcode"],"title":"算法概述","uri":"/posts/tech/leetcode/algorithm/"},{"categories":["leetcode"],"content":"三、算法刷题指南 首先要明确的是，数据结构是工具，算法是通过合适的工具解决特定问题的方法。也就是说，学习算法之前，最起码得了解那些常用的数据结构，了解它们的特性和缺陷。 所以我建议的刷题顺序是： 1、先学习像数组、链表这种基本数据结构的常用算法，比如单链表翻转，前缀和数组，二分搜索等。 因为这些算法属于会者不难难者不会的类型，难度不大，学习它们不会花费太多时间。而且这些小而美的算法经常让你大呼精妙，能够有效培养你对算法的兴趣。 2、学会基础算法之后，不要急着上来就刷回溯算法、动态规划这类笔试常考题，而应该先刷二叉树，先刷二叉树，先刷二叉树，重要的事情说三遍。 为什么要先刷二叉树呢，因为二叉树是最容易培养框架思维的，而且大部分算法技巧，本质上都是树的遍历问题。 刷二叉树看到题目没思路？根据很多读者的问题，其实大家不是没思路，只是没有理解我们说的「框架」是什么。 不要小看这几行破代码，几乎所有二叉树的题目都是一套这个框架就出来了： void traverse(TreeNode root) { // 前序位置 traverse(root.left); // 中序位置 traverse(root.right); // 后序位置 } 比如说我随便拿几道题的解法出来，不用管具体的代码逻辑，只要看看框架在其中是如何发挥作用的就行。 力扣第 124 题，难度困难，让你求二叉树中最大路径和，主要代码如下： 比如说我随便拿几道题的解法出来，不用管具体的代码逻辑，只要看看框架在其中是如何发挥作用的就行。 力扣第 124 题，难度困难，让你求二叉树中最大路径和，主要代码如下： int res = Integer.MIN_VALUE; int oneSideMax(TreeNode root) { if (root == null) return 0; int left = max(0, oneSideMax(root.left)); int right = max(0, oneSideMax(root.right)); // 后序位置 res = Math.max(res, left + right + root.val); return Math.max(left, right) + root.val; } 注意递归函数的位置，这就是个后序遍历嘛，无非就是把 traverse 函数名字改成 oneSideMax 了。 力扣第 105 题，难度中等，让你根据前序遍历和中序遍历的结果还原一棵二叉树，很经典的问题吧，主要代码如下： TreeNode build(int[] preorder, int preStart, int preEnd, int[] inorder, int inStart, int inEnd) { // 前序位置，寻找左右子树的索引 if (preStart \u003e preEnd) { return null; } int rootVal = preorder[preStart]; int index = 0; for (int i = inStart; i \u003c= inEnd; i++) { if (inorder[i] == rootVal) { index = i; break; } } int leftSize = index - inStart; TreeNode root = new TreeNode(rootVal); // 递归构造左右子树 root.left = build(preorder, preStart + 1, preStart + leftSize, inorder, inStart, index - 1); root.right = build(preorder, preStart + leftSize + 1, preEnd, inorder, index + 1, inEnd); return root; } 不要看这个函数的参数很多，只是为了控制数组索引而已。注意找递归函数 build 的位置，本质上该算法也就是一个前序遍历，因为它在前序遍历的位置加了一坨代码逻辑。 力扣第 230 题，难度中等，寻找二叉搜索树中的第 k 小的元素，主要代码如下： int res = 0; int rank = 0; void traverse(TreeNode root, int k) { if (root == null) { return; } traverse(root.left, k); /* 中序遍历代码位置 */ rank++; if (k == rank) { res = root.val; return; } /*****************/ traverse(root.right, k); } 这不就是个中序遍历嘛，对于一棵 BST 中序遍历意味着什么，应该不需要解释了吧。 你看，二叉树的题目不过如此，只要把框架写出来，然后往相应的位置加代码就行了，这不就是思路吗。 对于一个理解二叉树的人来说，刷一道二叉树的题目花不了多长时间。那么如果你对刷题无从下手或者有畏惧心理，不妨从二叉树下手，前 10 道也许有点难受；结合框架再做 20 道，也许你就有点自己的理解了；刷完整个专题，再去做什么回溯动规分治专题，你就会发现只要涉及递归的问题，都是树的问题。 综上，对于畏惧算法的同学来说，可以先刷树的相关题目，试着从框架上看问题，而不要纠结于细节问题。 纠结细节问题，就比如纠结 i 到底应该加到 n 还是加到 n - 1，这个数组的大小到底应该开 n 还是 n + 1？ 从框架上看问题，就是像我们这样基于框架进行抽取和扩展，既可以在看别人解法时快速理解核心逻辑，也有助于找到我们自己写解法时的思路方向。 当然，如果细节出错，你得不到正确的答案，但是只要有框架，你再错也错不到哪去，因为你的方向是对的。 但是，你要是心中没有框架，那么你根本无法解题，给了你答案，你也不会发现这就是个树的遍历问题。 这种思维是很重要的， 动态规划详解 中总结的找状态转移方程的几步流程，有时候按照流程写出解法，可能自己都不知道为啥是对的，反正它就是对了。。。 这就是框架的力量，能够保证你在快睡着的时候，依然能写出正确的程序；就算你啥都不会，都能比别人高一个级别。 本文最后，总结一下吧： 数据结构的基本存储方式就是链式和顺序两种，基本操作就是增删查改，遍历方式无非迭代和递归。 学完基本算法之后，建议从「二叉树」系列问题开始刷，结合框架思维，把树结构理解到位，然后再去看回溯、动规、分治等算法专题，对思路的理解就会更加深刻。 ","date":"2021-08-18","objectID":"/posts/tech/leetcode/algorithm/:3:0","tags":["算法","leetcode"],"title":"算法概述","uri":"/posts/tech/leetcode/algorithm/"},{"categories":["leetcode"],"content":"四、算法的本质 如果要让我一句话总结，我想说算法的本质就是「穷举」。 但是，你千万不要觉得穷举这个事儿很简单，穷举有两个关键难点：无遗漏、无冗余。 遗漏，会直接导致答案出错；冗余，会拖慢算法的运行速度。所以，当你看到一道算法题，可以从这两个维度去思考： 1、如何穷举？即无遗漏地穷举所有可能解。 2、如何聪明地穷举？即避免所有冗余的计算，消耗尽可能少的资源求出答案。 不同类型的题目，难点是不同的，有的题目难在「如何穷举」，有的题目难在「如何聪明地穷举」。 什么算法的难点在「如何穷举」呢？一般是递归类问题，最典型的就是动态规划系列问题。 ","date":"2021-08-18","objectID":"/posts/tech/leetcode/algorithm/:4:0","tags":["算法","leetcode"],"title":"算法概述","uri":"/posts/tech/leetcode/algorithm/"},{"categories":["leetcode"],"content":"Refer Refer to : https://labuladong.gitee.io/algo/2/ ","date":"2021-08-18","objectID":"/posts/tech/leetcode/algorithm/:5:0","tags":["算法","leetcode"],"title":"算法概述","uri":"/posts/tech/leetcode/algorithm/"},{"categories":["生活"],"content":" 2021.07.02-2021.07.05 ","date":"2021-07-13","objectID":"/posts/travel/wanning/:0:0","tags":["海南","万宁","三亚"],"title":"万宁Outing","uri":"/posts/travel/wanning/"},{"categories":["生活"],"content":"Day1 【周五】 周五下坐飞机飞海口，原计划14点的飞机，晚点到17点起飞； 20点左右到达海口，乘坐旅游大巴赶往万宁； 23点左右入到达万宁，入住神州半岛福朋喜来登酒店； 酒店在海边一个小岛的景区中，晚上人烟稀少，在周边找吃的有些费劲； ","date":"2021-07-13","objectID":"/posts/travel/wanning/:1:0","tags":["海南","万宁","三亚"],"title":"万宁Outing","uri":"/posts/travel/wanning/"},{"categories":["生活"],"content":"Day2【周六】 早起，自助餐早点，伙食还不错的； 酒店一日躺，下午海边泳池玩水； 酒店泳池 晚上附近找了个沙滩，玩篝火、吃烧烤、海边踩水； 万宁沙滩 万宁沙滩篝火 ","date":"2021-07-13","objectID":"/posts/travel/wanning/:2:0","tags":["海南","万宁","三亚"],"title":"万宁Outing","uri":"/posts/travel/wanning/"},{"categories":["生活"],"content":"Day3【周日】 坐高铁到三亚，开启三亚一日游模式； 三亚凤凰岛 鸿洲国际游艇码头 浪里个浪，耗资几百大元，体验了把人工潜水+水下拍照，体验效果：近海区水太脏了，照片效果令人堪忧，完美踩坑； 晚上搜了家大众点评top3的海鲜店，吃海鲜，口味很棒；吃完返程回万宁； ","date":"2021-07-13","objectID":"/posts/travel/wanning/:3:0","tags":["海南","万宁","三亚"],"title":"万宁Outing","uri":"/posts/travel/wanning/"},{"categories":["生活"],"content":"Day4【周一】 早起，先坐大巴到海口，然后回杭； ","date":"2021-07-13","objectID":"/posts/travel/wanning/:4:0","tags":["海南","万宁","三亚"],"title":"万宁Outing","uri":"/posts/travel/wanning/"},{"categories":["生活"],"content":"学习的人 近期发现一部不错的韩国纪录片，关于如何学习，片名《学习的人.Homo.Academics》, 网易公开课、哔哩哔哩或外网均有完整视频。 这部片值得反复观看学习。 网易公开课 纪录片中，通过对韩国、中国、美国、英国、印度等国家进行深入采访，对比不同年龄段、不同民族、不同文化群体的学习方式； 印象最深刻的是犹太族的家庭教育和犹太族的图书馆： 犹太的家庭教育，家长会在晚餐时，问孩子\"你今天在学校都问了哪些问题？\" 犹太人的图书馆，不是静悄悄，而是大声的激烈讨论、辩论会场； 引申思考：如何做，才能成为一名会学习的人？ ","date":"2021-06-26","objectID":"/posts/life/movie/learning/:1:0","tags":["纪录片"],"title":"[纪录片] 学习的人.Homo.Academics","uri":"/posts/life/movie/learning/"},{"categories":["生活"],"content":"70-20-10学习法则 《70-20-10学习法则》源自Center for Creative Leadership（CCL，创新领导力中心）的Morgan McCall、Bob Eichinger和 Mike Lombardo在20世纪80年代提出的“历练驱动型发展”（experience-driven development） 该法则认为成人学习70%来自挑战性在职任务、20%来自与他人的合作与洞察、10%来自正式或虚拟课堂。 在当今工作中，该学习法则被证明是一种有效的全新的作为学习支持和发展的工具。即每个人的学习由以下途径\u0026\u0026占比构成： 70％来自于工作中的学习 20％来自与同事间的沟通学习 10%来自于课程教学和阅读 学习法则中20％的学习是向他人学习，这种非正式学习对于个人学习发挥着重要的作用。 首先创造一个知识共享的文化环境，就是要了解领导在想什么，如何对企业团队发挥作用。 需要让HR和员工意识到，工作中重要的知识共享可以通过维基，网络会议和非正式聊天发生。 一个企业，一个员工的学习和发展的需求若被满足，那么员工将会更具积极性，企业也将更有竞争力，从而才能够吸引和保留住最优秀的人才。积极进取的员工将充分利用70-20-10 学习法则带动自己，一旦他们意识这一学习法则的优越性，他们自身则将更加主动去为自己安排更多的学习机会。 ","date":"2021-06-26","objectID":"/posts/life/movie/learning/:2:0","tags":["纪录片"],"title":"[纪录片] 学习的人.Homo.Academics","uri":"/posts/life/movie/learning/"},{"categories":["生活"],"content":"吴越古道➕浙西天池 吴越古道 队伍 生命的力量 微视角 ","date":"2021-05-03","objectID":"/posts/life/sport/zhexidaxiagu/:1:0","tags":["户外"],"title":"[户外]吴越古道➕浙西天池","uri":"/posts/life/sport/zhexidaxiagu/"},{"categories":["生活"],"content":"刷新徒步新记录 20.76km，刷新单日徒步记录； ","date":"2021-05-03","objectID":"/posts/life/sport/zhexidaxiagu/:2:0","tags":["户外"],"title":"[户外]吴越古道➕浙西天池","uri":"/posts/life/sport/zhexidaxiagu/"},{"categories":["生活"],"content":"开跑 第一次报名参加越野跑，也就是传说中的跑山、跑土路，听上去就蛮刺激的； 起点-开跑 ","date":"2021-04-24","objectID":"/posts/life/sport/westlake2021/:1:0","tags":["马拉松","户外"],"title":"[户外]西湖群山-10km越野赛","uri":"/posts/life/sport/westlake2021/"},{"categories":["生活"],"content":"一路风景 真的跑山哈，没路的话，就硬踩出路。 山里找路 左右边都是茶田，空气蛮好； 总行程10.3km，总耗时98分钟，两步路记录比较准确。 记录 ","date":"2021-04-24","objectID":"/posts/life/sport/westlake2021/:2:0","tags":["马拉松","户外"],"title":"[户外]西湖群山-10km越野赛","uri":"/posts/life/sport/westlake2021/"},{"categories":["生活"],"content":"获奖 首次参加越野跑，在崎岖的山路上，做到团队领头羊，冲在最前面，同时鼓励team成员，咬紧牙关，向前冲😀😀！ 最终5人小组赛10km越野跑，取得团队组第一的好成绩！🏆 奖品是人手500g 西湖明前龙井茶叶，不错不错； 战绩 ","date":"2021-04-24","objectID":"/posts/life/sport/westlake2021/:3:0","tags":["马拉松","户外"],"title":"[户外]西湖群山-10km越野赛","uri":"/posts/life/sport/westlake2021/"},{"categories":["生活"],"content":"方向 一到两个 方向/赛道，不要多。 知识分享、知识付费 资料 自媒体-1 自媒体-2 自媒体-3 所有的行业-》提供产品，服务消费者，教培行业[知识付费] 每天都在重复、传授、吸收知识。– 如教师行业 知识星球。 知识是掌握路径： 学习 -\u003e 听，学、练习、掌握 -\u003e 遗忘 -》 使用前，在此学习。 如果你像日常三餐、睡觉一样的频率和规律 去反复学习同一拨知识，你的掌握水平会高于其他人。 ","date":"2021-01-03","objectID":"/posts/thinking/mine-thinking/:0:0","tags":["学习"],"title":"[思考-记录]mine-thinking","uri":"/posts/thinking/mine-thinking/"},{"categories":["中间件","缓存"],"content":"常用三个框架 Caffeine, GuavaCache, EhCache ","date":"2020-11-01","objectID":"/posts/middleware/cache/cache/:0:0","tags":["缓存"],"title":"缓存框架小结","uri":"/posts/middleware/cache/cache/"},{"categories":["中间件","缓存"],"content":"前言 在大部分互联网架构中 Cache 己经成为了必可不少的一环- 常用的方案有大家熟知的 NoSQL数据库 (Redis、Memcached) 等,也有大量的进程内缓存 Caffeine、EhCache、Guava Cache等. ","date":"2020-11-01","objectID":"/posts/middleware/cache/cache/:1:0","tags":["缓存"],"title":"缓存框架小结","uri":"/posts/middleware/cache/cache/"},{"categories":["中间件","缓存"],"content":"缓存框架介绍 ","date":"2020-11-01","objectID":"/posts/middleware/cache/cache/:2:0","tags":["缓存"],"title":"缓存框架小结","uri":"/posts/middleware/cache/cache/"},{"categories":["中间件","缓存"],"content":"1.Caffeine Caffeine是一个基于Java8开发的提供了近乎最佳命中率的高性能的缓存库， 缓存和ConcurrentMap有点相似，但还是有所区别- 最根本的区别是ConcurrentMap将会持有所有加入到缓存当中的元素， 直到它们被从缓存当中手动移除- 但是，Caffeine的缓存Cache 通常会被配置成自动驱逐缓存中元素，以限制其内存占用- 在某些场景下，LoadingCache 和AsyncLoadingCache 因为其自动加载缓存的能力将会变得非常实用，Spring5 开始不再支持 Guava Cache, 改用Caffeine. ","date":"2020-11-01","objectID":"/posts/middleware/cache/cache/:2:1","tags":["缓存"],"title":"缓存框架小结","uri":"/posts/middleware/cache/cache/"},{"categories":["中间件","缓存"],"content":"2.EhCache EhCache 是一个用Java实现的使用简单，高速，实现线程安全的缓存管理类库，而且从12之后就支持了集群 ehcache提供 了用内存，磁盘文件存储，以及分布式存储方式等多种灵活的cache管理方案- 同时ehcache作为开放源代码项目，采用限 制比较宽松的Apache License V2.0作为授权方式，被广泛地用于Hibernate, Spring， Cocoon等其他开源系统- ","date":"2020-11-01","objectID":"/posts/middleware/cache/cache/:2:2","tags":["缓存"],"title":"缓存框架小结","uri":"/posts/middleware/cache/cache/"},{"categories":["中间件","缓存"],"content":"3.GuavaCache guava cache是google开源的一款本地缓存工具库，它的设计灵感来源于ConcurrentHashMap， 使用多个segments方式的 细粒度锁，在保证线程安全的同时，支持高并发场景需求，同时支持多种类型的緩存清理策略，包括基于容量的清理、基于 时间的清理、基于引用的清理等- ","date":"2020-11-01","objectID":"/posts/middleware/cache/cache/:2:3","tags":["缓存"],"title":"缓存框架小结","uri":"/posts/middleware/cache/cache/"},{"categories":["中间件","缓存"],"content":"缓存框架主要特性 ","date":"2020-11-01","objectID":"/posts/middleware/cache/cache/:3:0","tags":["缓存"],"title":"缓存框架小结","uri":"/posts/middleware/cache/cache/"},{"categories":["中间件","缓存"],"content":"1.Caffeine Caffeine提供了灵活的构造器去创建一个拥有下列特性的缓存： 自动加载元素到缓存当中，异步加载的方式也可供选择 当达到最大容量的时候可以使用基于就近度和频率的算法进行基于容量的驱逐 将根据缓存中的元素上一次访问或者被修改的时间进行基于过期时间的驱逐 当向缓存中一个已经过时的元素进行访问的时候将会进行异步刷新 key将自动被弱引用所封装 value将自动被弱引用或者软引用所封装 驱逐(或移除)缓存中的元素时将会进行通知 写入传播到一个外部数据源当中 持续计算缓存的访问统计指标 为了提高集成度，扩展模块提供了JSR-107 JCache 和Guava适配器- JSR-107规范了基于Java 6的API，在牺牲了功 能和性能的代价下使代码更加规范- Guava的Cache是Caffeine的原型库并且Caffeine提供了适配器以供简单的迁移策略 ","date":"2020-11-01","objectID":"/posts/middleware/cache/cache/:3:1","tags":["缓存"],"title":"缓存框架小结","uri":"/posts/middleware/cache/cache/"},{"categories":["中间件","缓存"],"content":"2.EhCache 快速，针对大型高并发系统场景，Ehcache的多线程机制有相应的优化改善 简单，很小的jar包，简单配置就可直接使用，单机场景下无需过多的其他服务依赖 支持多种的缓存策略，灵活 缓存数据有两级：内存和磁盘，与一般的本地内存缓存相比，有了磁盘的存储空间，将可以支持更大量的数据缓存需求 具有缓存和缓存管理器的监听接口，能更简单方便的进行缓存实例的监控管理 支持多缓存管理器实例，以及一个实例的多个缓存区域 Ehcache的超时设置主要是针对整个cache实例设置整体的超时策略，而没有较好的处理针对单独的key的个性的超时设置 因此，在使用中要注意过期失效的缓存元素无法被GC回收，时间越长缓存越多，内存占用也就越大，内存泄露的概率也越大 ","date":"2020-11-01","objectID":"/posts/middleware/cache/cache/:3:2","tags":["缓存"],"title":"缓存框架小结","uri":"/posts/middleware/cache/cache/"},{"categories":["中间件","缓存"],"content":"3.GuavaCache Guava Cache的架构设计灵感ConcurrentHashMap，在简单场景中可以通过HashMap实现简单数据缓存，但如果要 实现缓存随时间改变、存储的数据空间可控则缓存工具还是很有必要的- cache存储的是键值对的集合，不同时是还 需要处理缓存过期、动态加载等算法逻辑，需要额外信息实现这些操作，对此根据面向对象的思想，还需要做方法与 数据的关联性封装，主要实现的缓存功能有：自动将节点加载至缓存结构中，当緩存的数据超过最大值时，使用LRU 算法替换；它具备根据节点上一次被访问或写入时间计算缓存过期机制，缓存的key被封装在WeakReference引用 中，缓存的value被封装在 WeakReference 或 SoftReference 引用中; 还可以统计缓存使用过程中的命中率、异常率和命中率等统计数据. ","date":"2020-11-01","objectID":"/posts/middleware/cache/cache/:3:3","tags":["缓存"],"title":"缓存框架小结","uri":"/posts/middleware/cache/cache/"},{"categories":["中间件","缓存"],"content":"缓存框架原理 ","date":"2020-11-01","objectID":"/posts/middleware/cache/cache/:4:0","tags":["缓存"],"title":"缓存框架小结","uri":"/posts/middleware/cache/cache/"},{"categories":["中间件","缓存"],"content":"1.Caffeine 主要原理 1.1淘汰算法 1.1.1常见算法 对于 Java 进程内缓存我们可以通过 HashMap 来实现。不过，Java 进程内存是有限的，不可能无限地往里面放缓存对象。 这就需要有合适的算法辅助我们淘汰掉使用价值相对不高的对象，为新进的对象留有空间。常见的缓存淘汰算法有 FIFO、LRU、LFU. FIFO(First In First Out): 先进先出 它是优先淘汰掉最先缓存的数据、是最简单的淘汰算法。缺点是如果先缓存的数据使用频率比较高的话，那么该数据就不停 地进进出出，因此它的缓存命中率比较低。 LRU(Least Recently Used): RRA. 它是优先淘汰掉最久未访问到的数据。缺点是不能很好地应对偶然的突发流量。比如一个数据在一分钟内的前59秒访问很多 次，而在最后1秒没有访问，但是有一批冷门数据在最后一秒进入缓存，那么热点数据就会被冲刷掉。 LFU(Least Frequently Used) : 最近最少频率使用。它是优先淘汰掉最不经常使用的数据，需要维护一个表示使用频率的字段。 主要有两个缺点： 如果访问频率比较高的话，频率宇段会占据一定的空间； 无法合理更新新上的热点数据，比如某个歌手的老歌播放历史较三，新出的歌如果和老歌一起排序的话，就永无出头之日; 1.1.2 W-TinyLFU 算法 Caffeine 使用了 W-TinyLFU 算法，解决了 LRU 和 LFU 上述的缺点，它主要干了两件事： 采用 Count-Min Sketch 算法降低频率信息带来的内存消耗； 维护一个PK机制保障新上的热点数据能够缓存。 如下图所示，Count-Min Sketch 算法类似布隆过滤器(Bloom fiter)思想，对子频率统计我们其实不需要一个精确值。存储 数据时，对key进行多次 hash 函数运算后，二维数组不同位置存储频率（Caffeine 实际实现的时候是用一维long 型数组， 每个long 型数字切分成16份，每份4bit，默认15次为最高访问频率，每个key实际 hash 了四次，落在不同 long 型数宇的16 份中某个位置）。读取某个key的访问次数时，会比较所有位置上的频率值，取最小值返口。对于所有key的访问频率之和有 个最大值，当达到最大值时，会进行reset即对各个缓存key的场率除以2。 Count-Min Sketch 如下图缓存访问频率存储主要分为两大部分，即 LRU 和 Segmented LRU。 新访问的数据会进入第一个 LRU，在 Caffeine 里叫 WindowDeque. 当WindowDeque满时, 会进入Segmented LRU 中的 ProbationDeque, 在后续被访问到时，它会 被提升到 ProtectedDeque。当 ProtectedDeque 满时，会有数据降级到 ProbationDeque。数据需要淘汰的时候，对 probationDeque 中的数据进行淘汰。具体淘汰机制：取ProbationDeque 中的队首和队尾进行 PK，队首数据是最先进入队 列的，称为受害者，队尾的数据称为攻击者，比较两者 频率大小，大胜小汰 ","date":"2020-11-01","objectID":"/posts/middleware/cache/cache/:4:1","tags":["缓存"],"title":"缓存框架小结","uri":"/posts/middleware/cache/cache/"},{"categories":["中间件","缓存"],"content":"2.EnCache 主要原理 略 ","date":"2020-11-01","objectID":"/posts/middleware/cache/cache/:4:2","tags":["缓存"],"title":"缓存框架小结","uri":"/posts/middleware/cache/cache/"},{"categories":["中间件","缓存"],"content":"3.GuavaCache主要原理 Guava Cache实质是一个在本地缓存KV数据的LocalCache。而LocalCache的数据结构和ConcurrentHashMap一样， 都采用分 segment 来细化管理HashMap中的节点Entry。不同的是LocalCache 中的 ReferenceEntry节点更为复杂。 数据结构简图大致如下： 图? 另外视缓存是否需要使用特别的引用策略(非Strong引用).以及设置的超时过期策路不同 (expireAfterAccess, expire AfterWrite）每个Segment中会维护最多以下5个队列： keyReferenceQueue： 存储了即将被GC回收的缓存数据K引1用列表 （当缓存设置了非强引用策略时该队列生效) valueReferenceQueue：存储了即将被GC回收的缓存数据Value弓1用列表（当缓存设置了非强引用策略时该队列生效） recencyQueue ： 存储最近访问的Entry列表，为了提升访问性能使用的辅助队列。 accessQueue：存储了基于最近访问时间排序的segment中所有ReferenceEntry的一个双向链表(当选择基于访问时间失效策略的时候用到该队列) WriteQueve： 存储了基于最近写入时间排序的segment中所有Entry的一个双向链表(当选择基于写入时问失效策略的时候用到该队列） 此外segment中还维护了2个变量count(记录当前segment中节点数量)，modcount (记录当 前segment变更次数） ","date":"2020-11-01","objectID":"/posts/middleware/cache/cache/:4:3","tags":["缓存"],"title":"缓存框架小结","uri":"/posts/middleware/cache/cache/"},{"categories":["中间件","缓存"],"content":"缓存基本用法 code 某他高级用法用法汇总: 通过异步自动加载实体到缓存中 基于大小的回收策略 基于时间的回收策略 自动刷新 key自动封装虚引用 value自动封装弱引用或软引1用 实体过期或被删除的通知 写入外部资源 统计累计访问缓存 加载策略 手动加载 同步加载 异步加载 回收策略 Caffeine提供了 3种回收策略：基于大小回收，基于时间回收，基手号用回收 统计缓存使用情况 通过使用Caffeine.recordStats… ","date":"2020-11-01","objectID":"/posts/middleware/cache/cache/:5:0","tags":["缓存"],"title":"缓存框架小结","uri":"/posts/middleware/cache/cache/"},{"categories":["中间件","缓存"],"content":"总结 个人推荐使用 Caffeine 算法W-TinyLFU算法它的命中率非常高，内存小，异步化，不阻塞。 无论是读写,Caffeine性能都比 Guava要好。 Caffeine基于java8的高性能，接近最优的缓存库。 Caffeine提供的内存缓存使用参考 Google guava的API。 Caffeine 是基于 Google guava 和 ConcurrentLinkedHashMap的设计经验上改进的成果。 • Caffeine 是Spring 5 默认支持的cache，可见Spring对它的看中，Spring抛弃Guava 转向了 Caffeine. ","date":"2020-11-01","objectID":"/posts/middleware/cache/cache/:6:0","tags":["缓存"],"title":"缓存框架小结","uri":"/posts/middleware/cache/cache/"},{"categories":["中间件","消息"],"content":"什么是消息中间件 消息队列 (MQ全称: Message Queue) 是应用程序和应用程序之间的通信方法。 MQ关注于数据的发送和接收，利用高效、可靠的异步消息传递机制集成分布式系统。通过提供消息传递和消息排队模型，它可以在分布式环境下扩展进程间的通信。 ","date":"2020-09-12","objectID":"/posts/middleware/mq/mq/:1:0","tags":["消息"],"title":"消息(MQ)小结","uri":"/posts/middleware/mq/mq/"},{"categories":["中间件","消息"],"content":"为什么需要消息中间件 在项目中，可将一些无需即时返回且耗时的操作提取出来，进行异步处理，这种异步处理的方式大大的节省了服务器的请求响应时间，最终提高了系统的吞吐量。 ","date":"2020-09-12","objectID":"/posts/middleware/mq/mq/:2:0","tags":["消息"],"title":"消息(MQ)小结","uri":"/posts/middleware/mq/mq/"},{"categories":["中间件","消息"],"content":"系统解耦 MQ相当于一个中介，生产方通过MQ与消费方交互，它将应用程序进行解耦合。 使用MQ后，系统就把自己的一份核心数据发到MQ里，下游哪个系统需要就自己去消费，不需要的话，不用消费即可。 ","date":"2020-09-12","objectID":"/posts/middleware/mq/mq/:2:1","tags":["消息"],"title":"消息(MQ)小结","uri":"/posts/middleware/mq/mq/"},{"categories":["中间件","消息"],"content":"异步调用 将不需要同步处理的并且耗时长的操作由消息队列通知消息接收方进行异步处理。提高了应用程序的响应时间。 ","date":"2020-09-12","objectID":"/posts/middleware/mq/mq/:2:2","tags":["消息"],"title":"消息(MQ)小结","uri":"/posts/middleware/mq/mq/"},{"categories":["中间件","消息"],"content":"流量削峰 假设你有一个系统，平时正常的时候每秒可能就几十个请求，系统正常处理都是OK的，每秒几百请求是可以轻松抗住的； 但假设在高峰期每秒钟有上万个请求，瞬间出现了流量高峰，此时你的选择是要搞扩容机器，能否抗住这个瞬时高峰吗？ 此时我们就可以用MQ中间件来进行流量削峰。所有机器前面部署一层MQ，平时每秒几百请求大家都可以轻松接收消息。 一旦到了瞬时高峰期，一下涌入每秒几万的请求，就可以积压在MQ里面，然后用机器慢慢的消费和处理。 这个就是很典型的一个MQ的用法，用有限的机器资源承载高并发请求，如果业务场景允许异步削峰，高峰期积压一些请求在MQ里，然后高峰期过了，后台系统在一定时间内消费完毕不再积压的话，那就很适合用这种技术方案。 ","date":"2020-09-12","objectID":"/posts/middleware/mq/mq/:2:3","tags":["消息"],"title":"消息(MQ)小结","uri":"/posts/middleware/mq/mq/"},{"categories":["中间件","消息"],"content":"常见的消息中间件有哪些 ","date":"2020-09-12","objectID":"/posts/middleware/mq/mq/:3:0","tags":["消息"],"title":"消息(MQ)小结","uri":"/posts/middleware/mq/mq/"},{"categories":["中间件","消息"],"content":"RocketMQ 阿里系下开源的一款分布式、队列模型的消息中间件，原名Metaq，后来3.0版本改为RocketMQ，是阿里参照kafka设计思想使用java实现的一套mq。同时将阿里系内部多款mq产品（Notify、metaq）进行整合，只维护核心功能，去除了所有其他运行时依赖，保证核心功能最简化，在此基础上配合阿里上述其他开源产品实现不同场景下mq的架构，目前主要多用于订单交易系统。 具有以下特点： 能够保证严格的消息顺序 提供针对消息的过滤功能 提供丰富的消息拉取模式 高效的订阅者水平扩展能力 实时的消息订阅机制 亿级消息堆积能力 ","date":"2020-09-12","objectID":"/posts/middleware/mq/mq/:3:1","tags":["消息"],"title":"消息(MQ)小结","uri":"/posts/middleware/mq/mq/"},{"categories":["中间件","消息"],"content":"ActiveMQ Apache下的一个子项目。 使用Java完全支持JMS1.1和J2EE 1.4规范的 JMS Provider实现，少量代码就可以高效地实现高级应用场景。 可插拔的传输协议支持，比如TCP, SSL, NIO, UDP等。 RabbitMQ、ZeroMQ、ActiveMQ均支持常用的多种语言客户端 C++、Java、.Net,、Python、 Php、 Ruby等。 ","date":"2020-09-12","objectID":"/posts/middleware/mq/mq/:3:2","tags":["消息"],"title":"消息(MQ)小结","uri":"/posts/middleware/mq/mq/"},{"categories":["中间件","消息"],"content":"RabbitMQ 使用Erlang编写的一个开源的消息队列，本身支持很多的协议：AMQP、XMPP、SMTP、STOMP，也正是如此，使的它变的非常重量级，更适合于企业级的开发。 实现了Broker架构，核心思想是生产者不会将消息直接发送给队列，消息在发送给客户端时先在中心队列排队。 对路由(Routing)，负载均衡(Load balance)、数据持久化都有很好的支持。 ","date":"2020-09-12","objectID":"/posts/middleware/mq/mq/:3:3","tags":["消息"],"title":"消息(MQ)小结","uri":"/posts/middleware/mq/mq/"},{"categories":["中间件","消息"],"content":"Kafka Apache下的一个子项目，使用scala实现的一个高性能分布式Publish/Subscribe消息队列系统，具有以下特性： 快速持久化：通过磁盘顺序读写与零拷贝机制，可以在O(1)的系统开销下进行消息持久化； 高吞吐：在一台普通的服务器上既可以达到10W/s的吞吐速率； 高堆积：支持topic下消费者较长时间离线，消息堆积量大； 完全的分布式系统：Broker、Producer、Consumer都原生自动支持分布式，依赖zookeeper自动实现负载均衡； 支持Hadoop数据并行加载：对于像Hadoop的一样的日志数据和离线分析系统，但又要求实时处理的限制，这是一个可行的解决方案。 ","date":"2020-09-12","objectID":"/posts/middleware/mq/mq/:3:4","tags":["消息"],"title":"消息(MQ)小结","uri":"/posts/middleware/mq/mq/"},{"categories":["中间件","消息"],"content":"各种MQ之间的比较 ","date":"2020-09-12","objectID":"/posts/middleware/mq/mq/:4:0","tags":["消息"],"title":"消息(MQ)小结","uri":"/posts/middleware/mq/mq/"},{"categories":["Tech"],"content":"文字转语音 ","date":"2020-09-10","objectID":"/posts/tech/tools/mac-translate-word/:1:0","tags":["mac"],"title":"Mac文字语音转换","uri":"/posts/tech/tools/mac-translate-word/"},{"categories":["Tech"],"content":"say的常用方法 say -v ‘?’ ;列出所有播音员 say -o xxx.acc ;指出输出文件名称 say -f xxx.xxx ;指出输入文件名称 say -v Ting-Ting 我爱你中国 ;指定播音员”Ting-Ting“说”我爱你中国“。 参见：https://www.jianshu.com/p/5d01cc011c6c ","date":"2020-09-10","objectID":"/posts/tech/tools/mac-translate-word/:1:1","tags":["mac"],"title":"Mac文字语音转换","uri":"/posts/tech/tools/mac-translate-word/"},{"categories":["Tech"],"content":"简单调用 在mac的命令行下面，执行： say hello world 就可以发出\"hello world\"的声音了，支持中文。 ","date":"2020-09-10","objectID":"/posts/tech/tools/mac-translate-word/:1:2","tags":["mac"],"title":"Mac文字语音转换","uri":"/posts/tech/tools/mac-translate-word/"},{"categories":["Tech"],"content":"文本文件播放语音 新建一个文本文件aa.txt，在终端里在，cd 到该目录，然后执行: say -f aa.txt ","date":"2020-09-10","objectID":"/posts/tech/tools/mac-translate-word/:1:3","tags":["mac"],"title":"Mac文字语音转换","uri":"/posts/tech/tools/mac-translate-word/"},{"categories":["Tech"],"content":"文本文件转为语音文件 新建一个文本文件aa.txt，在终端里在，cd 到该目录，然后执行: say -f aa.txt -o a.m4a 即可生成a.m4a这个语音文件。 -f 后面跟的是需要转换成语音的文件，-o 是 -out 的意思。 ","date":"2020-09-10","objectID":"/posts/tech/tools/mac-translate-word/:1:4","tags":["mac"],"title":"Mac文字语音转换","uri":"/posts/tech/tools/mac-translate-word/"},{"categories":["Tech"],"content":"设置 修改语音声音 打开Mac系统偏好设置-\u003e辅助功能-\u003e语音 对于国人来说，Sin-ji是讲粤语的，而Ting-ting是讲普通话的。当然，所有的演员都认识英文。 可切换语种 可调整语速 ","date":"2020-09-10","objectID":"/posts/tech/tools/mac-translate-word/:1:5","tags":["mac"],"title":"Mac文字语音转换","uri":"/posts/tech/tools/mac-translate-word/"},{"categories":["Tech"],"content":"语音转文字 ","date":"2020-09-10","objectID":"/posts/tech/tools/mac-translate-word/:2:0","tags":["mac"],"title":"Mac文字语音转换","uri":"/posts/tech/tools/mac-translate-word/"},{"categories":["Tech"],"content":"1. MAC系统自带的听写功能 http://blog.itpub.net/69983418/viewspace-2772692/ 为获得最佳效果，每次说话的时长不要超过 40 秒。如果周围环境太吵，会让识别效果变差。 ","date":"2020-09-10","objectID":"/posts/tech/tools/mac-translate-word/:2:1","tags":["mac"],"title":"Mac文字语音转换","uri":"/posts/tech/tools/mac-translate-word/"},{"categories":["Tech"],"content":"2. Google Docs Voice Typing Mac听写软件下载：很少有人知道 Google Docs 有一个非常强大的免费语音识别引擎，它不仅可以将语音转录为文本，还可以让你使用语音命令更改文档的格式。 Google Docs 语音输入可以说比 Apple Dictation 更准确，但它仅适用于 Google Chrome 浏览器——它不适用于 Safari 或 Firefox。 要激活 Google Docs 语音输入功能，请打开任何 Google 文档并转到“工具” -\u003e “语音输入”，然后单击出现的麦克风以开始转录。 Google Docs Voice Typing 对于免费的在线文本转语音工具来说非常准确。 ","date":"2020-09-10","objectID":"/posts/tech/tools/mac-translate-word/:2:2","tags":["mac"],"title":"Mac文字语音转换","uri":"/posts/tech/tools/mac-translate-word/"},{"categories":["Tech"],"content":"3. T ","date":"2020-09-10","objectID":"/posts/tech/tools/mac-translate-word/:2:3","tags":["mac"],"title":"Mac文字语音转换","uri":"/posts/tech/tools/mac-translate-word/"},{"categories":["Tech"],"content":"参照 https://javascript.net.cn/articles/721 https://newsn.net/say/mac-command-say.html ","date":"2020-09-10","objectID":"/posts/tech/tools/mac-translate-word/:3:0","tags":["mac"],"title":"Mac文字语音转换","uri":"/posts/tech/tools/mac-translate-word/"},{"categories":["Tech"],"content":"思维导图 ","date":"2020-05-29","objectID":"/posts/tech/tools/tools-paint/:0:0","tags":["作图（paint）"],"title":"常用作图工具(工作\u0026\u0026生活)","uri":"/posts/tech/tools/tools-paint/"},{"categories":["Tech"],"content":"xmind UML ","date":"2020-05-29","objectID":"/posts/tech/tools/tools-paint/:1:0","tags":["作图（paint）"],"title":"常用作图工具(工作\u0026\u0026生活)","uri":"/posts/tech/tools/tools-paint/"},{"categories":["Tech"],"content":"plantUML Official website demo ","date":"2020-05-29","objectID":"/posts/tech/tools/tools-paint/:2:0","tags":["作图（paint）"],"title":"常用作图工具(工作\u0026\u0026生活)","uri":"/posts/tech/tools/tools-paint/"},{"categories":["Tech"],"content":"IDEA plant plugins idea plugin 流程图 ","date":"2020-05-29","objectID":"/posts/tech/tools/tools-paint/:3:0","tags":["作图（paint）"],"title":"常用作图工具(工作\u0026\u0026生活)","uri":"/posts/tech/tools/tools-paint/"},{"categories":["Tech"],"content":"Omni全家桶 OmniGraffle Mac平台的流程图绘制软件，相当于windows平台的visio OmniPlan 工期规划甘特图的工具 ","date":"2020-05-29","objectID":"/posts/tech/tools/tools-paint/:4:0","tags":["作图（paint）"],"title":"常用作图工具(工作\u0026\u0026生活)","uri":"/posts/tech/tools/tools-paint/"},{"categories":["Tech"],"content":"Gliffy diagrams ","date":"2020-05-29","objectID":"/posts/tech/tools/tools-paint/:5:0","tags":["作图（paint）"],"title":"常用作图工具(工作\u0026\u0026生活)","uri":"/posts/tech/tools/tools-paint/"},{"categories":["读书笔记"],"content":"整本书用口语在和读者交流，没有太多理论抽象，案例非常多，读起来相对轻松，如果有丰富的管理经验，甚至看目录即可。 ","date":"2020-05-02","objectID":"/posts/book/duplicateleader/:0:0","tags":["读书笔记"],"title":"[读书笔记]可复制的领导力：樊登的9堂上商业课程","uri":"/posts/book/duplicateleader/"},{"categories":["读书笔记"],"content":"第1章 80%的管理者能达到 80分 作者通过孔子和柏拉因教学方式的差异，总结了一个很有意思的观点：西方更强调逻得思维，讨论事物给出的答案非常的具象，而且习惯标准化；东方更强调综合思维，关注宏观问题，讨论内容非常抽象，很难标准化 在解决问题思维上，东方人依赖个人能力，而西方注重标准化，按照标准操作，一切任务都可 以完成。在管理学习上也应该标准化，普通人通过训练可以轻松拥有领导力 建立信任 建立团队 建工体系 建立文化 四个步骤很通俗易懂，在建立体系环节作者用麦当劳举例，麦当劳最核心 竞争力是其标准化，全世界麦当劳都可以高效、口味一致的提供服务给客户 ","date":"2020-05-02","objectID":"/posts/book/duplicateleader/:1:0","tags":["读书笔记"],"title":"[读书笔记]可复制的领导力：樊登的9堂上商业课程","uri":"/posts/book/duplicateleader/"},{"categories":["读书笔记"],"content":"第2章 明确角色定位，避免亲力亲为 这个道理很简单，但却是大部分新管理者角色未转换前最容易出现的问题 用球队来打个比方：就好比你是前锋，觉得后防不力，就老帮后卫防守，觉得中场组织很差．就老帮中场组织拿 球。当球队需要破门得分、往前传球的时候，却找不到你这个正印前锋的影子，那球队还能赢得了球吗？ 想要让团队获得持续健康的发展，必须激发团队各成员的潜能。在这个过程中不可避免会犯错，不犯错就不会发现自己各方面存在的缺陷。如果无法获得成长的空间和机会，也就没有意愿去承担厲开自己的责任、独当一面 团队管理者在培养人才的过程中，最大的挑战就是要眼睁睁地看着员工去犯错，要给员工试错的空间，培养属于员工的责任感，让他感觉这件事跟他自己是有关的，是需要他自己想办法解决的。 ","date":"2020-05-02","objectID":"/posts/book/duplicateleader/:2:0","tags":["读书笔记"],"title":"[读书笔记]可复制的领导力：樊登的9堂上商业课程","uri":"/posts/book/duplicateleader/"},{"categories":["读书笔记"],"content":"第3章 构建游戏化组织，让工作变的更有趣 这章的标题其实有些容易让人误解，作者想表达的是团队愿景的重要性，书中拿游戏举了例子：超级玛丽最终是为了营救公主、魔兽世界是为了带领阵营成长，甚至在线下欢呼庆祝全球同时在线人数突破4000万，共杀死20亿外星人- 团队所有同学要明白这个团队的终极目标是什么，我们为什么而努力 《硅谷钢铁侠 埃隆•马斯克的冒险人生》也提到过类似的观点，Spacex Tesla. solarCity 的所有员工都清楚公司的终极梦想是让人类变成跨行星物种，而且大概率在这一代人手中无法实现。但这不影响所有员工务实的在新能源、宇宙探索领域积极进取，更不影响公司盈利，顺便让马斯克做了 首富 ","date":"2020-05-02","objectID":"/posts/book/duplicateleader/:3:0","tags":["读书笔记"],"title":"[读书笔记]可复制的领导力：樊登的9堂上商业课程","uri":"/posts/book/duplicateleader/"},{"categories":["读书笔记"],"content":"第4章 理清关系，打造团队一致性 不要把团队比喻成家，因为家庭成员永远不会互相放弃，团队做不到这一点 团队就是球队，目标是赢球 通过建立共同目标、适当授权，让团队的事情成为员工自己想做的事情 ","date":"2020-05-02","objectID":"/posts/book/duplicateleader/:4:0","tags":["读书笔记"],"title":"[读书笔记]可复制的领导力：樊登的9堂上商业课程","uri":"/posts/book/duplicateleader/"},{"categories":["读书笔记"],"content":"第5章 用目标管人，而不是人管人 目标管理有四大难题，作者没有很理论性的给出答案，但识别到问题后，去找方案总归是个相对简单的事情 成员参与度不够，执行积极性不高：让每个成员都参与进来 资源匮乏：我们身边到处都有资源，只要有足够的创意，就可以收获意想不到的惊喜 目标拆分不合理：管理者需要根据实际情况进行具体评估，再做出合理的规划 目标总在变化：理解企业决定、提前准备预案 目标管理领域有一个非常著名的SMART法则 S Specific（明确具体） M Measurable（可量化） A Attainable（可接受、可实现） R Realistic（相关性、符合实际） T Time-limited（有时间限制） 为团队成员设置了合理的目标，并不意味着目标管理的完成，作者给了—个工具 利用目标书写公式、写出目标 列出阻碍目标实现的因素 列出可以帮助目标实现的条件 写下个人特征 列出要做的事情 ","date":"2020-05-02","objectID":"/posts/book/duplicateleader/:5:0","tags":["读书笔记"],"title":"[读书笔记]可复制的领导力：樊登的9堂上商业课程","uri":"/posts/book/duplicateleader/"},{"categories":["读书笔记"],"content":"第6章 利用沟通视窗，改善人际沟通 沟通视窗，也称乔哈里视窗，是一种关于沟通的技巧和理论，也被称为“自我意识的发现一反馈模型”。有效沟通就是这四个象限的有机融合。 隐私象限：正面沟通，避免误解 盲点象限：利用反馈看到自身局限 潜能象限：不要轻视每一名员工的潜能 公开象限：让员工尊重你，而不是怕你 ","date":"2020-05-02","objectID":"/posts/book/duplicateleader/:6:0","tags":["读书笔记"],"title":"[读书笔记]可复制的领导力：樊登的9堂上商业课程","uri":"/posts/book/duplicateleader/"},{"categories":["读书笔记"],"content":"第7章 学会倾听，创建良性的交流通道 倾听并不是不打断别人说话就可以，要点是吸收对方的信息，通过三个步骤可以做到 深呼吸：保证自己情绪稳定 提问：通过实时反馈，让对方感受到你的投入度 复述：确保信息有效性 书里面关于提问讲了两种问题模式：封闭性问题、开放性问题 开放性问题需要对方针对有关事情做进一步的描述，并把回答者的注意力转向所描述事情中比较具体的某个方面，开放性问题没有标准答案。管理者在团队沟通是应该尽量使用这种方式提问 封闭性问题是指那些只能用“是”或“不是”等具体答案来进行解答的问题，这种提问方式在销售层面有着较为广泛的应用，为的是不给客户考虑的空间，只要回答“是”或“不是”就好，造成一种心理催眠效果，“， YES成交法”是其典型代表。在和团队交流时候如果这么搞，出的问题就可想而知了 很有意思的是传销很爱用这种套路，比如一个标价3000元的洗脸盆，正常人大多不会购买，但这在传销组织中很 容易成交，话术大概这样进行 传销者：“朋友们，在外打拼这么多年，大家觉不觉得健康是一件非常重要的事情？是不是？” 观众：“是” 传销者：“那父母的健康是不是很重要？” 观众：“是” 传销者：“大家是不是感觉我们每天忙子事业，对父母的关心不够？” 观众：“是.” 传销者：“如果我们可以花一顿饭的钱，给父母带来健康和快乐．是不是一籍很划算的投资？” 观众：“是” 传销者：“如果我们可以花一顿饭的钱，给父母带来健康和快乐，是不是一笔很划算的投资？” 观众： “是” 传销者：“人老脚先老，洗脚可以使父母身体更加健康，更加长寿，是不是只要一顿饭的钱就可以实现，帮你完成孝心？” 观众 “是” 接下来，传销者还会设置很多需要观众回答“是”的问题，不光要回答“是”，还要观众点头表示认同。这是一种群体性的催眠方式，只要周围有两千人不断地点头说是，在连着说6次yes 后，传销者的第7个问题将会是“你是否 愿意购买？“此时肯定有人习惯性地说“yes”，3000元一个的脸盆就这样成交了。 〝7YES成交法”带来的销售额非常惊人。量然这种做法有违社会道德，但其中蕴含的原理却耐人寻味。 管理者在倾听时，经常会碰到对方情绪失控的情况，这时候简单安慰作用甚微，要学会用认同化解对方的失控情绪 如果我们面对对方的失控，只是重复地说“令静点”“理智点〞，而根本不照顾对方的情绪，那么对方的情绪就会越来越坏。更有效的处理方式应该是“反映情绪”，反映情绪是指在对方情绪出现波动的时候，通过一系列的询问让对方认识到自身的情绪状态 比如，管理者可以问员工“这件事让你很心烦，对吗？，这件事让你很难过，对吗？”“这件事让你很悲伤，对吗？“等类似的问题，实际上就是前文所说的封闭性问题，只需要让对方回答“是”或者“否”。管理者在面对情绪失 控的人时，最好的办法就是千方百计让对方说“是”。只要他说了“是”，情绪就会缓和，因为他从这个回答中找到了认同。 所以.一切所谓“艰难”的谈话，最难过的往往是第一关，即认同对方的情绪。过不了这一关，其他的沟通技巧都没办法起作用。核心是处理好情绪问题。 ","date":"2020-05-02","objectID":"/posts/book/duplicateleader/:7:0","tags":["读书笔记"],"title":"[读书笔记]可复制的领导力：樊登的9堂上商业课程","uri":"/posts/book/duplicateleader/"},{"categories":["读书笔记"],"content":"第8章 及时反馈，让员工敬重你、信任你 别用绩效考核代替反馈 警惕“推理阶梯”（想当然），避免误解和伤害 正面反馈要及时、准确 负面反馈对事不对人 觉得负面反馈很棘手时候，可以用三明治反馈 表扬员工平时、工作做得不错 指出员工现阶段、工作中存在的问题 告诉员工改进之、后会达到的成就 但也要警惕三明治反馈的陷阱，员工会有选择地接受那些表扬性的词汇，而将真正需要反思的问题拋诸脑后。更有甚者，由于管理者批评的语言婉转晦涩，员工甚至都不知道这是负面反馈。 当然更要避免另类的三明治反馈，前段时间看脱口秀，李雪琴也提到了领导拙劣的技巧 老板： 雪琴你今天挺好看的； 你看你那稿子写的什么破玩意，一天天寻思啥呢，带没带脑子来； 你这衣服也挺好看的 李雪琴：也说不上来老板这个三明治有什么不同，但就感觉薄皮大馅的呢？ 人在自信时才会勇于承担属于自己的责任，不自信时，就会觉得周围的人都在针对他，从而不愿意承认自己的过失，拒绝承担相关责任。 在大量工作中优先看到别人的缺点，是很多管理者的通病。这是我们的本能。优秀的企业管理者，必须尽力压制这 种本能，善于发现员工身上闪光的地方，表扬和强化它，员工会在不断的积极反馈中，明确自己的工作方向，更有勇气和力量承担责任。 ","date":"2020-05-02","objectID":"/posts/book/duplicateleader/:8:0","tags":["读书笔记"],"title":"[读书笔记]可复制的领导力：樊登的9堂上商业课程","uri":"/posts/book/duplicateleader/"},{"categories":["读书笔记"],"content":"第9章 有效利用时间，拒绝无效努力 这章作者主要介绍了如何做好一次头脑风暴和六顶思考帽的使用 头脑风暴最重要的就是对于意见不批评、不否定、不深入讨论 团队中有人提出了一个意见，另一个人开始针锋相对，探讨这个意见为什么不合适，然后这两人就开始顺着这个 意见的方向走下去了。这样整个会议的方向就开始出现偏差，整个会场只能听见二人的声音，火药味越来越浓。 其他的与会者心里会想，在这种场合提出白己的意见要冒着被批评、被指责的风险，不如将意见埋在心里。如果 反驳的人是管理者，其他人则更不敢发表不同意见，生怕被管理者当场驳斥。如此一来，自然无法收集到足够的 意见和信息，也会极大地降低团队的会议效率。 白帽 （中立、客观） 绿帽 （创意、巧思） 黄帽 （积极、正面) 红帽 （直觉、情感） 黑帽 （谨慎、负面） 蓝帽 （中立、客观） 六顶思考帽在很多场合听说过，作者举了个很贴切的例子，开高端牛肉拉面馆的几个合伙人，想出了一个营销创意：在一个月内，每天送出100份牛肉面给那些吃不起面的人。这种方案为拉面馆增添了慈善的噱头，通过微信转 发、媒体报道，很快就会吸引很多顾客。 我戴上蓝色思考帽，然后让他们依次戴上了红色思考帽和白色思考帽。一些事实．数据以及直觉思维都在友好的气氛中交流着。 会议很快就进入了黑色思考帽的环节，在戴上黑色思考帽之后，大家一开始都不发言。 于是我就规定所有与会成员每个人一定要想到至少一条负面因素。 过了一会儿，有个人说：“100碗面对后厨的压力可不小，如果赶上高峰期，很有可能影响其他顾客的就餐时间。 有一自然有二，第二个人很快也站了起来，说;“要是来了一群乞丐怎么办？这会严重影响门店的形象。 \"第三个声音响起：“如果每天来的都是同样的100个人该如何是好？这样根本起不到宣传的效果。 还有一个人说：“不要小看100碗面，这个成本也不少，店铺前期送面肯定是赔本赚吆喝，不知道能坚持多久。 如果我们每天给大家发面，突然有一天不发了，会不会引起大家的不满？这对店铺的名誉也不利。 听到大家提出的种种问题，出主意的人说自己确实没有思考周全，打算放弃。我笑着对他摇摇手，让所有人都带 上绿色思考帽，想一下这些问题的解决办法。 第一个人说：“我们可以在早上10点到11点之间发放这100碗面，这样就不会跟中午的高峰期冲突。 第二个人说：“我们可以不在店里宣传，改在互联网和微信上宣传，这样乞丐就不会来了。 第三个人说：“我们还可以学习国外的“墙上咖啡，做墙上拉面”。” （“墙上咖啡*的流程是： 一个人可以买两杯咖啡，其中一杯自己喝，另一杯挂在墙上。如果店里进来一个想喝咖啡却没带钱的人，就可以喝到别人买的咖啡 了。“墙上拉面”的方式与之类似，就是将其他人买好的拉面挂在墙上，供没钱的人享用，减少店里的经营成本。） 在群策群力下，团队拿出了最终的决策方案：慈善拉面的发放时间定为上午10点到11点，发放渠道是互联网和微 信，发送方式为“墙上拉面” ","date":"2020-05-02","objectID":"/posts/book/duplicateleader/:9:0","tags":["读书笔记"],"title":"[读书笔记]可复制的领导力：樊登的9堂上商业课程","uri":"/posts/book/duplicateleader/"},{"categories":["Spring"],"content":"概述 Springboot 秉承 “约定大于配置\"的理念，通过规范化的文件结构、约定的配置文件等方式，将复杂的pom引用依赖通过stater包等方式隐藏，同时各starter模块之间相互独立，化繁为简，提高工程研发效率。 ","date":"2019-11-23","objectID":"/posts/spring/springboot/starter/:1:0","tags":["SpringBoot"],"title":"Spring Boot Starter小结","uri":"/posts/spring/springboot/starter/"},{"categories":["Spring"],"content":"spring-boot-starter document spring-boot-document Starters Starters are a set of convenient dependency descriptors that you can include in your application. You get a one-stop shop for all the Spring and related technologies that you need without having to hunt through sample code and copy-paste loads of dependency descriptors. For example, if you want to get started using Spring and JPA for database access, include the spring-boot-starter-data-jpa dependency in your project. The starters contain a lot of the dependencies that you need to get a project up and running quickly and with a consistent, supported set of managed transitive dependencies. What is in a name All official starters follow a similar naming pattern; spring-boot-starter-*, where * is a particular type of application. This naming structure is intended to help when you need to find a starter. The Maven integration in many IDEs lets you search dependencies by name. For example, with the appropriate Eclipse or Spring Tools plugin installed, you can press ctrl-space in the POM editor and type “spring-boot-starter” for a complete list. As explained in the “Creating Your Own Starter” section, third party starters should not start with spring-boot, as it is reserved for official Spring Boot artifacts. Rather, a third-party starter typically starts with the name of the project. For example, a third-party starter project called thirdpartyproject would typically be named thirdpartyproject-spring-boot-starter. ","date":"2019-11-23","objectID":"/posts/spring/springboot/starter/:2:0","tags":["SpringBoot"],"title":"Spring Boot Starter小结","uri":"/posts/spring/springboot/starter/"},{"categories":["Spring"],"content":"spring-boot-starter source code ","date":"2019-11-23","objectID":"/posts/spring/springboot/starter/:3:0","tags":["SpringBoot"],"title":"Spring Boot Starter小结","uri":"/posts/spring/springboot/starter/"},{"categories":["Spring"],"content":"auto-spring-boot-starter demo ","date":"2019-11-23","objectID":"/posts/spring/springboot/starter/:4:0","tags":["SpringBoot"],"title":"Spring Boot Starter小结","uri":"/posts/spring/springboot/starter/"},{"categories":["Spring"],"content":"Refer to (Springboot document) Creating Your Own Starter ","date":"2019-11-23","objectID":"/posts/spring/springboot/starter/:5:0","tags":["SpringBoot"],"title":"Spring Boot Starter小结","uri":"/posts/spring/springboot/starter/"},{"categories":["Tech"],"content":"Chart github: Python3 pyecharts ","date":"2019-11-16","objectID":"/posts/tech/python/python3/:1:0","tags":["python"],"title":"python3","uri":"/posts/tech/python/python3/"},{"categories":["tech"],"content":"概要 Arthas 是一款线上(运行时)监控诊断产品，通过全局视角实时查看应用 load、内存、gc、线程的状态信息，并能在不修改应用代码的情况下，对业务问题进行诊断，包括查看方法调用的出入参、异常，监测方法执行耗时，类加载信息等，大大提升线上问题排查效率。 arthas官网 ","date":"2019-10-05","objectID":"/posts/tech/tools/arthas/:1:0","tags":["arthas"],"title":"Arthas(阿尔萨斯)","uri":"/posts/tech/tools/arthas/"},{"categories":["tech"],"content":"Arthas（阿尔萨斯）能为你做什么？ Arthas 是 Alibaba 开源的 Java 诊断工具，深受开发者喜爱。 当你遇到以下类似问题而束手无策时，Arthas可以帮助你解决： 这个类从哪个 jar 包加载的？为什么会报各种类相关的 Exception？ 我改的代码为什么没有执行到？难道是我没 commit？分支搞错了？ 遇到问题无法在线上 debug，难道只能通过加日志再重新发布吗？ 线上遇到某个用户的数据处理有问题，但线上同样无法 debug，线下无法重现！ 是否有一个全局视角来查看系统的运行状况？ 有什么办法可以监控到 JVM 的实时运行状态？ 怎么快速定位应用的热点，生成火焰图？ 怎样直接从 JVM 内查找某个类的实例？ Arthas 支持 JDK 6+，支持 Linux/Mac/Windows，采用命令行交互模式，同时提供丰富的 Tab 自动补全功能，进一步方便进行问题的定位和诊断。 ","date":"2019-10-05","objectID":"/posts/tech/tools/arthas/:1:1","tags":["arthas"],"title":"Arthas(阿尔萨斯)","uri":"/posts/tech/tools/arthas/"},{"categories":["tech"],"content":"一键安装 curl -L https://arthas.aliyun.com/install.sh | sh ","date":"2019-10-05","objectID":"/posts/tech/tools/arthas/:1:2","tags":["arthas"],"title":"Arthas(阿尔萨斯)","uri":"/posts/tech/tools/arthas/"},{"categories":["tech"],"content":"Arthas原理 如此强大的工具，究竟是如何做到的呢? 它通过 Instrument 机制和ASM字节码框架，干涉类的加载过程，动态注入字节码，搜集接口调用信息并反馈。 在JDK5之后提供的新特性JavaAgent(Java代理）, java.lang.instrument包支持以Java代理的形式监控或重新定义运行中的服务．可以让我们在不修改程序代码的前提下通过 Instrumentation API改变运行中的java程序. Instrumentation 是一个JVM接口，该接口提供了一组查看和操作Java类的方法，如修改类的字节码、向 classLoader 的classpath下加入jar文件等。开发者可以通过Java语言来操作和监控JVM内部的状态，进而实现Java程序的监控分析。 如Arthas的watch命令就是使用了 java.lang.instrument.Instrumentation#addTransformer(java.lang.instrument.ClassFileTransformer)来 动态增加字节码文件。 public interface Instrumentation{ } 在动态修改字节码文件中，用到了ASM框架，ASM是一个通用的Java字节码操作和分析框架。一般用来动态生成类或者增强既有类的功能。也就是既可以创建class文件，也可以修改class文件。 Arthas增强功能的核心是Enhancer和AdviceWeaver这两个类，对方法进行AOP织入，达到watch，trace等效果。 ","date":"2019-10-05","objectID":"/posts/tech/tools/arthas/:2:0","tags":["arthas"],"title":"Arthas(阿尔萨斯)","uri":"/posts/tech/tools/arthas/"},{"categories":["tech"],"content":"特性 ","date":"2019-10-05","objectID":"/posts/tech/tools/arthas/:3:0","tags":["arthas"],"title":"Arthas(阿尔萨斯)","uri":"/posts/tech/tools/arthas/"},{"categories":["tech"],"content":"后台异步任务，任务输出重定向 可通过 \u003e 或者 \u003e\u003e 将任务输出结果输出到指定的文件中，可以和\u0026一起使用，实现 arthas 命令的后台异步任务。 trace Test t » /Users/michael/tmp_del/test.out \u0026 ","date":"2019-10-05","objectID":"/posts/tech/tools/arthas/:3:1","tags":["arthas"],"title":"Arthas(阿尔萨斯)","uri":"/posts/tech/tools/arthas/"},{"categories":["tech"],"content":"批处理功能 通过批处理功能，arthas 支持一次性批量运行多个命令，并取得命令执行的结果。 ","date":"2019-10-05","objectID":"/posts/tech/tools/arthas/:3:2","tags":["arthas"],"title":"Arthas(阿尔萨斯)","uri":"/posts/tech/tools/arthas/"},{"categories":["tech"],"content":"常用命令 命令列表 ","date":"2019-10-05","objectID":"/posts/tech/tools/arthas/:4:0","tags":["arthas"],"title":"Arthas(阿尔萨斯)","uri":"/posts/tech/tools/arthas/"},{"categories":["tech"],"content":"线程查看 当没有参数时，显示第一页线程的信息 thread 支持一键展示当前最忙的前 N 个线程并打印堆栈： thread -n 3 thread id，显示指定线程的运行堆栈 thread 1 找出当前阻塞其他线程的线程 有时候我们发现应用卡住了，通常是由于某个线程拿佳了某个锁， 并且其他线程都在等待这把锁造成的。 为了排查这类问题，arthas 提供 thread -b 一键找出那个 罪魁祸首。 thread -b 查看指定状态的线程 thread –state WAITING ","date":"2019-10-05","objectID":"/posts/tech/tools/arthas/:4:1","tags":["arthas"],"title":"Arthas(阿尔萨斯)","uri":"/posts/tech/tools/arthas/"},{"categories":["tech"],"content":"watch（函数执行数据观测） 查看日志 $ watch demo.MathGame primeFactors -x 2 Press Q or Ctrl+C to abort. Affect(class count: 1 , method count: 1) cost in 32 ms, listenerId: 5 method=demo.MathGame.primeFactors location=AtExceptionExit ts=2021-08-31 15:22:57; [cost=0.220625ms] result=@ArrayList[ @Object[][ @Integer[-179173], ], @MathGame[ random=@Random[java.util.Random@31cefde0], illegalArgumentCount=@Integer[44], ], null, ] ","date":"2019-10-05","objectID":"/posts/tech/tools/arthas/:4:2","tags":["arthas"],"title":"Arthas(阿尔萨斯)","uri":"/posts/tech/tools/arthas/"},{"categories":["tech"],"content":"monitor（监控） monitor 方法执行监控 monitor com.xx.global.campaign.facade.impl.MerchantsSellerQueryFacadeImpl queryActivityListData -n 10 –cycle 10 $ monitor -c 5 demo.MathGame primeFactors Press Ctrl+C to abort. Affect(class-cnt:1 , method-cnt:1) cost in 94 ms. timestamp class method total success fail avg-rt(ms) fail-rate ----------------------------------------------------------------------------------------------- 2018-12-03 19:06:38 demo.MathGame primeFactors 5 1 4 1.15 80.00% timestamp class method total success fail avg-rt(ms) fail-rate ----------------------------------------------------------------------------------------------- 2018-12-03 19:06:43 demo.MathGame primeFactors 5 3 2 42.29 40.00% ","date":"2019-10-05","objectID":"/posts/tech/tools/arthas/:4:3","tags":["arthas"],"title":"Arthas(阿尔萨斯)","uri":"/posts/tech/tools/arthas/"},{"categories":["tech"],"content":"trace（耗时） trace 方法内部调用路径，并输出方法路径上的每个节点上耗时 trace com.xx.global.campaign.service.business.service.core.impl.ActivitySearchService queryAllCampaignList -n 5 –skipJDKMethod false $ trace demo.MathGame run -n 1 Press Q or Ctrl+C to abort. Affect(class-cnt:1 , method-cnt:1) cost in 20 ms. `---ts=2019-12-04 00:45:53;thread_name=main;id=1;is_daemon=false;priority=5;TCCL=sun.misc.Launcher$AppClassLoader@3d4eac69 `---[0.549379ms] demo.MathGame:run() +---[0.059839ms] demo.MathGame:primeFactors() #24 `---[0.232887ms] demo.MathGame:print() #25 ","date":"2019-10-05","objectID":"/posts/tech/tools/arthas/:4:4","tags":["arthas"],"title":"Arthas(阿尔萨斯)","uri":"/posts/tech/tools/arthas/"},{"categories":["tech"],"content":"指定 classloader 更新 logger level logger logger -c 2a139a55 –name ROOT –level debug ","date":"2019-10-05","objectID":"/posts/tech/tools/arthas/:4:5","tags":["arthas"],"title":"Arthas(阿尔萨斯)","uri":"/posts/tech/tools/arthas/"},{"categories":["tech"],"content":"查看所有的 option vmoption ","date":"2019-10-05","objectID":"/posts/tech/tools/arthas/:4:6","tags":["arthas"],"title":"Arthas(阿尔萨斯)","uri":"/posts/tech/tools/arthas/"},{"categories":["tech"],"content":"其他 Arthas Tunnel?? ","date":"2019-10-05","objectID":"/posts/tech/tools/arthas/:5:0","tags":["arthas"],"title":"Arthas(阿尔萨斯)","uri":"/posts/tech/tools/arthas/"},{"categories":["tech"],"content":"案例 实际案例 ","date":"2019-10-05","objectID":"/posts/tech/tools/arthas/:6:0","tags":["arthas"],"title":"Arthas(阿尔萨斯)","uri":"/posts/tech/tools/arthas/"},{"categories":["tech"],"content":"FAO ","date":"2019-10-05","objectID":"/posts/tech/tools/arthas/:7:0","tags":["arthas"],"title":"Arthas(阿尔萨斯)","uri":"/posts/tech/tools/arthas/"},{"categories":["tech"],"content":"怎么以json格式查看结果？ options json-format true ","date":"2019-10-05","objectID":"/posts/tech/tools/arthas/:7:1","tags":["arthas"],"title":"Arthas(阿尔萨斯)","uri":"/posts/tech/tools/arthas/"},{"categories":["Java","多线程"],"content":"Callable 和 Runnable的区别 ","date":"2019-09-18","objectID":"/posts/tech/java/callable/:1:0","tags":["多线程","并行处理"],"title":"Java 多线程并行处理","uri":"/posts/tech/java/callable/"},{"categories":["Java","多线程"],"content":"相同点 都是接口 都可以编写多线程程序 都采用Thread.start()启动线程 ","date":"2019-09-18","objectID":"/posts/tech/java/callable/:1:1","tags":["多线程","并行处理"],"title":"Java 多线程并行处理","uri":"/posts/tech/java/callable/"},{"categories":["Java","多线程"],"content":"不同点 Runnable没有返回值；Callable可以返回执行结果，是个泛型，和Future、FutureTask配合可以用来获取异步执行的结果; callable接口实现类中的run方法允许异常向上抛出，可以在内部处理，try catch，但是runnable接口实现类中run方法的异常必须在内部处理，不能抛出; 注：Callalble接口支持返回执行结果，需要调用FutureTask.get()得到，此方法会阻塞主进程的继续往下执行，如果不调用不会阻塞。 ","date":"2019-09-18","objectID":"/posts/tech/java/callable/:1:2","tags":["多线程","并行处理"],"title":"Java 多线程并行处理","uri":"/posts/tech/java/callable/"},{"categories":["Java","多线程"],"content":"Callable 样例 声明线程池； 创建任务； 任务执行； 等待任务执行完成； 解析任务执行结构； 关闭线程池； public class ExecutorPool { /*声明线程池*/ public static final ExecutorService EXECUTOR = new ThreadPoolExecutor( 4, 100, 0L, TimeUnit.SECONDS, new LinkedBlockingQueue\u003c\u003e(100), new ThreadFactoryBuilder().setNameFormat(\"customize-pool-%d\").build(), new ThreadPoolExecutor.CallerRunsPolicy()); } @Data @Builder public class ResultDTO { Integer id; boolean processResult; } @Data @Slf4j public class CampaignDemoTask implements Callable\u003cResultDTO\u003e { private Integer id; private CountDownLatch countDownLatch; public CampaignDemoTask(Integer id, CountDownLatch countDownLatch) { this.id = id; this.countDownLatch = countDownLatch; } @Override public ResultDTO call() throws Exception { try { log.info(\"CampaignTaskDemoThread process id={}\", this.id); //process... if (NumberUtils.INTEGER_ONE.equals(this.id)) { TimeUnit.SECONDS.sleep(5L); } else { TimeUnit.SECONDS.sleep(2L); } log.info(\"CampaignTaskDemoThread finish id={}\", this.id); } catch (InterruptedException e) { e.printStackTrace(); } finally { this.countDownLatch.countDown(); } return ResultDTO.builder().id(this.id).processResult(Boolean.TRUE).build(); } } @Slf4j public class CallableTest { public static void main(String[] args) { CallableTest callTest = new CallableTest(); callTest.run(); } public void run() { //总任务数 int total = 3; //线程任务结果集 List\u003cFuture\u003cResultDTO\u003e\u003e futureList = Lists.newArrayList(); //1. 组装线程任务 CountDownLatch countDownLatch = new CountDownLatch(total); for (int i = 0; i \u003c total; i++) { CampaignDemoTask campaignTaskDemoThread = new CampaignDemoTask(i, countDownLatch); //2. 线程池执行 Future\u003cResultDTO\u003e result = ExecutorPool.EXECUTOR.submit(campaignTaskDemoThread); futureList.add(result); } log.info(\"futureList={}\", JSON.toJSONString(futureList)); //3. 等待线程池任务执行完成 try { countDownLatch.await(); // 个别线程执行时间会很长，如果线程执行时间超过某段时间，自动结束该线程; 可使用下面方式 // countDownLatch.await(3L, TimeUnit.SECONDS); } catch (InterruptedException e) { e.printStackTrace(); } log.info(\"futureList={}\", JSON.toJSONString(futureList)); //3. 解析处理结果 futureList.forEach(t -\u003e { try { ResultDTO result = t.get(); log.info(\"result={}\", JSON.toJSONString(result)); } catch (InterruptedException e) { e.printStackTrace(); } catch (ExecutionException e) { e.printStackTrace(); } }); //4.线程池关闭 ExecutorPool.EXECUTOR.shutdown(); log.info(\"done!\"); } } ","date":"2019-09-18","objectID":"/posts/tech/java/callable/:1:3","tags":["多线程","并行处理"],"title":"Java 多线程并行处理","uri":"/posts/tech/java/callable/"},{"categories":["读书笔记"],"content":"语录 查理就是如此独特的人，他的独特性既表现在他的思想上，也表现在他的人格上。 比如说，查理思考问题总是从逆向开始。如果要明白人生如何得到幸福，查理首先是研究人生如何才能变得痛苦；要研究企业如何做强做大，查理首先研究企业是如何衰败的；大部分人更关心如何在股市投资上成功，查理最关心的是为什么在股市投资上大部分人都失败了。 他的这种思考方法来源于下面这句农夫谚语中所蕴含的哲理：我只想知道将来我会死在什么地方，这样我就就=不去那儿了。”这也是逆向思维的典型例子。 查理对理性有更苛刻的定义。正是这样的“理性”，让查理具有敏說独到的眼光和洞察力，即使对于完全陌生的领域，他也能一眼看到事物的本质。巴菲特就把查理的这个特点称作“两分钟效应”- 他说查理比世界上任何人更能在最短时间之内把一个复杂商业的本质说清楚。 芒格推崇的几个重要的投资原则： ● 逆向思维，凡事总是反过来想； ● 拥有良好的性格，毫不焦躁地持有看好的股票，并保持浓厚的兴趣去提高自己的能力； ● 在自己的“能力圈”中做投资，并不断拓展自己的能力圈； ● 等待好的投资机会出现，一旦出现，倾全力集中投资。 〝我这辈子遇到的聪明人（来自各行各业的聪明人）没有不每天阅读的没有，一个都没有。沃伦读书之多，我读书之多，可能会让你感到吃惊。我的孩子们都笑话我。他们觉得我是一本长了两条腿的书。” 查理论吸引客户：“关健是把手头的事情做好……把手头的事情做好。把已经拥有的客户照顾好，其他的自然会来找你。 查理有把事情彻底弄清楚的欲望。他遇事喜欢穷根究底，无论该事跟他有密切关系与否。任何引起他注意的事情，他都想对其有更多的认识，更多的了解，弄清楚那到底是怎么回事。 “多元思维模型” – “你必须知道重要学科的重要理论，并经常使用它们—-要全部都用上，而不是只用几种。大多数人都只使用学过的一个学科的思维模型，比如说经济学，试图用一种方法来解决所有问题。你知道谚语是怎么说的：“在手里拿着铁锤的人看来，世界就像一颗钉子。”这是处理问题的一种笨办法。 我们看很多书。我认识的聪明人没有不看很多书的。但光看书还不够：你必须拥有一种能够掌握思想和做合理事情的性格。大多数人无法掌握正确的思想，或者不知道该怎么应用它们。 求学之道无坦途，问艺之路无捷径。 -安东尼•特罗洛普 “五何”原则一一你必须说明何人因何故在何时何地做了何事。如果你在布劳恩公司里面写一封信或指示某人去做某事，但没有告诉他原因，那么你可能会被解雇。实际上，你只要犯两次这种错误，就会被解雇。 你们也许会问，这有那么重要吗？嗯，这也跟心理学的原理有关。如果你能够将一堆模式的知识组合起来，回答一个又一个为什么，你就能够更好地思考：同样道理，如果你告诉人们事情的时候，总是告诉他们原因，他们就能更深刻地理解你说的话，就会要加重视你说的话，也会更倾向于听从你说的话。就算他们不理解你的理由，他们也会更倾向于听你的语。 正如你想要从问一个又一个的“为什么”开始获得普世的智慧一样，你在跟别人交流沟通时，也应该把原因讲清楚。就算答案很浅显，你把“为什么”讲清仍是一种明智的做法。 我什么都读：企业年报、10-K报表、10-Q报表、传记、历史书，每天还要读五份报纸。在飞机上，我会阅读座椅后背的安全指南。阅读是很重要的。这么多年来，是阅读让我致富。 遇到好机会，就全力出击。就是这么简单。 你必须有浓厚的兴趣去弄明白正在发生的事情背后的原因。如果你能够长期保持这种心态，你关注现实的能力将会逐渐得到提高。如果你没有这种心态，那么即使你有很高的智商，也注定会失败。 你若想在任何领域拥有竞争力，就必须熟练地掌握该领域的方方面面，不管你是否喜欢这么做，这是人类大脑的深层结构决定的。 我发现，如果一个人的全部信息都局限于他的工作领域，那么他的工作不会做得很好。一个人必须有眼光，他可以从书籍上或者人们身上--最好是两者兼有--培养眼光。 如果你在生活中惟一的成功就是通过买股票发财，那么这是一种失败的生活。生活不仅仅是精明地积累财富。 生活和生意上的大多数成功来自你知道应该避免哪些事情：过早死亡、糟糕的婚姻等等， 避免染上艾滋病、在路口和火车抢道以及吸毒培养良好的心理习惯。避免邪悉之人，尤其是那些性感诱人的异性。如果因为你的特立油行而在周围人中不受欢迎……那你就随他们去吧。 如何致富 许多年轻的生意人都问我们这个问题。这是一个聪明的问题：你看见某个有钱的老头，然后问他：“我要怎样才能变得像你一样呢？” 每天起床的时候，争取变得比你从前更聪明一点。认真地、出色地完成你的任务。慢慢地，做会有所进步，但这种进步不一定很快。但你这样能够为快速进步打好基础………每天慢慢向前挪一点。到最后（如果你足够长寿的话）大老数人得到了他们应得的东西。 ","date":"2019-07-29","objectID":"/posts/book/poor_charlie_book/:1:0","tags":["理财"],"title":"[读书笔记] 《穷查理宝典》","uri":"/posts/book/poor_charlie_book/"},{"categories":["读书笔记"],"content":"格言 一切重要的图书都应该立即重读。-叔本华 求学之道无坦途，问艺之路无捷径。 -安东尼•特罗洛普 ","date":"2019-07-29","objectID":"/posts/book/poor_charlie_book/:2:0","tags":["理财"],"title":"[读书笔记] 《穷查理宝典》","uri":"/posts/book/poor_charlie_book/"},{"categories":["读书笔记"],"content":"小结 人类误判心理学 聪明人为什么会犯错？答案是：人们倾向于积累大量僵化的结论和态度，而且不去经常检讨，更不愿做改变。芒格亲笔阐述 25 种人类误判的心理倾向。 画定你的能力圈 你必须弄清楚自己有什么本领。如果玩那些别人玩得很好自己却一窍不通的游戏，那么你注定一败涂地。要认清自己的优势，只在能力圈里竞争。 如何让自己生活幸福 只要懂得妒忌、怨恨、反覆无常、意志消沉、不屑客观、不从其他人的经验学习，保证可以轻松拥有悲惨的一生。想要幸福？反其道而行之就可以了。 掌握多学科视角成为赢家 在手里拿着一把锤子的人眼中，世界就像一根钉子。大多数人试图以一种思维模型来解决所有问题，而其思维往往只来自某一专业学科。但你必须要知道各种重要学科的重要理论，才能洞察问题本质。 没有必定赚钱公式 在98% 的时问里，我们对股市的态度是：保持不可知状态。赚钱，靠的是记住浅显的，而不是掌握深奥的。伯克希尔只寻找那些不用动脑筋也能赚钱的机会。 耐心等待一记好球 只要以耐心、纪律和客观为指导原则，你可以将90% 的财富都投到一家伟大的公司。不需要频繁的买卖，只要几次决定便能造就投资财富。芒格的这一特点，彻底改变了巴菲特的投资策略。 ","date":"2019-07-29","objectID":"/posts/book/poor_charlie_book/:3:0","tags":["理财"],"title":"[读书笔记] 《穷查理宝典》","uri":"/posts/book/poor_charlie_book/"},{"categories":["Tech"],"content":"具体的解决方案如下： 苹果-\u003e系统偏好设置-\u003e最下边点mysql 在弹出页面中 关闭mysql服务（点击stop mysql server） 进入终端输入：cd /usr/local/mysql/bin/ 回车后 登录管理员权限 sudo su 输入mac的管理员密码 回车后输入以下命令来禁止mysql验证功能 ./mysqld_safe –skip-grant-tables \u0026 回车后mysql会自动重启（偏好设置中mysql的状态会变成running） 输入命令 ./mysql 输入命令 FLUSH PRIVILEGES; 输入命令 SET PASSWORD FOR ‘root’@’localhost’ = PASSWORD(‘你的新密码’); 至此，密码已经修改成功，可以登录啦！ ","date":"2019-06-16","objectID":"/posts/tech/setup/mac-reset-mysql-pwd/:0:0","tags":["install","mysql"],"title":"Mac下Mysql重置密码","uri":"/posts/tech/setup/mac-reset-mysql-pwd/"},{"categories":["Java","多线程"],"content":" 并发: 一个处理器同时处理多个任务。有效解决了单CPU下的多任务问题； 并行: 多个处理器或者是多核的处理器同时处理多个不同的任务.[ 能够并行执行任务的基础就是多核CPU ] 前者是逻辑上的同时发生（simultaneous），而后者是物理上的同时发生． 并发性(concurrency)，又称共行性，是指能处理多个同时性活动的能力，并发事件之间不一定要同一时刻发生。 并行(parallelism)是指同时发生的两个并发事件，具有并发的含义，而并发则不一定并行。 来个比喻： 并发：1个人1张嘴同时吃3个馒头 并行：3个人3张口，每人各吃n个馒头 并发与并行的区别 下图反映了一个包含8个操作的任务在一个有两核心的CPU中创建四个线程运行的情况。 假设每个核心有两个线程，那么每个CPU中两个线程会交替并发，两个CPU之间的操作会并行运算。 单就一个CPU而言两个线程可以解决线程阻塞造成的不流畅问题，其本身运行效率并没有提高； 多CPU的并行运算才真正解决了运行效率问题，这也正是并发和并行的区别。 双核四线程运行示意图 ","date":"2019-05-25","objectID":"/posts/tech/java/concurrencyparall/:0:0","tags":["并行\u0026\u0026并发"],"title":"并行\u0026\u0026并发","uri":"/posts/tech/java/concurrencyparall/"},{"categories":["Java","多线程"],"content":"Refer 参考 ","date":"2019-05-25","objectID":"/posts/tech/java/concurrencyparall/:1:0","tags":["并行\u0026\u0026并发"],"title":"并行\u0026\u0026并发","uri":"/posts/tech/java/concurrencyparall/"},{"categories":["Java"],"content":"Java基础概括 ","date":"2019-03-19","objectID":"/posts/tech/java/java-learning/:1:0","tags":["Java"],"title":"Java随笔","uri":"/posts/tech/java/java-learning/"},{"categories":["Java"],"content":"大图 ","date":"2019-03-19","objectID":"/posts/tech/java/java-learning/:1:1","tags":["Java"],"title":"Java随笔","uri":"/posts/tech/java/java-learning/"},{"categories":["Java"],"content":"Java ","date":"2019-03-19","objectID":"/posts/tech/java/java-learning/:1:2","tags":["Java"],"title":"Java随笔","uri":"/posts/tech/java/java-learning/"},{"categories":["Java"],"content":"设计模式 \u0026\u0026 算法 ","date":"2019-03-19","objectID":"/posts/tech/java/java-learning/:1:3","tags":["Java"],"title":"Java随笔","uri":"/posts/tech/java/java-learning/"},{"categories":["Java"],"content":"框架 \u0026\u0026 spring ","date":"2019-03-19","objectID":"/posts/tech/java/java-learning/:1:4","tags":["Java"],"title":"Java随笔","uri":"/posts/tech/java/java-learning/"},{"categories":["Java"],"content":"中间件 \u0026\u0026 其他 ","date":"2019-03-19","objectID":"/posts/tech/java/java-learning/:1:5","tags":["Java"],"title":"Java随笔","uri":"/posts/tech/java/java-learning/"},{"categories":["Java"],"content":"Java ","date":"2019-03-19","objectID":"/posts/tech/java/java-learning/:2:0","tags":["Java"],"title":"Java随笔","uri":"/posts/tech/java/java-learning/"},{"categories":["Java"],"content":"Document Oracle Java tutorial ","date":"2019-03-19","objectID":"/posts/tech/java/java-learning/:2:1","tags":["Java"],"title":"Java随笔","uri":"/posts/tech/java/java-learning/"},{"categories":["Java"],"content":"List public class ArrayList\u003cE\u003e extends AbstractList\u003cE\u003e implements List\u003cE\u003e, RandomAccess, Cloneable, java.io.Serializable{} public class LinkedList\u003cE\u003e extends AbstractSequentialList\u003cE\u003e implements List\u003cE\u003e, Deque\u003cE\u003e, Cloneable, java.io.Serializable{} public class CopyOnWriteArrayList\u003cE\u003e implements List\u003cE\u003e, RandomAccess, Cloneable, java.io.Serializable {} List list = Collections.synchronizedList(new ArrayList(...)); ","date":"2019-03-19","objectID":"/posts/tech/java/java-learning/:2:2","tags":["Java"],"title":"Java随笔","uri":"/posts/tech/java/java-learning/"},{"categories":["Java"],"content":"Java equals() and hashCode() refer Java HashMap equals() Object class defined equals() method like this: public boolean equals(Object obj) { return (this == obj); } According to java documentation of equals() method, any implementation should adhere to following principles. For any object x, x.equals(x) should return true. For any two object x and y, x.equals(y) should return true if and only if y.equals(x) returns true. For multiple objects x, y, and z, if x.equals(y) returns true and y.equals(z) returns true, then x.equals(z) should return true. Multiple invocations of x.equals(y) should return same result, unless any of the object properties is modified that is being used in the equals() method implementation. Object class equals() method implementation returns true only when both the references are pointing to same object. hashCode() Java Object hashCode() is a native method and returns the integer hash code value of the object. The general contract of hashCode() method is: Multiple invocations of hashCode() should return the same integer value, unless the object property is modified that is being used in the equals() method. An object hash code value can change in multiple executions of the same application. If two objects are equal according to equals() method, then their hash code must be same. If two objects are unequal according to equals() method, their hash code are not required to be different. Their hash code value may or may-not be equal. Importance of equals() and hashCode() method Java hashCode() and equals() method are used in Hash table based implementations in java for storing and retrieving data. I have explained it in detail at How HashMap works in java? The implementation of equals() and hashCode() should follow these rules. If o1.equals(o2), then o1.hashCode() == o2.hashCode() should always be true. If o1.hashCode() == o2.hashCode is true, it doesn’t mean that o1.equals(o2) will be true. When to override equals() and hashCode() methods? When we override equals() method, it’s almost necessary to override the hashCode() method too so that their contract is not violated by our implementation. Note that your program will not throw any exceptions if the equals() and hashCode() contract is violated, if you are not planning to use the class as Hash table key, then it will not create any problem. If you are planning to use a class as Hash table key, then it’s must to override both equals() and hashCode() methods. Let’s see what happens when we rely on default implementation of equals() and hashCode() methods and use a custom class as HashMap key. public class DataKey { private String name; private int id; // getter and setter methods @Override public String toString() { return \"DataKey [name=\" + name + \", id=\" + id + \"]\"; } } public class HashingTest { public static void main(String[] args) { Map\u003cDataKey, Integer\u003e hm = getAllData(); DataKey dk = new DataKey(); dk.setId(1); dk.setName(\"Pankaj\"); log.info(\"{}\", dk.hashCode()); Integer value = hm.get(dk); log.info(\"{}\", value); } private static Map\u003cDataKey, Integer\u003e getAllData() { Map\u003cDataKey, Integer\u003e hm = new HashMap\u003c\u003e(); DataKey dk = new DataKey(); dk.setId(1); dk.setName(\"Pankaj\"); log.info(\"{}\", dk.hashCode()); hm.put(dk, 10); return hm; } } When we run above program, it will print null. It’s because Object hashCode() method is used to find the bucket to look for the key. Since we don’t have access to the HashMap keys and we are creating the key again to retrieve the data, you will notice that hash code values of both the objects are different and hence value is not found. We can also use Project Lombok to auto generate equals and hashCode method implementations. import lombok.Data; @Data public class DataKey { private String name; private int id; @Override public String toString() { return \"DataKey [name=\" + name + \", id=\" + id + \"]\"; } } What is Hash Collision ?? In very simple terms, Java Hash table implementations uses following logic for get and put opera","date":"2019-03-19","objectID":"/posts/tech/java/java-learning/:2:3","tags":["Java"],"title":"Java随笔","uri":"/posts/tech/java/java-learning/"},{"categories":["Java"],"content":"Project Lombok refer ","date":"2019-03-19","objectID":"/posts/tech/java/java-learning/:2:4","tags":["Java"],"title":"Java随笔","uri":"/posts/tech/java/java-learning/"},{"categories":["Java"],"content":"Serialization and Deserialization Serialization is the conversion of the state of an object into a byte stream;deserialization does the opposite. Stated differently, serialization is the conversion of a Java object into a static stream (sequence) of bytes, which we can then save to a database or transfer over a network. When should I implement Serializable interface? implement the Serializable interface when you need to store a copy of the object, send them to another process which runs on the same system or over the network. Why do we do that? Because you want to store or send an object. Does it give any advantages or security? It makes storing and sending objects easy. It has nothing to do with security. What to do instead Instead, use a serialization scheme that you can explicitly control. Such as Protocol Buffers, JSON, XML, or your own custom scheme. refer refer2 ","date":"2019-03-19","objectID":"/posts/tech/java/java-learning/:2:5","tags":["Java"],"title":"Java随笔","uri":"/posts/tech/java/java-learning/"},{"categories":["Java"],"content":"Java 泛型（generics） Java Genrics is one of the most important features introduced in Java 5. What does the syntax mean in Java? Here \u003cE\u003e denotes the type parameter of Node class .The type parameter defines that it can refer to any type (like String, Integer, Employee etc.). Java generics have type parameter naming conventions like following: Java Generic Type Naming convention helps us understanding code easily and having a naming convention is one of the best practices of Java programming language. So generics also comes with its own naming conventions. Usually, type parameter names are single, uppercase letters to make it easily distinguishable from java variables. The most commonly used type parameter names are: E - Element (used extensively by the Java Collections Framework, for example ArrayList, Set etc.) K - Key (Used in Map) N - Number T - Type V - Value (Used in Map) S,U,V etc. - 2nd, 3rd, 4th types ？- 通配符泛型 For example take the following scenerio public class Node\u003cE\u003e{ E elem; Node\u003cE\u003e next, previous; } class Test{ Node\u003cString\u003e obj = new Node\u003c\u003e(); } You can use generics with Interface,method and constructor too. For more about generics visit these: https://www.javatpoint.com/generics-in-java Generics in Java Generics was added in Java 5 to provide compile-time type checking and removing risk of ClassCastException that was common while working with collection classes. The whole collection framework was re-written to use generics for type-safety. Let’s see how generics help us using collection classes safely. List list = new ArrayList(); list.add(\"abc\"); list.add(new Integer(5)); //OK for(Object obj : list){ //type casting leading to ClassCastException at runtime String str=(String) obj; } Above code compiles fine but throws ClassCastException at runtime because we are trying to cast Object in the list to String whereas one of the element is of type Integer. After Java 5, we use collection classes like below. List\u003cString\u003e list1 = new ArrayList\u003cString\u003e(); // java 7 ? List\u003cString\u003e list1 = new ArrayList\u003c\u003e(); list1.add(\"abc\"); //list1.add(new Integer(5)); //compiler error for(String str : list1){ //no type casting needed, avoids ClassCastException } Notice that at the time of list creation, we have specified that the type of elements in the list will be String. So if we try to add any other type of object in the list, the program will throw compile-time error. Also notice that in for loop, we don’t need typecasting of the element in the list, hence removing the ClassCastException at runtime. https://www.journaldev.com/1663/java-generics-example-method-class-interface Why do we use Generics in Java? Generics provide strong compile-time type checking and reduces risk of ClassCastException and explicit casting of objects. What is T in Generics? We use to create a generic class, interface, and method. The T is replaced with the actual type when we use it. How does Generics work in Java? Generic code ensures type safety. The compiler uses type-erasure to remove all type parameters at the compile time to reduce the overload at runtime. refer reter 2 泛型通配符 ","date":"2019-03-19","objectID":"/posts/tech/java/java-learning/:2:6","tags":["Java"],"title":"Java随笔","uri":"/posts/tech/java/java-learning/"},{"categories":["Java"],"content":"Java Reflection refer Reflection in Java is a very powerful concept and it’s of little use in normal programming but it’s the backbone for most of the Java, J2EE frameworks. Some of the frameworks that use java reflection are: JUnit - uses reflection to parse @Test annotation to get the test methods and then invoke it. Spring - dependency injection, read more at Spring Dependency Injection Tomcat web container to forward the request to correct module by parsing their web.xml files and request URI. The list is endless and they all use java reflection because all these frameworks have no knowledge and access of user defined classes, interfaces, their methods etc. We should not use reflection in normal programming where we already have access to the classes and interfaces because of following drawbacks. Poor Performance - Since java reflection resolve the types dynamically, it involves processing like scanning the classpath to find the class to load, causing slow performance. Security Restrictions - Reflection requires runtime permissions that might not be available for system running under security manager. This can cause you application to fail at runtime because of security manager. Security Issues - Using reflection we can access part of code that we are not supposed to access, for example we can access private fields of a class and change it’s value. This can be a serious security threat and cause your application to behave abnormally. High Maintenance - Reflection code is hard to understand and debug, also any issues with the code can’t be found at compile time because the classes might not be available, making it less flexible and hard to maintain. ","date":"2019-03-19","objectID":"/posts/tech/java/java-learning/:2:7","tags":["Java"],"title":"Java随笔","uri":"/posts/tech/java/java-learning/"},{"categories":["Java"],"content":"Java Annotations refer Java 1.5 introduced annotations and now it’s heavily used in Java EE frameworks like Hibernate, Jersey, and Spring. Java Annotation is metadata about the program embedded in the program itself. It can be parsed by the annotation parsing tool or by the compiler. We can also specify annotation availability to either compile time only or till runtime. import java.lang.annotation.Documented; import java.lang.annotation.ElementType; import java.lang.annotation.Inherited; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; import java.lang.annotation.Target; @Documented @Target(ElementType.METHOD) @Inherited @Retention(RetentionPolicy.RUNTIME) public @interface MethodInfo{ String author() default \"Pankaj\"; String date(); int revision() default 1; String comments(); } Meta annotations in java There are five types of meta annotations: @Documented indicates that elements using this annotation should be documented by javadoc and similar tools. This type should be used to annotate the declarations of types whose annotations affect the use of annotated elements by their clients. If a type declaration is annotated with Documented, its annotations become part of the public API of the annotated elements. @Target indicates the kinds of program element to which an annotation type is applicable. Some possible values are TYPE, METHOD, CONSTRUCTOR, FIELD etc. If Target meta-annotation is not present, then annotation can be used on any program element. @Inherited indicates that an annotation type is automatically inherited. If user queries the annotation type on a class declaration, and the class declaration has no annotation for this type, then the class’s superclass will automatically be queried for the annotation type. This process will be repeated until an annotation for this type is found, or the top of the class hierarchy (Object) is reached. @Retention indicates how long annotations with the annotated type are to be retained. It takes RetentionPolicy argument whose Possible values are SOURCE, CLASS and RUNTIME @Repeatable used to indicate that the annotation type whose declaration it annotates is repeatable. Java Annotations Example Let’s see a java example showing the use of built-in annotations in java as well as the use of custom annotation created by us in the above example. import java.io.FileNotFoundException; import java.util.ArrayList; import java.util.List; public class AnnotationExample { public static void main(String[] args) { } @Override @MethodInfo(author = \"Pankaj\", comments = \"Main method\", date = \"Nov 17 2012\", revision = 1) public String toString() { return \"Overriden toString method\"; } @Deprecated @MethodInfo(comments = \"deprecated method\", date = \"Nov 17 2012\") public static void oldMethod() { System.out.println(\"old method, don't use it.\"); } @SuppressWarnings({ \"unchecked\", \"deprecation\" }) @MethodInfo(author = \"Pankaj\", comments = \"Main method\", date = \"Nov 17 2012\", revision = 10) public static void genericsTest() throws FileNotFoundException { List l = new ArrayList(); l.add(\"abc\"); oldMethod(); } } I believe above java annotation example is self-explanatory and showing the use of annotations in different cases. Java Annotations Parsing We will use Reflection to parse java annotations from a class. Please note that Annotation Retention Policy should be RUNTIME otherwise its information will not be available at runtime and we won’t be able to fetch any data from it. import java.lang.annotation.Annotation; import java.lang.reflect.Method; public class AnnotationParsing { public static void main(String[] args) { try { for (Method method : AnnotationParsing.class.getClassLoader() .loadClass((\"com.michael.annotations.AnnotationExample\")).getMethods()) { // checks if MethodInfo annotation is present for the method if (method.isAnnotationPresent(com.michael.annotations.MethodInfo.class)) { try { // iterates all the annotations available in the method for (Annotation a","date":"2019-03-19","objectID":"/posts/tech/java/java-learning/:2:8","tags":["Java"],"title":"Java随笔","uri":"/posts/tech/java/java-learning/"},{"categories":["Java"],"content":"Map ","date":"2019-03-19","objectID":"/posts/tech/java/java-learning/:2:9","tags":["Java"],"title":"Java随笔","uri":"/posts/tech/java/java-learning/"},{"categories":["Java"],"content":"HashMap refer Java HashMap is one of the most popular Collection classes in java. Java HashMap is Hash table based implementation. HashMap in java extends AbstractMap class that implements Map interface. public class HashMap\u003cK,V\u003e extends AbstractMap\u003cK,V\u003e implements Map\u003cK,V\u003e, Cloneable, Serializable {} Some of the important points about HashMap in Java are; Java HashMap allows null key and null values. HashMap is not an ordered collection. You can iterate over HashMap entries through keys set but they are not guaranteed to be in the order of their addition to the HashMap. HashMap is almost similar to Hashtable except that it’s unsynchronized and allows null key and values. HashMap uses it’s inner class Node\u003cK,V\u003e for storing map entries. HashMap stores entries into multiple singly linked lists, called buckets or bins. Default number of bins is 16 and it’s always power of 2. HashMap uses hashCode() and equals() methods on keys for get and put operations. So HashMap key object should provide good implementation of these methods. This is the reason immutable classes are better suitable for keys, for example String and Interger. Java HashMap is not thread safe, for multithreaded environment you should use ConcurrentHashMap class or get synchronized map using Collections.synchronizedMap() method. Java HashMap Constructors Java HashMap provides four constructors. public HashMap(): Most commonly used HashMap constructor. This constructor will create an empty HashMap with default initial capacity 16 and load factor 0.75 public HashMap(int initialCapacity): This HashMap constructor is used to specify the initial capacity and 0.75 load factor. This is useful in avoiding rehashing if you know the number of mappings to be stored in the HashMap. public HashMap(int initialCapacity, float loadFactor): This HashMap constructor will create an empty HashMap with specified initial capacity and load factor. You can use this if you know the maximum number of mappings to be stored in HashMap. In common scenarios you should avoid this because load factor 0.75 offers a good tradeoff between space and time cost. public HashMap(Map\u003c? extends K, ? extends V\u003e m): Creates a Map having same mappings as the specified map and with load factor 0.75 How HashMap works in java? HashMap in java use it’s inner class Node\u003cK,V\u003e for storing mappings. HashMap works on hashing algorithm and uses hashCode() and equals() method on key for get and put operations. HashMap use singly linked list to store elements, these are called bins or buckets. When we call put method, hashCode of key is used to determine the bucket that will be used to store the mapping. Once bucket is identified, hashCode is used to check if there is already a key with same hashCode or not. If there is an existing key with same hashCode, then equals() method is used on key. If equals returns true, then value is overwritten, otherwise a new mapping is made to this singly linked list bucket. If there is no key with same hashCode then mapping is inserted into the bucket. For HashMap get operation, again key hashCode is used to determine the bucket to look for the value. After bucket is identified, entries are traversed to find out the Entry using hashCode and equals method. If match is found, value is returned otherwise null is returned. There are much more things involved such as hashing algorithm to get the bucket for the key, rehashing of mappings etc. But for our working, just remember that HashMap operations work on Key and good implementation of hashCode and equals method is required to avoid unwanted behaviour. Below image shows the explanation of get and put operations. ","date":"2019-03-19","objectID":"/posts/tech/java/java-learning/:2:10","tags":["Java"],"title":"Java随笔","uri":"/posts/tech/java/java-learning/"},{"categories":["Java"],"content":"java移位运算 左乘、右除 左移1位相当于乘以2的1次方，左移n位就相当于乘以 2的n次方。 右移1位相当于除以2的1次方，右移n位就相当于除以 2的n次方。 demo 10 \u003c\u003c 1 = 10 * 2 = 20 10 \u003c\u003c 3 = 10 * (2 * 2 * 2) = 80 6 \u003e\u003e 1 = 6/2 = 3 6 \u003e\u003e 2 = 6/(2 * 2) = 1 6 \u003e\u003e 3 = 6/(2 * 2 * 2) = 0 ","date":"2019-03-19","objectID":"/posts/tech/java/java-learning/:2:11","tags":["Java"],"title":"Java随笔","uri":"/posts/tech/java/java-learning/"},{"categories":["Java"],"content":"JVM ","date":"2019-03-19","objectID":"/posts/tech/java/java-learning/:3:0","tags":["Java"],"title":"Java随笔","uri":"/posts/tech/java/java-learning/"},{"categories":["Java"],"content":"图例 JVM ","date":"2019-03-19","objectID":"/posts/tech/java/java-learning/:3:1","tags":["Java"],"title":"Java随笔","uri":"/posts/tech/java/java-learning/"},{"categories":["Java"],"content":"todo ","date":"2019-03-19","objectID":"/posts/tech/java/java-learning/:4:0","tags":["Java"],"title":"Java随笔","uri":"/posts/tech/java/java-learning/"},{"categories":["Java"],"content":"java 链表 java ListNode 链表 ","date":"2019-03-19","objectID":"/posts/tech/java/java-learning/:4:1","tags":["Java"],"title":"Java随笔","uri":"/posts/tech/java/java-learning/"},{"categories":["Tech"],"content":"版本控制 : 集中式 vs 分布式 ","date":"2018-10-11","objectID":"/posts/tech/tools/git/:1:0","tags":["git"],"title":"Git小结","uri":"/posts/tech/tools/git/"},{"categories":["Tech"],"content":"集中式版本控制（csv、svn） 集中式版本控制系统，版本库是集中存放在中央服务器的，而干活的时候，用的都是自己的电脑，所以要先从中央服务器取得最新的版本，然后开始干活，干完活了，再把自己的活推送给中央服务器。中央服务器就好比是一个图书馆，你要改一本书，必须先从图书馆借出来，然后回到家自己改，改完了，再放回图书馆。 缺点 集中式版本控制系统最大的毛病就是必须联网才能工作； 集中式版本控制系统的中央服务器要是出了问题，所有人都没法干活了。 ","date":"2018-10-11","objectID":"/posts/tech/tools/git/:1:1","tags":["git"],"title":"Git小结","uri":"/posts/tech/tools/git/"},{"categories":["Tech"],"content":"分布式版本控制（git） 分布式版本控制系统根本没有“中央服务器”，每个人的电脑上都是一个完整的版本库，这样，你工作的时候，就不需要联网了，因为版本库就在你自己的电脑上. 优点 不需要联网，也可以工作； 安全性要高很多，因为每个人电脑里都有完整的版本库，某一个人的电脑坏掉了不要紧，随便从其他人那里复制一个就可以了。 ","date":"2018-10-11","objectID":"/posts/tech/tools/git/:1:2","tags":["git"],"title":"Git小结","uri":"/posts/tech/tools/git/"},{"categories":["Tech"],"content":"Git安装\u0026\u0026配置 ","date":"2018-10-11","objectID":"/posts/tech/tools/git/:2:0","tags":["git"],"title":"Git小结","uri":"/posts/tech/tools/git/"},{"categories":["Tech"],"content":"yum安装(Linux) 在Linux上是有yum安装Git，非常简单，只需要一行命令 yum -y install git 输入 git version 查看Git是否安装完成以及查看其版本号 备注： yum安装git被安装在 /usr/libexec/git-core 目录下 ","date":"2018-10-11","objectID":"/posts/tech/tools/git/:2:1","tags":["git"],"title":"Git小结","uri":"/posts/tech/tools/git/"},{"categories":["Tech"],"content":"Git初始化配置 a、设置用户名： git config --global user.name \"\u003c用户名\u003e\" b、设置用户邮箱： git config --global user.email \"\u003c电子邮件\u003e\" 注意：该配置会在github主页上显示谁提交了该文件 c、配置ok之后，我们用如下命令来看看是否配置成功 git config --list 注意：git config --global 参数，有了这个参数表示你这台机器上所有的git仓库都会使用这个配置，当然你也可以对某个仓库指定不同的用户名和邮箱 ","date":"2018-10-11","objectID":"/posts/tech/tools/git/:2:2","tags":["git"],"title":"Git小结","uri":"/posts/tech/tools/git/"},{"categories":["Tech"],"content":"Git 配置SSH git使用SSH，需要以下三个步骤: 使用秘钥生成工具生成rsa秘钥和公钥 将rsa公钥添加到git代码托管平台 将rsa秘钥添加到ssh-agent中，为ssh client指定使用的秘钥文件 第一步：检查本地主机是否已经存在ssh key cd ~/.ssh ls //看是否存在 id_rsa 和 id_rsa.pub文件，如果存在，说明已经有SSH Key 第二步：生成ssh key 如果不存在ssh key，使用如下命令生成 ssh-keygen -t rsa -C \"xxx@xxx.com\" //执行后一直回车即可 第三步：获取ssh key公钥内容（id_rsa.pub） cd ~/.ssh cat id_rsa.pub 第四步：Github账号上添加公钥 进入Settings设置 第五步：验证是否设置成功 ssh -T git@github.com ","date":"2018-10-11","objectID":"/posts/tech/tools/git/:2:3","tags":["git"],"title":"Git小结","uri":"/posts/tech/tools/git/"},{"categories":["Tech"],"content":"Git使用 ","date":"2018-10-11","objectID":"/posts/tech/tools/git/:3:0","tags":["git"],"title":"Git小结","uri":"/posts/tech/tools/git/"},{"categories":["Tech"],"content":"命令流程图 远程仓库-本地仓库-工作区 本地仓库-工作区 ","date":"2018-10-11","objectID":"/posts/tech/tools/git/:3:1","tags":["git"],"title":"Git小结","uri":"/posts/tech/tools/git/"},{"categories":["Tech"],"content":"git help 要想获得 git config 命令的手册，执行 git help add 如果你不需要全面的手册，只需要可用选项的快速参考，那么可以用 -h 选项获得更简明的 “help” 输出： git add -h ","date":"2018-10-11","objectID":"/posts/tech/tools/git/:3:2","tags":["git"],"title":"Git小结","uri":"/posts/tech/tools/git/"},{"categories":["Tech"],"content":"常规git操作Demo 你应该能够置并初始化一个仓库（repository）、开始或停止跟踪（track）文件、暂存（stage）或提交（commit）更改. 1.进入目标文件夹 cd demo 2.初始化仓库 git init 3.仓库中创建 readme.txt文件，文本内容：test 4.查看仓库状态 git status 请记住，你工作目录下的每一个文件都不外乎这两种状态：已跟踪 或 未跟踪。 5.添加文件到暂存区中 git add readme.txt 6.提交文件到仓库 git commit -m \"readme.txt提交\" 7.查看仓库状态 git status 8.提交到远程库 git push 9.本地修改 readme.txt 文件后可以使用diff查看文件修改前后对比 git diff readme.txt 10.查看最近到最远的历史提交日志 git log [不传入任何参数的默认情况下，git log 会按时间先后顺序列出所有的提交，最近的更新排在最上面。 正如你所看到的，这个命令会列出每个提交的 SHA-1 校验和、作者的名字和电子邮件地址、提交时间以及提交说明。] 11.回退版本 git reset --hard 版本号 ","date":"2018-10-11","objectID":"/posts/tech/tools/git/:3:3","tags":["git"],"title":"Git小结","uri":"/posts/tech/tools/git/"},{"categories":["Tech"],"content":"Git常用基本命令 mkdir XX (创建一个空目录 XX指目录名) git init 把当前的目录变成可以管理的git仓库，生成隐藏.git文件 pwd 显示当前目录的路径 cat XX 查看XX文件内容 git add XX 把xx文件添加到暂存区去 git commit –m “XX” 提交文件到本地仓库 –m 后面的是注释 git push –u(第一次要用-u 以后不需要) origin master 把当前master分支推送到远程库 git push origin master Git会把master分支推送到远程库对应的远程分支上 git push origin --delete serverfix 删除远程分支 git status 查看仓库状态 git diff XX 查看XX文件修改了那些内容 git log 查看历史记录 git reflog 查看历史记录的版本号id git reset --hard HEAD^ 回退到上一个版本 git reset --hard HEAD~ 回退到上一个版本 git reset –-hard HEAD~100 (回退到100个版本) git checkout -- XX 把XX文件在工作区的修改全部撤销 git rm XX 删除XX文件 git remote 查看远程库的信息 git remote –v 查看远程库的详细信息 git remote add origin https://github.com/tugenhua0707/testgit 关联一个远程库 git fetch 从远程仓库中抓取与拉取 git clone https://github.com/tugenhua0707/testgit 从远程库中克隆 git checkout –b dev 创建dev分支 并切换到dev分支上； 等同于两条命令的: git branch dev; git checkout dev; git checkout master 切换到master分支 git branch 查看当前所有的分支[查看当前所有分支的一个列表] git branch -v 查看每一个分支的最后一次提交 git branch –d bug_fix 删除bug_fix分支 git branch \u003cname\u003e 创建新分支 git branch --no-merged master 尚未合并到 master 分支列表 git merge dev 在当前的分支上合并dev分支 git stash 把当前的工作隐藏起来 等以后恢复现场后继续工作 git stash list 查看所有被隐藏的文件列表 git stash apply 恢复被隐藏的文件，但是内容不删除 git stash drop 删除文件 git stash pop 恢复文件的同时 也删除文件 ","date":"2018-10-11","objectID":"/posts/tech/tools/git/:4:0","tags":["git"],"title":"Git小结","uri":"/posts/tech/tools/git/"},{"categories":["Tech"],"content":"tmp 初始化一个Git仓库，使用: git init 添加文件到Git仓库，分两步： 使用命令: git add \u003cfile\u003e 注意，可反复多次使用，添加多个文件； 使用命令: git commit -m \u003cmessage\u003e 要随时掌握工作区的状态，使用命令: git status 请记住，你工作目录下的每一个文件都不外乎这两种状态：已跟踪 或 未跟踪。 如果git status告诉你有文件被修改过, 则用 git diff可以查看修改内容: git diff readme.txt HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令： git reset --hard commit_id。 穿梭前，用git log可以查看提交历史，以便确定要回退到哪个版本。 要重返未来，用git reflog查看命令历史，以便确定要回到未来的哪个版本。 如果嫌输出信息太多，看得眼花缭乱的，可以试试加上--pretty=oneline参数： git log --pretty=oneline 如果用git log可以按s向下翻log git log --oneline 可以一行展现 场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令: git checkout -- file。 场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令 git reset HEAD \u003cfile\u003e，就回到了场景1，第二步按场景1操作。 场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退一节，不过前提是没有推送到远程库。 远程库已经准备好了，下一步是用命令git clone克隆一个本地库： git clone git@github.com:xxx/xxx.git 每次本地提交后，只要有必要，就可以使用命令git push origin master推送最新修改； 命令git rm用于删除一个文件。如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，你只能恢复文件到最新版本，你会丢失最近一次提交后你修改的内容。 git remote -v 查看远程库信息. $ git remote -v origin git@github.com:michaelliao/learn-git.git (fetch) origin git@github.com:michaelliao/learn-git.git (push) 然后，根据名字删除，比如删除origin： $ git remote rm origin 我们创建dev分支，然后切换到dev分支: $ git checkout -b dev git checkout命令加上-b参数表示创建并切换，相当于以下两条命令： or 创建并切换dev分支： $ git switch -c dev 用git branch命令查看当前分支： git branch命令会列出所有分支，当前分支前面会标一个*号。 我们把dev分支的工作成果合并到master分支上： $ git merge dev 合并完成后，就可以放心地删除dev分支了： $ git branch -d dev Git鼓励大量使用分支： 查看分支：git branch 创建分支：git branch \u003cname\u003e 切换分支：git checkout \u003cname\u003e或者git switch \u003cname\u003e 创建+切换分支：git checkout -b \u003cname\u003e或者git switch -c \u003cname\u003e 合并某分支到当前分支：git merge \u003cname\u003e 删除分支：git branch -d \u003cname\u003e 推送分支，就是把该分支上的所有本地提交推送到远程库。推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上： $ git push origin master 如果要推送其他分支，比如dev，就改成： $ git push origin dev 因此，多人协作的工作模式通常是这样： 首先，可以试图用git push origin \u003cbranch-name\u003e推送自己的修 如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并； 如果合并有冲突，则解决冲突，并在本地提交； 没有冲突或者解决掉冲突后，再用git push origin \u003cbranch-name\u003e推送就能成功！ 如果git pull提示no tracking information，则说明本地分支和远程分支的链接关系没有创建，用命令git branch --set-upstream-to \u003cbranch-name\u003e origin/\u003cbranch-name\u003e。 这就是多人协作的工作模式，一旦熟悉了，就非常简单。 小结 查看远程库信息，使用git remote -v； 本地新建的分支如果不推送到远程，对其他人就是不可见的； 从本地推送分支，使用git push origin branch-name，如果推送失败，先用git pull抓取远程的新提交； 在本地创建和远程分支对应的分支，使用git checkout -b branch-name origin/branch-name，本地和远程分支的名称最好一致； 建立本地分支和远程分支的关联，使用git branch --set-upstream branch-name origin/branch-name； 从远程抓取分支，使用git pull，如果有冲突，要先处理冲突。 ","date":"2018-10-11","objectID":"/posts/tech/tools/git/:5:0","tags":["git"],"title":"Git小结","uri":"/posts/tech/tools/git/"},{"categories":["Tech"],"content":"Refer to https://git-scm.com/book/zh/v2 https://www.liaoxuefeng.com/wiki/896043488029600 https://www.cnblogs.com/upstudy/p/15868898.html https://www.cnblogs.com/upstudy/p/15870787.html ","date":"2018-10-11","objectID":"/posts/tech/tools/git/:6:0","tags":["git"],"title":"Git小结","uri":"/posts/tech/tools/git/"},{"categories":["Tech"],"content":"Hugo介绍 desc Hugo 几年前的影响力是不如 hexo 的，但现在越来越多的人从 hexo 迁移到了 Hugo，Hugo使用人数也多了起来，GitHub 上 Hugo 项目有 56.2k 个 star，已远远超过了 hexo，因此你也不用太担心 Hugo 会不会太小众化的问题，但是 Hugo 上的主题选择会更少一些，其中最受欢迎的是 wowchemy，但也仅有 6.1k 个star，而本站采用的是 LoveIt 主题，它的 star 就更少了，才 1.6k 个。当然，如果你是搞前端开发的，或者乐意自己写主题，那这些就不重要了。 ","date":"2018-07-13","objectID":"/posts/tech/hugo/hugo-build-blog/:1:0","tags":["hugo","博客"],"title":"Hugo搭建博客(How to build a blog quickly?)","uri":"/posts/tech/hugo/hugo-build-blog/"},{"categories":["Tech"],"content":"优点 速度快 Hugo 采用 Go 语言编写，它的速度用作者的话来形容就是世界上最快的构建网站工具。并且 Hugo 是即时渲染的，这意味着你可以边写边改样式，直到你满意为止。即使是你写了几百篇文章，它也能在几秒之内全部渲染完成。 The world’s fastest framework for building websites 配置更为简单 你需要安装只是 Hugo，不像 hexo 还得安装 Node.js。并且Hugo 中是不区分站点和主题的配置文件的，Hugo 中只有一个位于站点根目录下的 config.toml 配置文件，你只用在这里面进行修改就可以了。 方便自定义 你可以在不修改主题文件的前提下方便地定制主题。在 Hugo 中，如果你想要定制主题，你只需在站点目录下新建相应的文件即可。这是非常利于主题的维护的，你只需使用 Git 的 submodule 的方式安装 Hugo 的主题，然后更新时只需直接在站点根目录下敲一条命令回车即可，非常方便！ ","date":"2018-07-13","objectID":"/posts/tech/hugo/hugo-build-blog/:1:1","tags":["hugo","博客"],"title":"Hugo搭建博客(How to build a blog quickly?)","uri":"/posts/tech/hugo/hugo-build-blog/"},{"categories":["Tech"],"content":"缺点 主题比较少，很可能大家都是用的同一个主题，并且主题作者更新会更少一点。 总结：如果你喜欢 DIY，我建议使用 Hugo。如果你是个专业博主，写了很多文章需要渲染，我建议使用 Hugo！ ","date":"2018-07-13","objectID":"/posts/tech/hugo/hugo-build-blog/:1:2","tags":["hugo","博客"],"title":"Hugo搭建博客(How to build a blog quickly?)","uri":"/posts/tech/hugo/hugo-build-blog/"},{"categories":["Tech"],"content":"环境准备 ","date":"2018-07-13","objectID":"/posts/tech/hugo/hugo-build-blog/:2:0","tags":["hugo","博客"],"title":"Hugo搭建博客(How to build a blog quickly?)","uri":"/posts/tech/hugo/hugo-build-blog/"},{"categories":["Tech"],"content":"安装 hugo 自动安装（依赖网速，可能会非常慢） 在终端中输入 brew install hugo 安装。 安装成功后可输入 hugo version 查看版本信息。 手工安装 首先，请前往 GitHub 上下载最新版的 Hugo 压缩包，Releases · gohugoio/hugo (github.com)，建议选择 extended 版本，这将更有利于后续的 DIY 操作！ 下载完成后解压到一个你认为合适的位置，然后把 hugo.exe 所在的文件夹添加至环境变量中的 Path 中即可。 ","date":"2018-07-13","objectID":"/posts/tech/hugo/hugo-build-blog/:2:1","tags":["hugo","博客"],"title":"Hugo搭建博客(How to build a blog quickly?)","uri":"/posts/tech/hugo/hugo-build-blog/"},{"categories":["Tech"],"content":"使用流程 ","date":"2018-07-13","objectID":"/posts/tech/hugo/hugo-build-blog/:3:0","tags":["hugo","博客"],"title":"Hugo搭建博客(How to build a blog quickly?)","uri":"/posts/tech/hugo/hugo-build-blog/"},{"categories":["Tech"],"content":"1.创建新网址 hugo new site quickstart 其中quickstart更改为用户名.github.io-creator（用户名为 github 用户名，需要小写） 使用code 用户名.github.io-creator使用 vscode 查看目录 ","date":"2018-07-13","objectID":"/posts/tech/hugo/hugo-build-blog/:3:1","tags":["hugo","博客"],"title":"Hugo搭建博客(How to build a blog quickly?)","uri":"/posts/tech/hugo/hugo-build-blog/"},{"categories":["Tech"],"content":"2.添加一个主题 在 quickstart 目录下打开新的终端，输入 git init git clone https://github.com/olOwOlo/hugo-theme-even themes/even 把 \\themes\\LoveIt\\exampleSite目录下的config.toml复制下来，替换掉 站点根目录 下的同名文件。 然后对这个文件进行一些自定义修改。 然后进入根目录下的archetypes文件夹中，修改default.md文件为下面的内容（这个文件是模板文件，通过指令创建的文章将以模板为基础内容） title: \"{{ replace .Name \"-\" \" \" | title }}\" date: {{ .Date }} tags: [\"\"] categories: [\"\"] toc: enable: true description: draft: true 其中title表示文章标题，date为生成文章当时的时间，tags为标签，categories为目录，toc enable为启用文章目录（需要自己在文章中生成），description为文章摘要，draft表示是否为草稿（写完了文章把这里改为 false 即可）， 为 LoveIt 主题的摘要标识符，该标识符上方的内容为文章摘要，如果上方为空，则采用 frontmatter 中设置的descriptions为文章摘要。 ","date":"2018-07-13","objectID":"/posts/tech/hugo/hugo-build-blog/:3:2","tags":["hugo","博客"],"title":"Hugo搭建博客(How to build a blog quickly?)","uri":"/posts/tech/hugo/hugo-build-blog/"},{"categories":["Tech"],"content":"3.添加文件 现在开始撰写文章 hugo new posts/my-first-post.md 并将draft：ture更改为draft：false。 注意: 对于even这个主题，应该使用 post 而不是 posts，即 hugo new post/some-content.md ","date":"2018-07-13","objectID":"/posts/tech/hugo/hugo-build-blog/:3:3","tags":["hugo","博客"],"title":"Hugo搭建博客(How to build a blog quickly?)","uri":"/posts/tech/hugo/hugo-build-blog/"},{"categories":["Tech"],"content":"4.构建页面 写完了文章进行网页的构建 hugo server -D -e production -D表示草稿也要渲染，-serve表示启动一个本地服务器，即时渲染，方便修改。 hugo serve 的默认运行环境是 development, 而 hugo 的默认运行环境是 production。 由于本地 development 环境的限制, 评论系统**, **CDN 和 fingerprint 不会在 development 环境下启用。 你可以使用 hugo serve -e production 命令来开启这些特性。 值得一提的是不论输入的是server还是serve都是一样的。 在浏览器中前往它给出的 http://localhost:1313 就能看到你刚生成的博客了。 当你运行 hugo serve 时, 当文件内容更改时, 页面会随着更改自动刷新. 现在再输入指令 hugo -D 这会生成一个 public 目录, 其中包含你网站的所有静态内容和资源. 现在可以将其部署在任何 Web 服务器上。 确认无误后就要把它发到公网上了，这里采用 GitHub pages 进行部署（当然，也有很多种方法也能达成这一目的） ","date":"2018-07-13","objectID":"/posts/tech/hugo/hugo-build-blog/:3:4","tags":["hugo","博客"],"title":"Hugo搭建博客(How to build a blog quickly?)","uri":"/posts/tech/hugo/hugo-build-blog/"},{"categories":["Tech"],"content":"5. 启动 Hugo 服务器 hugo server -D -D 代表草稿态 ","date":"2018-07-13","objectID":"/posts/tech/hugo/hugo-build-blog/:3:5","tags":["hugo","博客"],"title":"Hugo搭建博客(How to build a blog quickly?)","uri":"/posts/tech/hugo/hugo-build-blog/"},{"categories":["Tech"],"content":"6. 上传至 github ","date":"2018-07-13","objectID":"/posts/tech/hugo/hugo-build-blog/:3:6","tags":["hugo","博客"],"title":"Hugo搭建博客(How to build a blog quickly?)","uri":"/posts/tech/hugo/hugo-build-blog/"},{"categories":["Tech"],"content":"Refer 参考 ","date":"2018-07-13","objectID":"/posts/tech/hugo/hugo-build-blog/:4:0","tags":["hugo","博客"],"title":"Hugo搭建博客(How to build a blog quickly?)","uri":"/posts/tech/hugo/hugo-build-blog/"},{"categories":["Tech"],"content":"知识点 用hugo生成的网站包含以下文件和文件夹： archetypes: 储存.md的模板文件，该文件夹的优先级高于themes下的archetypes文件夹 config.toml: 配置文件 content: 储存网站的所有内容 data: 储存数据文件供模板调用 layouts: 储存.html模板，该文件夹的优先级高于主题下的layouts文件夹 static: 储存图片、css、js等静态文件，该目录下的文件会直接拷贝到/public，该文件夹的优先级高于主题下的/static文件夹 themes: 储存主题 public: 执行hugo命令后，储存生成的静态文件 ","date":"2018-07-13","objectID":"/posts/tech/hugo/hugo-build-blog/:4:1","tags":["hugo","博客"],"title":"Hugo搭建博客(How to build a blog quickly?)","uri":"/posts/tech/hugo/hugo-build-blog/"},{"categories":["Tech"],"content":"Hugo置顶文章 Hugo 置顶文章很简单，只需要将以下放在文章头部即可置顶 --- weight: 1 --- ","date":"2018-07-13","objectID":"/posts/tech/hugo/hugo-build-blog/:4:2","tags":["hugo","博客"],"title":"Hugo搭建博客(How to build a blog quickly?)","uri":"/posts/tech/hugo/hugo-build-blog/"},{"categories":["Tech"],"content":"command #查看版本 hugo version #版本和环境详细信息 hugo env #创建新站点 hugo new site \"mysite\" #创建文章 hugo new index.md 在content/文件夹可以看到，此时多了一个markdown格式的文件index.md，打开文件可以看到时间和文件名等信息已经自动加到文件开头，包括创建时间，页面名，是否为草稿等。 #编译生成静态文件 hugo Hugo将编译所有文件并输出到public目录 #编译生成静态文件并启动web服务 hugo server ","date":"2018-07-13","objectID":"/posts/tech/hugo/hugo-build-blog/:4:3","tags":["hugo","博客"],"title":"Hugo搭建博客(How to build a blog quickly?)","uri":"/posts/tech/hugo/hugo-build-blog/"},{"categories":["Spring"],"content":"jar指定配置文件 java -jar myproject.jar --server.port = 8081 java -jar myproject.jar --server.config.location = /Users/michael/config/application.properties java -jar myproject.jar --server.config.location = /Users/michael/config/application.properties -Dserver.port = 8081 ","date":"2018-06-19","objectID":"/posts/spring/springboot/:1:0","tags":["Springboot"],"title":"Springboot","uri":"/posts/spring/springboot/"},{"categories":["Tech"],"content":"Linux 单机最大进程数、线程数、连接数 ","date":"2018-06-05","objectID":"/posts/tech/os/linux/:1:0","tags":["Linux"],"title":"Linux相关","uri":"/posts/tech/os/linux/"},{"categories":["Tech"],"content":"1、查看Linux系统开启的最大进程数 cat /proc/sys/kernel/pid_max ","date":"2018-06-05","objectID":"/posts/tech/os/linux/:1:1","tags":["Linux"],"title":"Linux相关","uri":"/posts/tech/os/linux/"},{"categories":["Tech"],"content":"2、查看Lixu系统开启的最大线程数 ulimit -u ulimit -a ➜ ~ ulimit -u 2784 ➜ ~ ulimit -a -t: cpu time (seconds) unlimited -f: file size (blocks) unlimited -d: data seg size (kbytes) unlimited -s: stack size (kbytes) 8192 -c: core file size (blocks) 0 -v: address space (kbytes) unlimited -l: locked-in-memory size (kbytes) unlimited -u: processes 2784 -n: file descriptors 256 ","date":"2018-06-05","objectID":"/posts/tech/os/linux/:1:2","tags":["Linux"],"title":"Linux相关","uri":"/posts/tech/os/linux/"},{"categories":["Tech"],"content":"3、 一个进程允许启动的最大线程数 Linux环境，一个进程分配的虚拟内存空间是4G,可用2G，每个线程Stack空间为10M，2048/10 = 200，所以一般的单进程能开通的线程数也就可以确定了。约为200个。 ","date":"2018-06-05","objectID":"/posts/tech/os/linux/:1:3","tags":["Linux"],"title":"Linux相关","uri":"/posts/tech/os/linux/"},{"categories":["Tech"],"content":"4、最大连接数 最大连接数限制就是系统所能打开的最大文件数（文件描述符）的限制，分全局和进程两种，相应的命令如下： sysctl kern.maxfiles 说明：全局限制，也就是系统默认的最大连接数限制是122880 ➜ ~ sysctl kern.maxfiles kern.maxfiles: 122880 sysctl kern.maxfilesperproc 说明：单个进程默认最大连接数限制是61440 ➜ ~ sysctl kern.maxfilesperproc kern.maxfilesperproc: 61440 ulimit －n 说明：“ulimit －n”命令显示当前shell能打开的最大文件数，默认值：256，该值总是小于kern.maxfilesperproc的值，因为一个shell就是一个进程。 ➜ ~ ulimit -n 256 ","date":"2018-06-05","objectID":"/posts/tech/os/linux/:1:4","tags":["Linux"],"title":"Linux相关","uri":"/posts/tech/os/linux/"},{"categories":["Tech"],"content":"Linux base64 编码与解码命令 1、 base64 编码 (1) base64 file 功能：从指定的文件file中读取数据，编码为base64的字符串然后输出； (2) echo \"string\" | base64 功能：将宇符串stringt换行编码为base64的字符串然后输出; (3) echo -n \"string\" I base64 功能：将字符串string编码为base64的字符串然后输出； 2、base64 解码 (1) base64 -d file 功能：从指定的文件file中读取已经过base64编码的数据，然后进行解码，并输出解码后的字符串; (2) echo \"str\" I base64 -d 功能：对base64编码的字符串str和空行进行解码，然后将解码后的字符串输出； (3) echo -n \"str\" | base64 -d 功能：对base64编码的字符串str进行解码，然后将解码后的字符串输出； ","date":"2018-06-05","objectID":"/posts/tech/os/linux/:2:0","tags":["Linux"],"title":"Linux相关","uri":"/posts/tech/os/linux/"},{"categories":["Tech"],"content":"常用命令 ","date":"2018-06-05","objectID":"/posts/tech/os/linux/:3:0","tags":["Linux"],"title":"Linux相关","uri":"/posts/tech/os/linux/"},{"categories":["Tech"],"content":"压缩命令 unrar x *.rar ","date":"2018-06-05","objectID":"/posts/tech/os/linux/:3:1","tags":["Linux"],"title":"Linux相关","uri":"/posts/tech/os/linux/"},{"categories":["Tech"],"content":"查看目录大小及文件数量 查看当前目录的空间大小: du -h -d 1 命令-d表示目录的深度，修改-d的值能看更多层目录的空间大小 查看根分区所有的文件和目录的大小。 du -sh /* 以对单个文件或者目录执行 du -sh /home du -sh * du -lh --max-depth=1 ","date":"2018-06-05","objectID":"/posts/tech/os/linux/:3:2","tags":["Linux"],"title":"Linux相关","uri":"/posts/tech/os/linux/"},{"categories":["Tech"],"content":"查找大文件 find . -type f -size +800M ","date":"2018-06-05","objectID":"/posts/tech/os/linux/:3:3","tags":["Linux"],"title":"Linux相关","uri":"/posts/tech/os/linux/"},{"categories":["Tech"],"content":"查找Linux下的大目录 [linux] du -h --max-depth=1 #对结果排序 du -h --max-depth=1 | sort -n [mac] du -hd1 #对结果排序 du -hd1 | sort -n ","date":"2018-06-05","objectID":"/posts/tech/os/linux/:3:4","tags":["Linux"],"title":"Linux相关","uri":"/posts/tech/os/linux/"},{"categories":["Tech"],"content":"1.保持学习 一个非常重要的观点是：如果你停留在一个地方不前，并不代表你能一直呆在那里，而是代表你正在落后（不进则退）。往前进并不意味着你是就能进步 - 这至少你不会沦落到最后（付出就会有收获） 。程序员为了保持向前发展，就需要不断学习 ，我们需要的不是慢慢的往前走，而是我们要奔跑起来！下面列出这方面的几个观点： 1）读书 2）订阅RSS和阅读一些杂志（我觉得msdn的杂志不错） 3）参加一些研讨会，自己准备一些简报(社区精英、博客园每月的活动等都不错) 4）学习一切可以帮助你的东西 5）教其他人其实也是教自己 ","date":"2018-06-03","objectID":"/posts/book/bettercoder/:1:0","tags":["学习"],"title":"如何成为一名优秀的码农","uri":"/posts/book/bettercoder/"},{"categories":["Tech"],"content":"2.给自己确定目标 如果不知道向什么方向发展，是很难有成就的。这一点关键是自己要有一个清晰地目标。这个应该是个长期的目标，然后要有一个目标的愿景。首先要把这个目标分成一些小的任务，建立实现这些目标的路线图。你可以创建每月或每年你必须完成的一个任务列表，然后根据这个任务列表去实现。 ","date":"2018-06-03","objectID":"/posts/book/bettercoder/:2:0","tags":["学习"],"title":"如何成为一名优秀的码农","uri":"/posts/book/bettercoder/"},{"categories":["Tech"],"content":"3.生活中的每一个挑战都是一个机遇 在日常工作时，总是会遇到各种各样的问题。你可能会遇到一些程序的bug；项目经理分配的新任务；你同事请你帮助；你请别人帮助。这些都是一个一个的挑战。问题是：你如何去解决这些挑战？我的一个答案是：你必要调动你所有的激情去应对这些挑战，因为每个挑战就是一个机遇。 ","date":"2018-06-03","objectID":"/posts/book/bettercoder/:3:0","tags":["学习"],"title":"如何成为一名优秀的码农","uri":"/posts/book/bettercoder/"},{"categories":["Tech"],"content":"4.抱有积极态度 对待每一件事情都应抱着积极的态度。如果发现你犯了一个错误，请不要在意，因为没有人是不会犯错误的。你可以想象一下，有谁喜欢那种一遇到问题就抱怨的人呢？如果你说“好吧,伙计们,我能做到的,请给我一分钟,我就会解决这个问题。”,然后笑着转过身就修改自己的错误，这样在别人眼里又是如何看待你呢？当您解决这个问题之后，你会感觉到异常的高兴。 相信自己的方法是正确的，自己正在快速进步。千万不要老是认为自己无法达到自己的目标。 ","date":"2018-06-03","objectID":"/posts/book/bettercoder/:4:0","tags":["学习"],"title":"如何成为一名优秀的码农","uri":"/posts/book/bettercoder/"},{"categories":["Tech"],"content":"5.给自己寻找一个导师 这并不是说你需要一个人来帮助你来完成你的工作。导师可能就是比你职别高的职员。而且他的职位是你想要去争取的。如果他的职位你争取到了，你可以再选择另外一个更高的。但是你必要一直都需要有这么一个人。也可以能督促你和支持你的朋友、亲人、恋人等等。 ","date":"2018-06-03","objectID":"/posts/book/bettercoder/:5:0","tags":["学习"],"title":"如何成为一名优秀的码农","uri":"/posts/book/bettercoder/"},{"categories":["Tech"],"content":"6.让自己公众化 如何让别人知道你呢？一个最简单的办法是写博客、提问题、帮别人解决问题。起码要google知道你吧。学会在团队和项目中分享自己的知识。如果你学了新的知识，就把它分享出来！如果你没有分享，下次再用的时候，你可能就忘记了。 ","date":"2018-06-03","objectID":"/posts/book/bettercoder/:6:0","tags":["学习"],"title":"如何成为一名优秀的码农","uri":"/posts/book/bettercoder/"},{"categories":["Tech"],"content":"7.时不时的审查一下自己，确保自己的方式正确 时不时的，你需要检查你做的方法是否全正确。检查一下是否完成即将完成的目标。如果没有，赶快找原因，加紧去完成。寻找你的薄弱环节，加强它们。这听起来很滑稽：我认识一个技术很强的开发人员，但他的打字速度却是很慢。为什么？因为他对键盘不熟悉，又不想花10-20小时进行键盘训练。兄弟，如果你会读到此，请务必要求自己克服此类的问题。 ","date":"2018-06-03","objectID":"/posts/book/bettercoder/:7:0","tags":["学习"],"title":"如何成为一名优秀的码农","uri":"/posts/book/bettercoder/"},{"categories":["Tech"],"content":"8.保持健康身体 我写这篇文章之前，算是“集思广益”的。我是一个年轻男子，跟我的笔记本电脑和另一台计算机工作了太长时间，我不能强迫自己做健身运动了。这个有点像磨刀不误砍柴工。有一个故事，两个樵夫打赌砍树，一个比较强壮，另外一个比较瘦弱。强壮的人相信他会赢得，因为他没有休息，持续砍了8小时。瘦小的那位，每隔一个小时就休息15分钟。最后瘦小的那位樵夫却赢了。他赢的秘密在于休息的时候将刀磨锋利了。你的健康就像是斧头，如果斧头钝了，你将无法为自己人生道路披荆斩刺…… ","date":"2018-06-03","objectID":"/posts/book/bettercoder/:8:0","tags":["学习"],"title":"如何成为一名优秀的码农","uri":"/posts/book/bettercoder/"},{"categories":["Tech"],"content":"9.其他 事繁勿慌，事闲勿荒。 每件事情或者项目完成之后，要告之需求者或者领导，让他们做个check，不管大事小事，免后顾之忧。 下班回家前收下邮件，确认没有剩下今天一定要完成的工作，下了班就忘了所有工作。 不要以项目急，作为写糟糕代码的借口，糟糕的代码在以后的维护中会给你带来更大的麻烦。 多请示，多汇报。 不要以工资低，做为不上心工作的借口，既然你接受了这个工资就好好的把事情做好。做一天就要做好一天，不想做就直接走人，别拖着。要做就做好，要么就不做。 动手写程序前，思路一定要清晰，逻辑一定要顺畅，不然写的累，以后维护更累。 碰到问题，就把他研究清楚，弄透彻，这样以后效率会越来越高。不要只知其然，而不知其所以然，下次这个问题还玩你。 要有自己的思想和主见，千万不要只会复制粘贴。 多做事情，不见得是坏事，公司会越来越需要你，多数公司是能看见的。如果你做N多事情，公司视而不见，你可以考虑走人了。 尽量培养自己的一技之长，不管是技术方面的或者业务方面的，提高自己的不可替代性。 学习，技术更新换代很快，不停的学习才是让自己的升值，最起码不贬值的唯一途径。 心态，什么行业，什么工作都会有压力，都会有烦乱的事情。保持良好心态才是王道。 ","date":"2018-06-03","objectID":"/posts/book/bettercoder/:9:0","tags":["学习"],"title":"如何成为一名优秀的码农","uri":"/posts/book/bettercoder/"},{"categories":["Spring"],"content":" Spring注入内部Bean Spring注入集合 Spring注入其他类型的属性 Spring Bean生命周期 Spring后置处理器 AOP面向切面编程 基于XML的AspectJ AOP开发 基于注解的AspectJ AOP开发 Spring整合日志框架Log4j2 ","date":"2018-06-03","objectID":"/posts/spring/springquestion/:0:0","tags":["SpringQuestion"],"title":"SpringQuestion","uri":"/posts/spring/springquestion/"},{"categories":["Spring"],"content":"简易Spring程序 导入基础包 org.springframework.core-xx.jar org.springframework.beans-xx.jar spring-context-xx.jar spring-expression-xx.jar commons.logging-xx.jar 创建Java (HelloWorld.java \u0026\u0026 MainApp.java) public class HelloWorld { private String message; public void setMessage(String message) { this.message = message; } public void getMessage() { System.out.println(\"message : \" + message); } } import org.springframework.context.ApplicationContext; import org.springframework.context.support.ClassPathXmlApplicationContext; public class MainApp { public static void main(String[] args) { ApplicationContext context = new ClassPathXmlApplicationContext(\"Beans.xml\"); HelloWorld obj = context.getBean(\"helloWorld\",HelloWorld.class); obj.getMessage(); } } 关于以上代码，需要注意以下两点： 创建 ApplicationContext 对象时使用了 ClassPathXmlApplicationContext 类，这个类用于加载 Spring 配置文件、创建和初始化所有对象（Bean）。 ApplicationContext.getBean() 方法用来获取 Bean，该方法返回值类型为 Object，通过强制类型转换为 HelloWorld 的实例对象，调用其中的 getMessage() 方法。 创建Beans.xml 在 src 目录下，创建一个 Spring 配置文件 Beans.xml，内容如下: \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd\"\u003e \u003cbean id=\"helloWorld\" class=\"net.biancheng.c.HelloWorld\"\u003e \u003cproperty name=\"message\" value=\"Hello World!\" /\u003e \u003c/bean\u003e \u003c/beans\u003e 运行程序 运行 MainApp.java，控制台中显示信息如下: message : Hello World! ","date":"2018-06-02","objectID":"/posts/spring/springbean/:1:0","tags":["SpringBean"],"title":"SpringBean","uri":"/posts/spring/springbean/"},{"categories":["Spring"],"content":"Spring IOC Spring 有两个核心部分： IoC 和 AOP。 IOC Inverse of Control 的简写，译为“控制反转”，指把创建对象过程交给 Spring 进行管理。 AOP Aspect Oriented Programming 的简写，译为“面向切面编程”。 用来封装多个类的公共行为，将那些与业务无关，却为业务模块所共同调用的逻辑封装起来，减少系统的重复代码，降低模块间的耦合度。另外，AOP 还解决一些系统层面上的问题，比如日志、事务、权限等。 在实际开发中，服务器端应用程序通常采用三层体系架构，分别为表现层（web）、业务逻辑层（service）、持久层（dao）。 IoC 是 Inversion of Control 的简写，译为“控制反转”，它不是一门技术，而是一种设计思想，是一个重要的面向对象编程法则，能够指导我们如何设计出松耦合、更优良的程序。 Spring 通过 IoC 容器来管理所有 Java 对象的实例化和初始化，控制对象与对象之间的依赖关系。我们将由 IoC 容器管理的 Java 对象称为 Spring Bean，它与使用关键字 new 创建的 Java 对象没有任何区别。 ","date":"2018-06-02","objectID":"/posts/spring/springbean/:2:0","tags":["SpringBean"],"title":"SpringBean","uri":"/posts/spring/springbean/"},{"categories":["Spring"],"content":"控制反转（IoC） 在传统的 Java 应用中，一个类想要调用另一个类中的属性或方法，通常会先在其代码中通过 new Object() 的方式将后者的对象创建出来，然后才能实现属性或方法的调用。为了方便理解和描述，我们可以将前者称为“调用者”，将后者称为“被调用者”。也就是说，调用者掌握着被调用者对象创建的控制权。 但在 Spring 应用中，Java 对象创建的控制权是掌握在 IoC 容器手里的，其大致步骤如下。 开发人员通过 XML 配置文件、注解、Java 配置类等方式，对 Java 对象进行定义，例如在 XML 配置文件中使用 标签、在 Java 类上使用 @Component 注解等。 Spring 启动时，IoC 容器会自动根据对象定义，将这些对象创建并管理起来。这些被 IoC 容器创建并管理的对象被称为 Spring Bean。 当我们想要使用某个 Bean 时，可以直接从 IoC 容器中获取（例如通过 ApplicationContext 的 getBean() 方法），而不需要手动通过代码（例如 new Obejct() 的方式）创建。 IoC 带来的最大改变不是代码层面的，而是从思想层面上发生了“主从换位”的改变。原本调用者是主动的一方，它想要使用什么资源就会主动出击，自己创建；但在 Spring 应用中，IoC 容器掌握着主动权，调用者则变成了被动的一方，被动的等待 IoC 容器创建它所需要的对象（Bean）。 这个过程在职责层面发生了控制权的反转，把原本调用者通过代码实现的对象的创建，反转给 IoC 容器来帮忙实现，因此我们将这个过程称为 Spring 的“控制反转”。 ","date":"2018-06-02","objectID":"/posts/spring/springbean/:2:1","tags":["SpringBean"],"title":"SpringBean","uri":"/posts/spring/springbean/"},{"categories":["Spring"],"content":"依赖注入（DI） 在了解了 IoC 之后，我们还需要了解另外一个非常重要的概念：依赖注入。 依赖注入（Denpendency Injection，简写为 DI）是 Martin Fowler 在 2004 年在对“控制反转”进行解释时提出的。Martin Fowler 认为“控制反转”一词很晦涩，无法让人很直接的理解“到底是哪里反转了”，因此他建议使用“依赖注入”来代替“控制反转”。 在面向对象中，对象和对象之间是存在一种叫做“依赖”的关系。简单来说，依赖关系就是在一个对象中需要用到另外一个对象，即对象中存在一个属性，该属性是另外一个类的对象。 例如，有一个名为 B 的 Java 类，它的代码如下: public class B { String bid; A a; } 从代码可以看出，B 中存在一个 A 类型的对象属性 a，此时我们就可以说 B 的对象依赖于对象 a。而依赖注入就是就是基于这种“依赖关系”而产生的。 我们知道，控制反转核心思想就是由 Spring 负责对象的创建。在对象创建过程中，Spring 会自动根据依赖关系，将它依赖的对象注入到当前对象中，这就是所谓的“依赖注入”。 依赖注入本质上是 Spring Bean 属性注入的一种，只不过这个属性是一个对象属性而已。 ","date":"2018-06-02","objectID":"/posts/spring/springbean/:2:2","tags":["SpringBean"],"title":"SpringBean","uri":"/posts/spring/springbean/"},{"categories":["Spring"],"content":"IoC 的工作原理 在 Java 软件开发过程中，系统中的各个对象之间、各个模块之间、软件系统和硬件系统之间，或多或少都存在一定的耦合关系。 若一个系统的耦合度过高，那么就会造成难以维护的问题，但完全没有耦合的代码几乎无法完成任何工作，这是由于几乎所有的功能都需要代码之间相互协作、相互依赖才能完成。因此我们在程序设计时，所秉承的思想一般都是在不影响系统功能的前提下，最大限度的降低耦合度。 IoC 底层通过工厂模式、Java 的反射机制、XML 解析等技术，将代码的耦合度降低到最低限度，其主要步骤如下: 在配置文件（例如 Bean.xml）中，对各个对象以及它们之间的依赖关系进行配置； 我们可以把 IoC 容器当做一个工厂，这个工厂的产品就是 Spring Bean； 容器启动时会加载并解析这些配置文件，得到对象的基本信息以及它们之间的依赖关系； IoC 利用 Java 的反射机制，根据类名生成相应的对象（即 Spring Bean），并根据依赖关系将这个对象注入到依赖它的对象中。 由于对象的基本信息、对象之间的依赖关系都是在配置文件中定义的，并没有在代码中紧密耦合，因此即使对象发生改变，我们也只需要在配置文件中进行修改即可，而无须对 Java 代码进行修改，这就是 Spring IoC 实现解耦的原理。 ","date":"2018-06-02","objectID":"/posts/spring/springbean/:2:3","tags":["SpringBean"],"title":"SpringBean","uri":"/posts/spring/springbean/"},{"categories":["Spring"],"content":"IoC 容器的两种实现 IoC 思想基于 IoC 容器实现的，IoC 容器底层其实就是一个 Bean 工厂。Spring 框架为我们提供了两种不同类型 IoC 容器，它们分别是 BeanFactory 和 ApplicationContext。 ","date":"2018-06-02","objectID":"/posts/spring/springbean/:2:4","tags":["SpringBean"],"title":"SpringBean","uri":"/posts/spring/springbean/"},{"categories":["Spring"],"content":"BeanFactory BeanFactory 是 IoC 容器的基本实现，也是 Spring 提供的最简单的 IoC 容器，它提供了 IoC 容器最基本的功能，由 org.springframework.beans.factory.BeanFactory 接口定义。 BeanFactory 采用懒加载（lazy-load）机制，容器在加载配置文件时并不会立刻创建 Java 对象，只有程序中获取（使用）这个对对象时才会创建。 示例 1 下面我们通过一个实例演示，来演示下 BeanFactory 的使用。 在 HelloSpring 项目中，将 MainApp 的代码修改为使用 BeanFactory 获取 HelloWorld 的对象，具体代码如下: public static void main(String[] args) { BeanFactory context = new ClassPathXmlApplicationContext(\"Beans.xml\"); HelloWorld obj = context.getBean(\"helloWorld\", HelloWorld.class); obj.getMessage(); } 运行 MainApp.java，控制台输出如下。 message : Hello World! 注意：BeanFactory 是 Spring 内部使用接口，通常情况下不提供给开发人员使用。 ","date":"2018-06-02","objectID":"/posts/spring/springbean/:2:5","tags":["SpringBean"],"title":"SpringBean","uri":"/posts/spring/springbean/"},{"categories":["Spring"],"content":"ApplicationContext ApplicationContext 是 BeanFactory 接口的子接口，是对 BeanFactory 的扩展。ApplicationContext 在 BeanFactory 的基础上增加了许多企业级的功能，例如 AOP（面向切面编程）、国际化、事务支持等。 ApplicationContext 接口有两个常用的实现类，具体如下表: 实现类：ClassPathXmlApplicationContext 描述：加载类路径 ClassPath 下指定的 XML 配置文件，并完成 ApplicationContext 的实例化工作 ApplicationContext applicationContext = new ClassPathXmlApplicationContext(String configLocation); 实现类：FileSystemXmlApplicationContext 描述：加载指定的文件系统路径中指定的 XML 配置文件，并完成 ApplicationContext 的实例化工作 ApplicationContext applicationContext = new FileSystemXmlApplicationContext(String configLocation); 在上表的示例代码中，参数 configLocation 用于指定 Spring 配置文件的名称和位置，如 Beans.xml。 示例 2 下面我们就通过一个实例，来演示 ApplicationContext 的使用。 修改 HelloSpring 项目 MainApp 类中 main() 方法的代码，具体代码如下。 public static void main(String[] args) { //使用 FileSystemXmlApplicationContext 加载指定路径下的配置文件 Bean.xml BeanFactory context = new FileSystemXmlApplicationContext(\"E:\\\\workspace\\\\HelloSpring\\\\src\\\\Beans.xml\"); HelloWorld obj = context.getBean(\"helloWorld\", HelloWorld.class); obj.getMessage(); } 运行 MainApp.java，控制台输出如下。 message : Hello World! ","date":"2018-06-02","objectID":"/posts/spring/springbean/:2:6","tags":["SpringBean"],"title":"SpringBean","uri":"/posts/spring/springbean/"},{"categories":["Spring"],"content":"Spring Bean加载流程 Spring IOC容器就像是一个生产产品的流水线上的机器，Spring创建出来的Bean就好像是流水线的终点生产出来的一个个精美绝伦的产品。既然是机器，总要先启动，Spring也不例外。因此Bean的加载流程总体上来说可以分为两个阶段： 容器启动阶段 Bean创建阶段 ","date":"2018-06-02","objectID":"/posts/spring/springbean/:3:0","tags":["SpringBean"],"title":"SpringBean","uri":"/posts/spring/springbean/"},{"categories":["Spring"],"content":"一、容器启动阶段： 容器的启动阶段做了很多的预热工作，为后面Bean的实例化做好了充分的准备，我们首先看一下容器的启动阶段都做了哪些预热工作。 配置元信息 BeanDefination BeanDefinationReader BeanDefinationRegistry BeanFactoryPostProcessor 配置元信息 Spring IOC容器将对象实例的创建与对象实例的使用分离，当业务中需要依赖某个对象，不再依靠我们自己手动创建，只需向Spring要，Spring就会以注入的方式交给我们需要的依赖对象。既然将对象创建的任务交给了Spring，那么Spring就需要知道创建一个对象所需要的一些必要的信息。而这些必要的信息可以是Spring过去支持最完善的xml配置文件，或者是其他形式的例如properties的磁盘文件，也可以是现在主流的注解，甚至是直接的代码硬编码。总之，这些创建对象所需要的必要信息称为配置 元信息。 \u003cbean id=\"role\" class=\"com.wbg.springxmlbean.entity.Role\"\u003e \u003c!-- property元素是定义类的属性，name属性定义的是属性名称 value是值 相当于： Role role=new Role(); role.setId(1); role.setRoleName(\"高级工程师\"); role.setNote(\"重要人员\");--\u003e \u003cproperty name=\"id\" value=\"1\"/\u003e \u003cproperty name=\"roleName\" value=\"高级工程师\"/\u003e \u003cproperty name=\"note\" value=\"重要人员\"/\u003e \u003c/bean\u003e BeanDefination： 在Java世界中，万物皆对象，散落于程序代码各处的注解以及保存在磁盘上的xml或者其他文件等等配置元信息，在内存中总要以一种对象的形式表示，就好比我们活生生的人对应到Java世界中就是一个Person类，而Spring选择在内存中表示这些配置元信息的方式就是BeanDefination，这里我们不会去分析BeanDefination的代码，这里我们只需要知道配置元信息被加载到内存之后是以BeanDefination的形存在的即可。 BeanDefinationReader： Spring是如何看懂这些配置元信息的呢？这个就要靠我们的BeanDefinationReader了。不同的BeanDefinationReader拥有不同的功能: 如果我们要读取xml配置元信息，那么可以使用XmlBeanDefinationReader。 如果我们要读取properties配置文件，那么可以使用PropertiesBeanDefinitionReader加载。 而如果我们要读取注解配置元信息，那么可以使用 AnnotatedBeanDefinitionReader加载。 我们也可以很方便的自定义BeanDefinationReader来自己控制配置元信息的加载。 总的来说，BeanDefinationReader的作用就是加载配置元信息，并将其转化为内存形式的BeanDefination ，存在某一个地方，至于这个地方在哪里，不要着急，接着往下看！ BeanDefinationRegistry： 执行到这里，Spring已经将存在于各处的配置元信息加载到内存，并转化为BeanDefination的形式，这样我们需要创建某一个对象实例的时候，找到相应的BeanDefination然后创建对象即可。那么我们需要某一个对象的时候，去哪里找到对应的BeanDefination呢？这种通过Bean定义的id找到对象的BeanDefination的对应关系或者说映射关系又是如何保存的呢？这就引出了BeanDefinationRegistry了。 Spring通过BeanDefinationReader将配置元信息加载到内存生成相应的BeanDefination之后，就将其注册到BeanDefinationRegistry中，BeanDefinationRegistry就是一个存放BeanDefination的大篮子，它也是一种键值对的形式，通过特定的Bean定义的id，映射到相应的BeanDefination。 BeanFactoryPostProcessor： BeanFactoryPostProcessor是容器启动阶段Spring提供的一个扩展点，主要负责对注册到BeanDefinationRegistry中的一个个的BeanDefination进行一定程度上的修改与替换。例如我们的配置元信息中有些可能会修改的配置信息散落到各处，不够灵活，修改相应配置的时候比较麻烦，这时我们可以使用占位符的方式来配置。例如配置Jdbc的DataSource连接的时候可以这样配置： \u003cbean id=\"dataSource\" class=\"org.apache.commons.dbcp.BasicDataSource\" destroy-method=\"close\"\u003e \u003cproperty name=\"maxIdle\" value=\"${jdbc.maxIdle}\"\u003e\u003c/property\u003e \u003cproperty name=\"maxActive\" value=\"${jdbc.maxActive}\"\u003e\u003c/property\u003e \u003cproperty name=\"maxWait\" value=\"${jdbc.maxWait}\"\u003e\u003c/property\u003e \u003cproperty name=\"minIdle\" value=\"${jdbc.minIdle}\"\u003e\u003c/property\u003e \u003cproperty name=\"driverClassName\" value=\"${jdbc.driverClassName}\"\u003e \u003c/property\u003e \u003cproperty name=\"url\" value=\"${jdbc.url}\"\u003e\u003c/property\u003e \u003cproperty name=\"username\" value=\"${jdbc.username}\"\u003e\u003c/property\u003e \u003cproperty name=\"password\" value=\"${jdbc.password}\"\u003e\u003c/property\u003e \u003c/bean\u003e BeanFactoryPostProcessor就会对注册到BeanDefinationRegistry中的BeanDefination做最后的修改，替换$占位符为配置文件中的真实的数据。 至此，整个容器启动阶段就算完成了，容器的启动阶段的最终产物就是注册到BeanDefinationRegistry中的一个个BeanDefination了，这就是Spring为Bean实例化所做的预热的工作。让我们再通过一张图的形式回顾一下容器启动阶段都是搞了什么事吧。 ","date":"2018-06-02","objectID":"/posts/spring/springbean/:3:1","tags":["SpringBean"],"title":"SpringBean","uri":"/posts/spring/springbean/"},{"categories":["Spring"],"content":"Spring Bean定义 由 Spring IoC 容器管理的对象称为 Bean，Bean 根据 Spring 配置文件中的信息创建。 我们可以把 Spring IoC 容器看作是一个大工厂，Bean 相当于工厂的产品。如果希望这个大工厂生产和管理 Bean，就需要告诉容器需要哪些 Bean，以哪种方式装配。 Spring 配置文件支持两种格式，即 XML 文件格式和 Properties 文件格式。 Properties 配置文件主要以 key-value 键值对的形式存在，只能赋值，不能进行其他操作，适用于简单的属性配置。 XML 配置文件采用树形结构，结构清晰，相较于 Properties 文件更加灵活。但是 XML 配置比较繁琐，适用于大型的复杂的项目。 通常情况下，Spring 的配置文件都是使用 XML 格式的。XML 配置文件的根元素是 ，该元素包含了多个子元素 。每一个 元素都定义了一个 Bean，并描述了该 Bean 是如何被装配到 Spring 容器中的。 如Beans.xml 配置文件，代码如下所示： \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd\"\u003e \u003cbean id=\"helloWorld\" class=\"net.biancheng.c.HelloWorld\"\u003e \u003cproperty name=\"message\" value=\"Hello World!\"/\u003e \u003c/bean\u003e \u003c/beans\u003e ","date":"2018-06-02","objectID":"/posts/spring/springbean/:4:0","tags":["SpringBean"],"title":"SpringBean","uri":"/posts/spring/springbean/"},{"categories":["Spring"],"content":"Spring Bean属性注入 所谓 Bean 属性注入，简单点说就是将属性注入到 Bean 中的过程，而这属性既可以普通属性，也可以是一个对象（Bean）。 Spring 主要通过以下 2 种方式实现属性注入： 构造函数注入 setter 注入（又称设值注入） ","date":"2018-06-02","objectID":"/posts/spring/springbean/:5:0","tags":["SpringBean"],"title":"SpringBean","uri":"/posts/spring/springbean/"},{"categories":["Spring"],"content":"构造函数注入 我们可以通过 Bean 的带参构造函数，以实现 Bean 的属性注入。 使用构造函数实现属性注入大致步骤如下： 在 Bean 中添加一个有参构造函数，构造函数内的每一个参数代表一个需要注入的属性； 在 Spring 的 XML 配置文件中，通过 及其子元素 对 Bean 进行定义； 在 元素内使用 元素，对构造函数内的属性进行赋值，Bean 的构造函数内有多少参数，就需要使用多少个 元素。 示例 1 下面我们就通过一个实例，来演示下如何构造函数注入的方式实现属性注入。 创建一个名为 Grade、Student 的类， import org.apache.commons.logging.Log; import org.apache.commons.logging.LogFactory; public class Grade { private static final Log LOGGER = LogFactory.getLog(Grade.class); private Integer gradeId; private String gradeName; public Grade(Integer gradeId, String gradeName) { LOGGER.info(\"正在执行 Course 的有参构造方法，参数分别为：gradeId=\" + gradeId + \",gradeName=\" + gradeName); this.gradeId = gradeId; this.gradeName = gradeName; } @Override public String toString() { return \"Grade{\" +\"gradeId=\" + gradeId +\", gradeName='\" + gradeName + '\\'' +'}'; } } import org.apache.commons.logging.Log; import org.apache.commons.logging.LogFactory; public class Student { private static final Log LOGGER = LogFactory.getLog(Student.class); private int id; private String name; private Grade grade; public Student(int id, String name, Grade grade) { LOGGER.info(\"正在执行 Course 的有参构造方法，参数分别为：id=\" + id + \",name=\" + name + \",grade=\" + grade); this.id = id; this.name = name; this.grade = grade; } @Override public String toString() { return \"Student{\" +\"id=\" + id +\", name='\" + name + '\\'' +\", grade=\" + grade +'}'; } } 在 src 目录下创建 Spring 配置文件 Beans.xml，配置如下： \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd\"\u003e \u003cbean id=\"student\" class=\"net.biancheng.c.Student\"\u003e \u003cconstructor-arg name=\"id\" value=\"2\"\u003e\u003c/constructor-arg\u003e \u003cconstructor-arg name=\"name\" value=\"李四\"\u003e\u003c/constructor-arg\u003e \u003c!-- 使用constructor-arg 标签： 依赖 grade --\u003e \u003cconstructor-arg name=\"grade\" ref=\"grade\"\u003e\u003c/constructor-arg\u003e \u003c/bean\u003e \u003cbean id=\"grade\" class=\"net.biancheng.c.Grade\"\u003e \u003cconstructor-arg name=\"gradeId\" value=\"4\"\u003e\u003c/constructor-arg\u003e \u003cconstructor-arg name=\"gradeName\" value=\"四年级\"\u003e\u003c/constructor-arg\u003e \u003c/bean\u003e \u003c/beans\u003e 创建一个名为 MainApp 的类，代码如下 import org.apache.commons.logging.Log; import org.apache.commons.logging.LogFactory; import org.springframework.context.ApplicationContext; import org.springframework.context.support.ClassPathXmlApplicationContext; public class MainApp { private static final Log LOGGER = LogFactory.getLog(MainApp.class); public static void main(String[] args) { //获取 ApplicationContext 容器 ApplicationContext context = new ClassPathXmlApplicationContext(\"Beans.xml\"); //获取名为 student 的 Bean Student student = context.getBean(\"student\", Student.class); //通过日志打印学生信息 LOGGER.info(student.toString()); } } 执行 MainApp 中的 main() 方法，控制台输出如下： 十二月 16, 2021 4:38:42 下午 net.biancheng.c.Grade \u003cinit\u003e 信息: 正在执行 Course 的有参构造方法，参数分别为：gradeId=4,gradeName=四年级 十二月 16, 2021 4:38:42 下午 net.biancheng.c.Student \u003cinit\u003e 信息: 正在执行 Course 的有参构造方法，参数分别为：id=2,name=李四,grade=Grade{gradeId=4, gradeName='四年级'} 十二月 16, 2021 4:38:42 下午 net.biancheng.c.MainApp main 信息: Student{id=2, name='李四', grade=Grade{gradeId=4, gradeName='四年级'}} ","date":"2018-06-02","objectID":"/posts/spring/springbean/:5:1","tags":["SpringBean"],"title":"SpringBean","uri":"/posts/spring/springbean/"},{"categories":["Spring"],"content":"setter 注入 我们可以通过 Bean 的 setter 方法，将属性值注入到 Bean 的属性中。 在 Spring 实例化 Bean 的过程中，IoC 容器首先会调用默认的构造方法（无参构造方法）实例化 Bean（Java 对象），然后通过 Java 的反射机制调用这个 Bean 的 setXxx() 方法，将属性值注入到 Bean 中。 使用 setter 注入的方式进行属性注入，大致步骤如下： 在 Bean 中提供一个默认的无参构造函数（在没有其他带参构造函数的情况下，可省略），并为所有需要注入的属性提供一个 setXxx() 方法； 在 Spring 的 XML 配置文件中，使用 及其子元素 对 Bean 进行定义； 在 元素内使用 元素对各个属性进行赋值。 示例 2 下面，我们就通过一个实例，来演示如何通过 setter 注入的方式实现属性注入，步骤如下: @Data public class Student { private int id; private String name; private Grade grade; } @Data public class Grade { private Integer gradeId; private String gradeName; } 在 src 目录下，修改配置文件 Beans.xml 的内容: \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd\"\u003e \u003cbean id=\"student\" class=\"net.biancheng.c.Student\"\u003e \u003c!--使用 property 元素完成属性注入 name: 类中的属性名称，例如 id,name value: 向属性注入的值 例如 学生的 id 为 1，name 为张三 --\u003e \u003cproperty name=\"id\" value=\"1\"\u003e\u003c/property\u003e \u003cproperty name=\"name\" value=\"张三\"\u003e\u003c/property\u003e \u003cproperty name=\"grade\" ref=\"grade\"\u003e\u003c/property\u003e \u003c/bean\u003e \u003cbean id=\"grade\" class=\"net.biancheng.c.Grade\"\u003e \u003cproperty name=\"gradeId\" value=\"3\"\u003e\u003c/property\u003e \u003cproperty name=\"gradeName\" value=\"三年级\"\u003e\u003c/property\u003e \u003c/bean\u003e \u003c/beans\u003e MainApp.java import org.springframework.context.ApplicationContext; import org.springframework.context.support.ClassPathXmlApplicationContext; public class MainApp { public static void main(String[] args) { //获取 ApplicationContext 容器 ApplicationContext context = new ClassPathXmlApplicationContext(\"Beans.xml\"); //获取名为 student 的 Bean Student student = context.getBean(\"student\", Student.class); //通过日志打印学生信息 LOGGER.info(student.toString()); } } ","date":"2018-06-02","objectID":"/posts/spring/springbean/:5:2","tags":["SpringBean"],"title":"SpringBean","uri":"/posts/spring/springbean/"},{"categories":["Spring"],"content":"Spring Bean作用域 默认情况下，所有的 Spring Bean 都是单例的，也就是说在整个 Spring 应用中， Bean 的实例只有一个。 我们可以在 元素中添加 scope 属性来配置 Spring Bean 的作用范围。例如，如果每次获取 Bean 时，都需要一个新的 Bean 实例，那么应该将 Bean 的 scope 属性定义为 prototype，如果 Spring 需要每次都返回一个相同的 Bean 实例，则应将 Bean 的 scope 属性定义为 singleton。 Spring 5 共提供了 6 种 scope 作用域，如下表: singleton 默认值，单例模式，表示在 Spring 容器中只有一个 Bean 实例 prototype 原型模式，表示每次通过 Spring 容器获取 Bean 时，容器都会创建一个新的 Bean 实例。 request 每次 HTTP 请求，容器都会创建一个 Bean 实例。该作用域只在当前 HTTP Request 内有效。 session 同一个 HTTP Session 共享一个 Bean 实例，不同的 Session 使用不同的 Bean 实例。该作用域仅在当前 HTTP Session 内有效。 application 同一个 Web 应用共享一个 Bean 实例，该作用域在当前 ServletContext 内有效。 与 singleton 类似，但 singleton 表示每个 IoC 容器中仅有一个 Bean 实例，而一个 Web 应用中可能会存在多个 IoC 容器，但一个 Web 应用只会有一个 ServletContext，也可以说 application 才是 Web 应用中货真价实的单例模式。 websocket websocket 的作用域是 WebSocket ，即在整个 WebSocket 中有效。 ","date":"2018-06-02","objectID":"/posts/spring/springbean/:6:0","tags":["SpringBean"],"title":"SpringBean","uri":"/posts/spring/springbean/"},{"categories":["Spring"],"content":"singleton singleton 是 Spring 容器默认的作用域。当 Bean 的作用域为 singleton 时，Spring IoC 容器中只会存在一个共享的 Bean 实例。这个 Bean 实例将存储在高速缓存中，所有对于这个 Bean 的请求和引用，只要 id 与这个 Bean 定义相匹配，都会返回这个缓存中的对象实例。 如果一个 Bean 定义的作用域为 singleton ，那么这个 Bean 就被称为 singleton bean。在 Spring IoC 容器中，singleton bean 是 Bean 的默认创建方式，可以更好地重用对象，节省重复创建对象的开销。 在 Spring 配置文件中，可以使用 元素的 scope 属性，将 Bean 的作用域定义成 singleton，其配置方式如下所示： \u003cbean id=\"...\" class=\"...\" scope=\"singleton\"/\u003e 创建一个名为 SingletonBean 的类: @Data public class SingletonBean { private String str; } 在 src 目录下创建 Spring 配置文件 Beans.xml，配置如下: \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd\"\u003e \u003cbean id=\"singletonBean\" class=\"net.biancheng.c.SingletonBean\" scope=\"singleton\"\u003e \u003cproperty name=\"str\" value=\"C语言中文网\"\u003e\u003c/property\u003e \u003c/bean\u003e \u003c/beans\u003e MainApp 的类，代码如下: import org.springframework.context.ApplicationContext; import org.springframework.context.support.ClassPathXmlApplicationContext; public class MainApp { public static void main(String[] args) { //获取 ApplicationContext 容器 ApplicationContext context = new ClassPathXmlApplicationContext(\"Beans.xml\"); SingletonBean singletonBean = context.getBean(\"singletonBean\", SingletonBean.class); SingletonBean singletonBean2 = context.getBean(\"singletonBean\", SingletonBean.class); System.out.println(singletonBean); System.out.println(singletonBean2); } } 运行 MainApp 类中的 main() 方法，控制台输出如下: net.biancheng.c.SingletonBean@65e2dbf3 net.biancheng.c.SingletonBean@65e2dbf3 从控制台的输出可以看出，两次获得的 Bean 实例的地址完全一样，这说明 IoC 容器只创建了一个 singletonBean 实例。由于 singleton 是 Spring IoC 容器的默认作用域，因此即使省略 scope 属性，控制台的输出结果也一样的。 ","date":"2018-06-02","objectID":"/posts/spring/springbean/:6:1","tags":["SpringBean"],"title":"SpringBean","uri":"/posts/spring/springbean/"},{"categories":["Spring"],"content":"prototype 如果一个 Bean 定义的作用域为 prototype，那么这个 Bean 就被称为 prototype bean。对于 prototype bean 来说，Spring 容器会在每次请求该 Bean 时，都创建一个新的 Bean 实例。 从某种意义上说，Spring IoC 容器对于 prototype bean 的作用就相当于 Java 的 new 操作符。它只负责 Bean 的创建，至于后续的生命周期管理则都是由客户端代码完成的，详情请参看《Spring Bean 生命周期》。 在 Spring 配置文件中，可以使用 元素的 scope 属性将 Bean 的作用域定义成 prototype，其配置方式如下所示： 纯文本复制 \u003cbean id=\"...\" class=\"...\" scope=\"prototype\"/\u003e 创建一个名为 SingletonBean 的类: @Data public class PrototypeBean { private String str; } 在 src 目录下创建 Spring 配置文件 Beans.xml，配置如下: \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd\"\u003e \u003c!--单例模式 singleton--\u003e \u003cbean id=\"singletonBean\" class=\"net.biancheng.c.SingletonBean\" scope=\"singleton\"\u003e \u003cproperty name=\"str\" value=\"C语言中文网\"\u003e\u003c/property\u003e \u003c/bean\u003e \u003c!--原型模式 prototype--\u003e \u003cbean id=\"prototypeBean\" class=\"net.biancheng.c.PrototypeBean\" scope=\"prototype\"\u003e \u003cproperty name=\"str\" value=\"c.biancheng.net\"\u003e\u003c/property\u003e \u003c/bean\u003e \u003c/beans\u003e MainApp 的类，代码如下: import org.springframework.context.ApplicationContext; import org.springframework.context.support.ClassPathXmlApplicationContext; public class MainApp { public static void main(String[] args) { //获取 ApplicationContext 容器 ApplicationContext context = new ClassPathXmlApplicationContext(\"Beans.xml\"); PrototypeBean prototypeBean = context.getBean(\"prototypeBean\", PrototypeBean.class); PrototypeBean prototypeBean2 = context.getBean(\"prototypeBean\", PrototypeBean.class); System.out.println(prototypeBean); System.out.println(prototypeBean2); } } 运行 MainApp 类中的 main() 方法，控制台输出如下: net.biancheng.c.PrototypeBean@61f8bee4 net.biancheng.c.PrototypeBean@7b49cea0 从运行结果可以看出，两次输出的内容并不相同，这说明在 prototype 作用域下，Spring 容器创建了两个不同的 prototypeBean 实例。 ","date":"2018-06-02","objectID":"/posts/spring/springbean/:6:2","tags":["SpringBean"],"title":"SpringBean","uri":"/posts/spring/springbean/"},{"categories":["Spring"],"content":"Refer to refer to referto - spring ","date":"2018-06-02","objectID":"/posts/spring/springbean/:7:0","tags":["SpringBean"],"title":"SpringBean","uri":"/posts/spring/springbean/"},{"categories":["Spring"],"content":"@Autowired 和 @Resource ","date":"2018-06-01","objectID":"/posts/spring/spring/:1:0","tags":["Spring"],"title":"Spring","uri":"/posts/spring/spring/"},{"categories":["Spring"],"content":"定义 @Autowired 对类成员变量、方法及构造函数进行标注，完成自动装配的工作。 @Resource 在语义上被定义为通过其唯一的名称来标识特定的目标组件，其中声明的类型与匹配过程无关。 ","date":"2018-06-01","objectID":"/posts/spring/spring/:1:1","tags":["Spring"],"title":"Spring","uri":"/posts/spring/spring/"},{"categories":["Spring"],"content":"区别 在Spring框架中，如果在Service层中需要注入其他依赖的对象，通常我们都会使用@Autowired或者@Resource注解，但是它们是有区别的，比如@Autowired跟Spring框架强耦合了， 如果换成其他框架，@Autowired就没作用了。而@Resource是JSR-250提供的，它是Java标准，绝大部分框架都支持。 包含的属性不同 @Autowired只包含一个参数：required，表示是否开启自动注入，默认是true。而@Resource包含七个参数，其中最重要的两个参数是：name 和 type。 @Autowired默认按byType自动装配，而@Resource默认byName自动装配。 @Autowired如果要使用byName，需要使用@Qualifier一起配合。而@Resource如果指定了name，则用byName自动装配，如果指定了type，则用byType自动装配。 注解应用的地方不同 @Autowired能够用在：构造器、方法、参数、成员变量和注解上，而@Resource能用在：类、成员变量和方法上。 出处不同 @Autowired是Spring定义的注解，而@Resource是JSR-250定义的注解。所以@Autowired只能在Spring框架下使用，而@Resource则可以与其他框架一起使用。 装配顺序不同 @Autowired的装配顺序如下： @Autowired默认先按byType进行匹配，如果发现找到多个bean，则又按照byName方式进行匹配，如果还有多个，则报出异常。 @Resource的装配顺序如下： 如果同时指定了name和type，流程如下： 找到name和type唯一的bean，找得到，进行装配；找不到或者找到多个，都会抛出异常。 如果指定了name，流程如下： 只是指定了@Resource注解的name，则按name后的名字去bean元素里查找有与之相等的name属性的bean，找不到或者找到多个，都会抛出异常。 如果指定了type，流程如下： 只指定@Resource注解的type属性，则从上下文中找到类型匹配的唯一bean进行装配，找不到或者找到多个，都会抛出异常。 如果既没有指定name，也没有指定type，流程如下： 既不指定name属性，也不指定type属性，则自动按byName方式进行查找。如果没有找到符合的bean，则回退为一个原始类型进行进行查找，如果找到就注入。 ","date":"2018-06-01","objectID":"/posts/spring/spring/:1:2","tags":["Spring"],"title":"Spring","uri":"/posts/spring/spring/"},{"categories":["Tech"],"content":"Windows下通过bat调用jar时，传参，网上有很多例子，这里就不做阐述。 今儿讲下如何在bat调用jar后，bat可以获取jar的返回值： 思路如下： jar内部执行相应的逻辑，输出不同的内容； 通过常规bat调用jar，同时将jar的输出内容定向到某一个文件a.txt中。（jar中若有时间轮询或等待，bat则会等jar完全结束后，才回处理后续作业） bat后续通过读取文件a.txt内容，进行后续逻辑操作； 以上思路，曲线救国~ demo code如下：inovke.bat @echo off java -jar test.jar \u003e a.txt setlocal enabledelayedexpansion for /f \"tokens=1-3\" %%i in (a.txt) do echo 第一列：%%i 第二列：%%j 第三列：%%k echo %a% pause test.jar的主类文件： public class Config { public static void main(String[] args) { Random random = new Random(); int result = random.nextInt(10); try { TimeUnit.SECONDS.sleep(result);// 随机等待秒速 } catch (InterruptedException e) { e.printStackTrace(); } } } 以上，完成bat同jar的交互 ； 今儿发现另一个思路，可以使用python胶水，来曲线救国~ 记录一下~ ","date":"2018-05-12","objectID":"/posts/tech/tools/windowsbat/:0:0","tags":["bat"],"title":"bat同jar交互","uri":"/posts/tech/tools/windowsbat/"},{"categories":["Tech"],"content":" markdown-it-demo Refer markdown grammar Markdown，写博客当然要用这个。在线编辑器，所见即所得地编写。 ","date":"2018-05-06","objectID":"/posts/tech/tools/markdown/:0:0","tags":["markdown"],"title":"Markdown 基本语法","uri":"/posts/tech/tools/markdown/"},{"categories":["Tech"],"content":"标题 markdown总支持1~6六级标题，通过在一行之前加上不同数量的井号来表示。 # 这是 H1 # ## 这是 H2 ## ### 这是 H3 ### … ","date":"2018-05-06","objectID":"/posts/tech/tools/markdown/:1:0","tags":["markdown"],"title":"Markdown 基本语法","uri":"/posts/tech/tools/markdown/"},{"categories":["Tech"],"content":"段落 非常自然，一行文字就是一个段落。 段落开头的一个空格\u0026emsp;\u0026emsp; ","date":"2018-05-06","objectID":"/posts/tech/tools/markdown/:2:0","tags":["markdown"],"title":"Markdown 基本语法","uri":"/posts/tech/tools/markdown/"},{"categories":["Tech"],"content":"文本样式 字体样式常用的有粗体、斜体、删除线等。 *斜体字* 对应 斜体字 **粗体字** 对应 粗体字 ~~删除线~~ 对应 删除线 行内代码 对应 行内代码 还有一些样式原生不支持，但是可以通过html间接支持。 可以使用星号*或下划线_指定粗体或者斜体。 这是斜体 这也是斜体 这是粗体 这是粗体+斜体 *这是斜体* _这也是斜体_ **这是粗体** ***这是粗体+斜体*** ` 行内代码 ` ","date":"2018-05-06","objectID":"/posts/tech/tools/markdown/:3:0","tags":["markdown"],"title":"Markdown 基本语法","uri":"/posts/tech/tools/markdown/"},{"categories":["Tech"],"content":"引用 通过在行首加上大于号\u003e来添加引用格式。 DD DD 引用可以嵌套： w 引用可以嵌套： \u003ew \u003e \u003e引用可以嵌套： 也可以嵌套其他格式： ","date":"2018-05-06","objectID":"/posts/tech/tools/markdown/:4:0","tags":["markdown"],"title":"Markdown 基本语法","uri":"/posts/tech/tools/markdown/"},{"categories":["Tech"],"content":"task list ( checkbox ) - [ ] todo: task one not finish `- + SPACE +[ ]` - [x] finish: task twp finish `- + SPACE +[x]` todo: task one not finish - + SPACE +[ ] finish: task twp finish - + SPACE +[x] ","date":"2018-05-06","objectID":"/posts/tech/tools/markdown/:5:0","tags":["markdown"],"title":"Markdown 基本语法","uri":"/posts/tech/tools/markdown/"},{"categories":["Tech"],"content":"列表 无序列表使用星号、加号或是减号作为列表标记： Red Green Blue 等同于 Red Green Blue 和 Red Green Blue - Red - Green - Blue 有序列表则使用数字接着一个英文句点： Bird McHale Parish 数字并不会影响输出的 HTML 结果，也就是说上面的例子等同于： Bird McHale Parish ","date":"2018-05-06","objectID":"/posts/tech/tools/markdown/:6:0","tags":["markdown"],"title":"Markdown 基本语法","uri":"/posts/tech/tools/markdown/"},{"categories":["Tech"],"content":"内联代码 用反引号` 来标记内联代码，它们会解释成标签 \u003ccode\u003e标签\u003c/code\u003e 如果代码的内容中有反引号，请用两个反引号包裹。 代码中的\u0026、\u003c、\u003e符号都会自动转义，请放心使用。 ` eee ` eee 还有一种是github的风格，代码段的前后用三个反引号 ``` 独占一行来标记。 ww ","date":"2018-05-06","objectID":"/posts/tech/tools/markdown/:7:0","tags":["markdown"],"title":"Markdown 基本语法","uri":"/posts/tech/tools/markdown/"},{"categories":["Tech"],"content":"分隔线 你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线： * * * *** ***** - - - --------------------------------------- ","date":"2018-05-06","objectID":"/posts/tech/tools/markdown/:8:0","tags":["markdown"],"title":"Markdown 基本语法","uri":"/posts/tech/tools/markdown/"},{"categories":["Tech"],"content":"超链接 an example an example [an example](http://example.com/) [an example](http://example.com/ \"Optional Title\") 会被解释为 \u003ca href='https://www.google.com/'\u003egoogle\u003c/a\u003e \u003ca href='https://www.google.com/' title=\"Optional Title\"\u003egoogle\u003c/a\u003e ","date":"2018-05-06","objectID":"/posts/tech/tools/markdown/:9:0","tags":["markdown"],"title":"Markdown 基本语法","uri":"/posts/tech/tools/markdown/"},{"categories":["Tech"],"content":"转义 markdown支持在以下字符前面插入反斜杠，插入之后，将不再解析这些字符，而是原样输出。 \\ 反斜线 ` 反引号 * 星号 _ 底线 {} 花括号 [] 方括号 () 括弧 # 井字号 + 加号 - 减号 . 英文句点 ! 惊叹号 ","date":"2018-05-06","objectID":"/posts/tech/tools/markdown/:10:0","tags":["markdown"],"title":"Markdown 基本语法","uri":"/posts/tech/tools/markdown/"},{"categories":["Tech"],"content":"表格(table) Item Value Qty Computer $1600 5 Phone $12 12 Pipe $1 234 | Item | Value | Qty | | :------- | ----: | :---: | | Computer | $1600 | 5 | | Phone | $12 | 12 | | Pipe | $1 | 234 | title1 title2 v1 v2 要注意第二行的冒号决定了居左居右还是居中，如果你不加冒号，默认是居左的。 另外可以把第一行去掉，做成没有表头的表格，但第二行始终是要有的。 ","date":"2018-05-06","objectID":"/posts/tech/tools/markdown/:11:0","tags":["markdown"],"title":"Markdown 基本语法","uri":"/posts/tech/tools/markdown/"},{"categories":["Tech"],"content":"TOC TOC = Table of content ， 将内容制作成导航 hexo toc 快速生成markdown目录TOC 快速生成markdown目录TOC，页内跳转 图片 ","date":"2018-05-06","objectID":"/posts/tech/tools/markdown/:12:0","tags":["markdown"],"title":"Markdown 基本语法","uri":"/posts/tech/tools/markdown/"},{"categories":["Tech"],"content":"内联 ![Alt text](/path/img.jpg) 会被解释为 \u003cimg src='/path/to/img.jpg'/\u003e 这种格式显示图片不能控制对齐和大小，需要的话可以采取raw html的方法： \u003cp align=\"center\"\u003e \u003cimg src=\"https://i.loli.net/2021/01/31/4ZHoWduI59fiqJY.png\" width=\"100\" /\u003e \u003c/p\u003e 自适配图片 引用方式如下： 独库公路-雪山 ","date":"2018-05-06","objectID":"/posts/tech/tools/markdown/:13:0","tags":["markdown"],"title":"Markdown 基本语法","uri":"/posts/tech/tools/markdown/"},{"categories":["Tech"],"content":"外联 ![图片](https://www.baidu.com/img/PCtm_d9c8750bed0b3c7d089fa7d55720d6cf.png) ","date":"2018-05-06","objectID":"/posts/tech/tools/markdown/:14:0","tags":["markdown"],"title":"Markdown 基本语法","uri":"/posts/tech/tools/markdown/"},{"categories":["Tech"],"content":"refer Refer ","date":"2018-05-06","objectID":"/posts/tech/tools/markdown/:15:0","tags":["markdown"],"title":"Markdown 基本语法","uri":"/posts/tech/tools/markdown/"},{"categories":["Tech"],"content":"LoveIt 使用Algolia搜索 Hugo-LoveIt添加Algolia搜索 loveit支持两种搜索：lunr和algolia。 lunr性能实在堪忧，特别是对于中文而言基本上不能用。 因此我们选用algolia，社区版10000条（不知道是按什么计算的，反正肯定不是按文章）搜索项，每月10000次搜索，对于小网站来说也够用了。之后我打算抽空自己用微服务写一个，到时候和博客挂在一起。 操作： 前往官网注册账号algolia 在左侧第二个Indices下选择New，创建Index（我的名称为 blog ） 在API Keys上拿到Search-Only API Key作为searchKey和Application ID作为appID。 配置 config.toml 文件，如下： [params.search] enable = true type = \"algolia\" contentLength = 4000 placeholder = \"\" maxResultLength = 10 snippetLength = 50 highlightTag = \"em\" absoluteURL = false [params.search.algolia] index = \"blog\" appID = \"xxxx\" searchKey = \"xxxx\" [outputs] home = [\"HTML\", \"RSS\", \"JSON\"] # 这个一定要带上JSON，不然不会产生对应的JSON文件 每次 hugo 命令之后会产生/public/index.json文件，需要将这个文件上传到algolia中 ","date":"2017-08-14","objectID":"/posts/tech/hugo/hugo-search/:1:0","tags":["search","hugo"],"title":"Hugo Search","uri":"/posts/tech/hugo/hugo-search/"},{"categories":["Tech"],"content":"使用Algolia搜索支持 Hugo-Even ","date":"2017-08-14","objectID":"/posts/tech/hugo/hugo-search/:2:0","tags":["search","hugo"],"title":"Hugo Search","uri":"/posts/tech/hugo/hugo-search/"},{"categories":["Tech"],"content":"使用hugofastsearch hugofastsearch.md 当前仅支持搜索标题 ","date":"2017-08-14","objectID":"/posts/tech/hugo/hugo-search/:3:0","tags":["search","hugo"],"title":"Hugo Search","uri":"/posts/tech/hugo/hugo-search/"},{"categories":["Tech"],"content":"Setup Add index.json file to layouts/_default Add JSON as additional output format in config.toml Add fastsearch.js and fuse.js (downloaded from fusejs.io) to static/js Add searchbox html to bottom of layouts/_default/baseof.html Add css styles to your site’s main css file or top of baseof.html hugo Visit localhost:1313/ Press CMD-/ to invoke search You can check the json index by visiting localhost:1313/index.json ","date":"2017-08-14","objectID":"/posts/tech/hugo/hugo-search/:4:0","tags":["search","hugo"],"title":"Hugo Search","uri":"/posts/tech/hugo/hugo-search/"},{"categories":["Tech"],"content":"Detail ","date":"2017-08-14","objectID":"/posts/tech/hugo/hugo-search/:5:0","tags":["search","hugo"],"title":"Hugo Search","uri":"/posts/tech/hugo/hugo-search/"},{"categories":["Tech"],"content":"index.json layouts/_default/index.json Hugo already builds indexes of all pages, we can cherry-pick which aspects should be searchable. The result is a newly created JSON index at /index.json {{- $.Scratch.Add \"index\" slice -}} {{- range .Site.RegularPages -}} {{- $.Scratch.Add \"index\" (dict \"title\" .Title \"tags\" .Params.tags \"categories\" .Params.categories \"contents\" .Plain \"permalink\" .Permalink) -}} {{- end -}} {{- $.Scratch.Get \"index\" | jsonify -}} ","date":"2017-08-14","objectID":"/posts/tech/hugo/hugo-search/:5:1","tags":["search","hugo"],"title":"Hugo Search","uri":"/posts/tech/hugo/hugo-search/"},{"categories":["Tech"],"content":"Config.toml Add this snippet to your config file to instruct Hugo to create the index file in JSON format. (RSS and HTML are default outputs, what’s important is to add JSON. [outputs] home = [\"HTML\", \"RSS\", \"JSON\"] ","date":"2017-08-14","objectID":"/posts/tech/hugo/hugo-search/:5:2","tags":["search","hugo"],"title":"Hugo Search","uri":"/posts/tech/hugo/hugo-search/"},{"categories":["Tech"],"content":"static/js/fastsearch.js This “makes” the search engine based on the index.json file, and wires up all keyboard handling var fuse; // holds our search engine var searchVisible = false; var firstRun = true; // allow us to delay loading json data unless search activated var list = document.getElementById('searchResults'); // targets the \u003cul\u003e var first = list.firstChild; // first child of search list var last = list.lastChild; // last child of search list var maininput = document.getElementById('searchInput'); // input box for search var resultsAvailable = false; // Did we get any search results? // ========================================== // The main keyboard event listener running the show // document.addEventListener('keydown', function (event) { // CMD-/ to show / hide Search if (event.metaKey \u0026\u0026 event.which === 191) { // Load json search index if first time invoking search // Means we don't load json unless searches are going to happen; keep user payload small unless needed if (firstRun) { loadSearch(); // loads our json data and builds fuse.js search index firstRun = false; // let's never do this again } // Toggle visibility of search box if (!searchVisible) { document.getElementById(\"fastSearch\").style.visibility = \"visible\"; // show search box document.getElementById(\"searchInput\").focus(); // put focus in input box so you can just start typing searchVisible = true; // search visible } else { document.getElementById(\"fastSearch\").style.visibility = \"hidden\"; // hide search box document.activeElement.blur(); // remove focus from search box searchVisible = false; // search not visible } } // Allow ESC (27) to close search box if (event.keyCode == 27) { if (searchVisible) { document.getElementById(\"fastSearch\").style.visibility = \"hidden\"; document.activeElement.blur(); searchVisible = false; } } // DOWN (40) arrow if (event.keyCode == 40) { if (searchVisible \u0026\u0026 resultsAvailable) { console.log(\"down\"); event.preventDefault(); // stop window from scrolling if (document.activeElement == maininput) { first.focus(); } // if the currently focused element is the main input --\u003e focus the first \u003cli\u003e else if (document.activeElement == last) { last.focus(); } // if we're at the bottom, stay there else { document.activeElement.parentElement.nextSibling.firstElementChild.focus(); } // otherwise select the next search result } } // UP (38) arrow if (event.keyCode == 38) { if (searchVisible \u0026\u0026 resultsAvailable) { event.preventDefault(); // stop window from scrolling if (document.activeElement == maininput) { maininput.focus(); } // If we're in the input box, do nothing else if (document.activeElement == first) { maininput.focus(); } // If we're at the first item, go to input box else { document.activeElement.parentElement.previousSibling.firstElementChild.focus(); } // Otherwise, select the search result above the current active one } } }); // ========================================== // execute search as each character is typed // document.getElementById(\"searchInput\").onkeyup = function (e) { executeSearch(this.value); } // ========================================== // fetch some json without jquery // function fetchJSONFile(path, callback) { var httpRequest = new XMLHttpRequest(); httpRequest.onreadystatechange = function () { if (httpRequest.readyState === 4) { if (httpRequest.status === 200) { var data = JSON.parse(httpRequest.responseText); if (callback) callback(data); } } }; httpRequest.open('GET', path); httpRequest.send(); } // ========================================== // load our search index, only executed once // on first call of search box (CMD-/) // function loadSearch() { fetchJSONFile('/index.json', function (data) { var options = { // fuse.js options; check fuse.js website for details shouldSort: true, location: 0, distance: 100, threshold: 0.4, minMatchCharLength: 2, keys: [ 'title', 'permalink', 'summary' ] }; fuse = new Fuse(data, options); // build the index from the json file }); } // ============================","date":"2017-08-14","objectID":"/posts/tech/hugo/hugo-search/:5:3","tags":["search","hugo"],"title":"Hugo Search","uri":"/posts/tech/hugo/hugo-search/"},{"categories":["Tech"],"content":"static/js/fuse.js fuse.js (downloaded from fusejs.io )) to static/js ","date":"2017-08-14","objectID":"/posts/tech/hugo/hugo-search/:5:4","tags":["search","hugo"],"title":"Hugo Search","uri":"/posts/tech/hugo/hugo-search/"},{"categories":["Tech"],"content":"baseof.html Add this block to the bottom of your baseof.html file, just before the footer \u003cdiv id=\"fastSearch\"\u003e \u003cinput id=\"searchInput\" tabindex=\"0\"\u003e \u003cul id=\"searchResults\"\u003e \u003c/ul\u003e \u003c/div\u003e \u003cscript src=\"/js/fuse.js\"\u003e\u003c/script\u003e \u003c!-- download and copy over fuse.js file from fusejs.io --\u003e \u003cscript src=\"/js/fastsearch.js\"\u003e\u003c/script\u003e CSS Styling Add css styles to your site’s main css file or top of baseof.html #fastSearch { visibility: hidden; position: absolute; right: 0px; top: 0px; display: inline-block; width: 300px; } #fastSearch input { padding: 4px 10px; width: 100%; height: 31px; font-size: 1.6em; color: #aaa; font-weight: bold; background-color: #000; border-radius: 3px 3px 0px 0px; border: none; outline: none; text-align: left; display: inline-block; } #searchResults li { list-style: none; margin-left: 0em; background-color: #aaa; border-bottom: 1px dotted #000; } #searchResults li .title { font-size: 1.1em; margin-bottom: 10px; display: inline-block;} #searchResults { visibility: inherit; display: inline-block; width: 320px; } #searchResults a { text-decoration: none !important; padding: 10px; display: inline-block; } #searchResults a:hover, a:focus { outline: 0; background-color: #666; color: #fff; } ","date":"2017-08-14","objectID":"/posts/tech/hugo/hugo-search/:5:5","tags":["search","hugo"],"title":"Hugo Search","uri":"/posts/tech/hugo/hugo-search/"},{"categories":["Tech"],"content":"Hugo如何添加about页 ","date":"2017-07-13","objectID":"/posts/tech/hugo/hugo-config/:1:0","tags":["hugo"],"title":"Hugo配置","uri":"/posts/tech/hugo/hugo-config/"},{"categories":["Tech"],"content":"创建页面 此处以even模板为例 hugo new post/about.md 文件创建完成后，会生成在 ${根目录}/content/post/目录下； 将about.md上移一层，到${根目录}/content/下, 和post目录同级。 ","date":"2017-07-13","objectID":"/posts/tech/hugo/hugo-config/:1:1","tags":["hugo"],"title":"Hugo配置","uri":"/posts/tech/hugo/hugo-config/"},{"categories":["Tech"],"content":"修改配置 修改根目录文件config.toml，新增如下配置 [[menu.main]] name = \"关于\" identifier = \"about\" url = \"/about/\" weight = 50 weight 根据menu的顺序自定义数字即可； ","date":"2017-07-13","objectID":"/posts/tech/hugo/hugo-config/:1:2","tags":["hugo"],"title":"Hugo配置","uri":"/posts/tech/hugo/hugo-config/"},{"categories":["Tech"],"content":"启动服务 hugo server -D 访问：http://localhost:1313 即可查看效果； ","date":"2017-07-13","objectID":"/posts/tech/hugo/hugo-config/:1:3","tags":["hugo"],"title":"Hugo配置","uri":"/posts/tech/hugo/hugo-config/"},{"categories":["Tech"],"content":"Hugo添加文章目录toc config.toml中加上toc的显示控制变量. toc = true ","date":"2017-07-13","objectID":"/posts/tech/hugo/hugo-config/:2:0","tags":["hugo"],"title":"Hugo配置","uri":"/posts/tech/hugo/hugo-config/"},{"categories":["Tech"],"content":"访问计数 如下配置 [params] [params.busuanzi] ## count web traffic by busuanzi ## 是否使用不蒜子统计站点访问量 enable = true siteUV = true sitePV = true pagePV = true ","date":"2017-07-13","objectID":"/posts/tech/hugo/hugo-config/:3:0","tags":["hugo"],"title":"Hugo配置","uri":"/posts/tech/hugo/hugo-config/"},{"categories":["Tech"],"content":"评论 [params.utteranc] ## https://utteranc.es/ enable = true repo = \"lovelock/blog-comments\" ## The repo to store comments issueTerm = \"pathname\" ##表示你选择以那种方式让github issue的评论和你的文章关联。 theme = \"github-light\" ## 样式主题，有github-light和github-dark两种 async = true ","date":"2017-07-13","objectID":"/posts/tech/hugo/hugo-config/:4:0","tags":["hugo"],"title":"Hugo配置","uri":"/posts/tech/hugo/hugo-config/"},{"categories":["Tech"],"content":"Emoji 表情 支持 Emoji 可以通过多种方式在 Hugo 项目中启用. emojify 方法可以直接在模板中调用, 或者使用行内 Shortcodes. 要全局使用 emoji, 需要在你的网站配置中设置 enableEmoji 为 true, 然后你就可以直接在文章中输入 emoji 的代码. 它们以冒号开头和结尾，并且包含 emoji 的 代码: 去露营啦! ⛺ 很快就回来. 真开心! 😂 去露营啦! ⛺ 很快就回来. 真开心! 😂 Emoji 支持 ","date":"2017-07-13","objectID":"/posts/tech/hugo/hugo-config/:5:0","tags":["hugo"],"title":"Hugo配置","uri":"/posts/tech/hugo/hugo-config/"},{"categories":["Tech"],"content":"其他 ","date":"2017-07-13","objectID":"/posts/tech/hugo/hugo-config/:6:0","tags":["hugo"],"title":"Hugo配置","uri":"/posts/tech/hugo/hugo-config/"},{"categories":["Tech"],"content":"统计 hugo不蒜子统计数量 ","date":"2017-07-13","objectID":"/posts/tech/hugo/hugo-config/:6:1","tags":["hugo"],"title":"Hugo配置","uri":"/posts/tech/hugo/hugo-config/"},{"categories":["Tech"],"content":"增强 https://lewky.cn/posts/hugo-3.2.html/ ","date":"2017-07-13","objectID":"/posts/tech/hugo/hugo-config/:6:2","tags":["hugo"],"title":"Hugo配置","uri":"/posts/tech/hugo/hugo-config/"},{"categories":["Tech"],"content":"文章总数展示 参见 官方doc 新增文章总数 对于 LoveIt 主题，在LoveIt/layouts/_default/section.html中，新增一行code 共 {{ len (where .Site.RegularPages \"Section\" \"posts\") }} 篇文章 如下： {{- define \"content\" -}} \u003cdiv class=\"page archive\"\u003e {{- /* Title */ -}} \u003ch2 class=\"single-title animate__animated animate__pulse animate__faster\"\u003e {{- .Params.Title | default (T .Section) | default .Section | dict \"Some\" | T \"allSome\" -}} \u003c/h2\u003e 共 {{ len (where .Site.RegularPages \"Section\" \"posts\") }} 篇文章 {{- /* Paginate */ -}} ..... ","date":"2017-07-13","objectID":"/posts/tech/hugo/hugo-config/:6:3","tags":["hugo"],"title":"Hugo配置","uri":"/posts/tech/hugo/hugo-config/"},{"categories":["Tech"],"content":"文章列表页置顶 使用weight标识符，如下示例： title: \"心灵鸡汤\" date: 2021-01-03T20:19:50+08:00 draft: false tags: [\"励志\"] categories: [\"生活\"] weight: 1 ","date":"2017-07-13","objectID":"/posts/tech/hugo/hugo-config/:6:4","tags":["hugo"],"title":"Hugo配置","uri":"/posts/tech/hugo/hugo-config/"},{"categories":["Tech"],"content":"github 自动部署, refer to : Hugo 白话文 | GitHub Action 自动部署 基于 Github Action 自动构建 Hugo 博客 ","date":"2017-05-13","objectID":"/posts/tech/github/githubaction/:0:0","tags":["github","hugo"],"title":"Github Pages Action","uri":"/posts/tech/github/githubaction/"},{"categories":["Tech"],"content":"document ","date":"2017-05-13","objectID":"/posts/tech/github/githubaction/:1:0","tags":["github","hugo"],"title":"Github Pages Action","uri":"/posts/tech/github/githubaction/"},{"categories":["Tech"],"content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. ","date":"2017-05-05","objectID":"/posts/tech/hugo/tools-hexo/:0:0","tags":["hugo"],"title":"hexo demo","uri":"/posts/tech/hugo/tools-hexo/"},{"categories":["Tech"],"content":"Quick Start ","date":"2017-05-05","objectID":"/posts/tech/hugo/tools-hexo/:1:0","tags":["hugo"],"title":"hexo demo","uri":"/posts/tech/hugo/tools-hexo/"},{"categories":["Tech"],"content":"Create a new post $ hexo new \"My New Post\" More info: Writing ","date":"2017-05-05","objectID":"/posts/tech/hugo/tools-hexo/:1:1","tags":["hugo"],"title":"hexo demo","uri":"/posts/tech/hugo/tools-hexo/"},{"categories":["Tech"],"content":"Run server $ hexo server More info: Server ","date":"2017-05-05","objectID":"/posts/tech/hugo/tools-hexo/:1:2","tags":["hugo"],"title":"hexo demo","uri":"/posts/tech/hugo/tools-hexo/"},{"categories":["Tech"],"content":"Generate static files $ hexo generate More info: Generating ","date":"2017-05-05","objectID":"/posts/tech/hugo/tools-hexo/:1:3","tags":["hugo"],"title":"hexo demo","uri":"/posts/tech/hugo/tools-hexo/"},{"categories":["Tech"],"content":"Deploy to remote sites $ hexo deploy More info: Deployment ","date":"2017-05-05","objectID":"/posts/tech/hugo/tools-hexo/:1:4","tags":["hugo"],"title":"hexo demo","uri":"/posts/tech/hugo/tools-hexo/"},{"categories":["Tech"],"content":"refer to GitHub Pages + Hexo搭建个人博客网站，史上最全教程 https://blog.csdn.net/yaorongke/article/details/119089190 ","date":"2017-05-05","objectID":"/posts/tech/hugo/tools-hexo/:2:0","tags":["hugo"],"title":"hexo demo","uri":"/posts/tech/hugo/tools-hexo/"},{"categories":["Tech"],"content":"setup node js 验证 安装完成后打开终端输入 npm -v node -v 出现版本信息，说明安装成功 refer to: https://blog.csdn.net/qq_45220508/article/details/122972391 ","date":"2017-05-05","objectID":"/posts/tech/hugo/tools-hexo/:2:1","tags":["hugo"],"title":"hexo demo","uri":"/posts/tech/hugo/tools-hexo/"},{"categories":["Tech"],"content":"setup Hexo 1. 输入npm i hexo-cli -g安装Hexo; 若提示权限不足，使用sudo 开头 2. 输入hexo -v验证是否安装成功。 3. 输入hexo g生成静态网页 4. 输入hexo s打开本地服务器，浏览器打开http://localhost:4000/ 5. 按ctrl+c关闭本地服务器。 ","date":"2017-05-05","objectID":"/posts/tech/hugo/tools-hexo/:2:2","tags":["hugo"],"title":"hexo demo","uri":"/posts/tech/hugo/tools-hexo/"},{"categories":["Tech"],"content":"写文章、发布文章 首先在博客根目录下右键打开git bash，安装一个扩展npm i hexo-deployer-git 然后输入 hexo new post “article title”，新建一篇文章。 然后打开D:\\study\\program\\blog\\source_posts的目录，可以发现下面多了一个文件夹和一个.md文件，一个用来存放你的图片等数据，另一个就是你的文章文件啦。 编写完markdown文件后， 然后输入hexo s可以本地预览效果，最后输入hexo d上传到github上。这时打开你的github.io主页就能看到发布的文章啦 github 上有很多theme ，search keyword： hexo-theme 不同的hexo theme，先下载them到project的themes包中，然后copy修改_config.yml（不同的themes 对应不同的_config.yml）。 ","date":"2017-05-05","objectID":"/posts/tech/hugo/tools-hexo/:2:3","tags":["hugo"],"title":"hexo demo","uri":"/posts/tech/hugo/tools-hexo/"}]