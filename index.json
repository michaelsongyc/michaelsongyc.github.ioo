[{"categories":["生活"],"content":" 加油，把刷题变成打游戏一样的兴趣。 天道酬勤，凡事感激. 编程能力就像任何其他技能一样，也是一个可以通过 刻意练习 大大提高的。 大多数经典面试题目都有多种解决方案。 为了达到最佳的练习效果，我们强烈建议您至少将此清单里的题目练习两遍，如果可以的话，三遍会更好。 在第二遍练习时，你可能会发现一些新的技巧或新的方法。 到第三遍的时候，你会发现你的代码要比第一次提交时更加简洁。 如果你达到了这样的效果，那么恭喜你，你已经掌握了正确的练习方法！ 记住：刻意练习并不意味着寻找答案并记住它，这种练习方法不是长久之计。 在没有参考答案情况下，越能自主解决问题，才越能提高自身能力。 北大通知书 假如北大在你高一的时候就给你发了一张录取通知书，但是要想得到它的话，你需要在高中三年满足以下六个条件，你答应还是不答应？ 第一，每天早晨05:40起床，唤醒大脑，坚持晨读。 第二，每天坚持背50个单词。 第三，每天坚持复习昨天学过的内容。 第四，每周末坚持整理本周的数理化错题。 第五，经常思考学过的知识点，它背后的逻辑没有掌握好，就去重新学习。 第六，每天抽时间做体育锻炼。 等到三年以后，你只要满足以上条件，那这张录取通知书就生效，你愿意答应吗？ 我想你心中已经有了答案，但其实如果你三年能够坚持做到这六点事儿，完全可以自己考上北大。 ","date":"2022-08-16","objectID":"/posts/life/sentence/:0:0","tags":["励志"],"title":"心灵鸡汤","uri":"/posts/life/sentence/"},{"categories":["leetcode"],"content":"1-容易-两数之和 1-容易-两数之和 给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标。 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。 你可以按任意顺序返回答案。 class Solution { public int[] twoSum(int[] nums, int target) { Map\u003cInteger/*value*/, Integer/*index*/\u003e map = new HashMap\u003c\u003e(); for (int i = 0; i \u003c nums.length; i++) { if (map.containsKey(target - nums[i])) { return new int[]{map.get(target - nums[i]), i}; } // map.put(nums[i], i); 一定放到if后面，不然就会可能存在 mums[i]+i=target, i是自己 map.put(nums[i], i); } return null; } } ","date":"2022-09-10","objectID":"/posts/tech/leetcode/collect/:1:0","tags":["综合","leetcode"],"title":"算法-搜集","uri":"/posts/tech/leetcode/collect/"},{"categories":["leetcode"],"content":"7-中等-整数反转 7-中等-整数反转 给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。 如果反转后整数超过 32 位的有符号整数的范围 [−231, 231 − 1] ，就返回 0。 假设环境不允许存储 64 位整数（有符号或无符号）。 class Solution { public int reverse(int x) { int result = 0; while (x != 0) { //边界值判定，防止integer溢出 if (result \u003e Integer.MAX_VALUE / 10 || result \u003c Integer.MIN_VALUE / 10) { return 0; } int n = x % 10; result = result * 10 + n; x = x / 10; } return result; } } ","date":"2022-09-10","objectID":"/posts/tech/leetcode/collect/:2:0","tags":["综合","leetcode"],"title":"算法-搜集","uri":"/posts/tech/leetcode/collect/"},{"categories":["leetcode"],"content":"8-简单-字符串转换整数 (atoi) 8-简单-字符串转换整数 (atoi) 请你来实现一个 myAtoi(string s) 函数，使其能将字符串转换成一个 32 位有符号整数（类似 C/C++ 中的 atoi 函数）。 函数 myAtoi(string s) 的算法如下： 读入字符串并丢弃无用的前导空格 检查下一个字符（假设还未到字符末尾）为正还是负号，读取该字符（如果有）。 确定最终结果是负数还是正数。 如果两者都不存在，则假定结果为正。 读入下一个字符，直到到达下一个非数字字符或到达输入的结尾。字符串的其余部分将被忽略。 将前面步骤读入的这些数字转换为整数（即，“123” -\u003e 123， “0032” -\u003e 32）。如果没有读入数字，则整数为 0 。必要时更改符号（从步骤 2 开始）。 如果整数数超过 32 位有符号整数范围 [−231, 231 − 1] ，需要截断这个整数，使其保持在这个范围内。具体来说，小于 −231 的整数应该被固定为 −231 ，大于 231 − 1 的整数应该被固定为 231 − 1 。 返回整数作为最终结果。 注意： 本题中的空白字符只包括空格字符 ’ ’ 。 除前导空格或数字后的其余字符串外，请勿忽略 任何其他字符。 class Solution { /** * 1.删除开头空白字符 * 2.排除全部为空的极端case * 3.设置符号 * 4.超出integer上下边界处理 */ public int myAtoi(String s) { char[] arrays = s.toCharArray(); int index = 0; // 1、去除前导空格 while (index \u003c arrays.length \u0026\u0026 arrays[index] == ' ') { index++; } // 2、如果已经遍历完成（针对极端用例 \" \"） if (index == arrays.length) { return 0; } //3.判断符号, 如果出现符号字符，仅第 1 个有效，并记录正负 int sign = 1; char firstChar = arrays[index]; if (firstChar == '+') { index++; } else if (firstChar == '-') { sign = -1; index++; } // 4、将后续出现的数字字符进行转换 // 不能使用 long 类型，这是题目说的 int result = 0; while (index \u003c arrays.length) { char currChar = arrays[index]; // 4.1 先判断不合法的情况 如\"+-42\" if (currChar \u003c '0' || currChar \u003e '9') { break; } //integer 边界值判断 if (result \u003e Integer.MAX_VALUE / 10 || (result == Integer.MAX_VALUE / 10 \u0026\u0026 (currChar - '0') \u003e Integer.MAX_VALUE % 10)) { return Integer.MAX_VALUE; } //注意为 -(Integer.MIN_VALUE % 10) 而不是 -Integer.MIN_VALUE % 10 ; 需要加括号 if (result \u003c Integer.MIN_VALUE / 10 || (result == Integer.MIN_VALUE / 10 \u0026\u0026 (currChar - '0') \u003e -(Integer.MIN_VALUE % 10))) { return Integer.MIN_VALUE; } //注意 (currChar-'0') result = result * 10 + (currChar - '0') * sign; index++; } return result; } } ","date":"2022-09-10","objectID":"/posts/tech/leetcode/collect/:3:0","tags":["综合","leetcode"],"title":"算法-搜集","uri":"/posts/tech/leetcode/collect/"},{"categories":["leetcode"],"content":"14-简单-最长公共前缀 14-简单-最长公共前缀 编写一个函数来查找字符串数组中的最长公共前缀。 如果不存在公共前缀，返回空字符串 “\"。 class Solution { /** * 横向扫描 */ public String longestCommonPrefix(String[] strs) { if (strs == null || strs.length == 0) { return \"\"; } //取数组第1个值作为预比较对象 String preStr = strs[0]; //注意此处循环 从1开始； for (int i = 1; i \u003c strs.length; i++) { preStr = compare(strs[i], preStr); if (preStr.length() == 0) { break; } } return preStr; } public String compare(String s1, String s2) { int len = Math.min(s1.length(), s2.length()); int index = 0; while (index \u003c len \u0026\u0026 s1.charAt(index) == s2.charAt(index)) { index++; } return s1.substring(0, index); } } ","date":"2022-09-10","objectID":"/posts/tech/leetcode/collect/:4:0","tags":["综合","leetcode"],"title":"算法-搜集","uri":"/posts/tech/leetcode/collect/"},{"categories":["leetcode"],"content":"19-中等-单链表的倒数第 k 个节点 19-中等-单链表的倒数第 k 个节点 给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。 class Solution { /** * 法1：双指针，单次链表遍历 */ public ListNode removeNthFromEnd(ListNode head, int n) { // 虚拟头结点 ListNode dump = new ListNode(0); //注意此处 dump.next = head; // 删除倒数第 n 个，先找倒数第 n + 1 个节点 [注意此处 为n+1] ListNode objNode = findFromEnd(dump, n + 1); // 删掉倒数第 n 个节点 objNode.next = objNode.next.next; return dump.next; } // 返回链表的倒数第 n 个节点 public ListNode findFromEnd(ListNode head, int n) { ListNode p1 = head; // p1 先走 n 步 for (int i = 0; i \u003c n; i++) { p1 = p1.next; } ListNode p2 = head; // p1 和 p2 同时走 len - k 步 while (p1 != null) { p1 = p1.next; p2 = p2.next; } // p2 现在指向第 len - n + 1 个节点，即倒数第 n 个节点 return p2; } /** * 法2：2次链表遍历； 先循环查询链表总长度，在走到特定节点，操作； */ public ListNode removeNthFromEnd2(ListNode head, int n) { ListNode dummy = new ListNode(0, head); int length = getLength(head); ListNode cur = dummy; for (int i = 1; i \u003c length - n + 1; ++i) { cur = cur.next; } cur.next = cur.next.next; //注意：此处return不能是cur.next，原因？ return dummy.next; // ListNode ans = dummy.next; // return ans; } public int getLength(ListNode head) { int length = 0; while (head != null) { ++length; head = head.next; } return length; } } ","date":"2022-09-10","objectID":"/posts/tech/leetcode/collect/:5:0","tags":["综合","leetcode"],"title":"算法-搜集","uri":"/posts/tech/leetcode/collect/"},{"categories":["leetcode"],"content":"20-简单-有效的括号 20-简单-有效的括号 给定一个只包括 ‘(’，’)’，’{’，’}’，’[’，’]’ 的字符串 s ，判断字符串是否有效。 有效字符串需满足： 左括号必须用相同类型的右括号闭合。 左括号必须以正确的顺序闭合。 每个右括号都有一个对应的相同类型的左括号。 class Solution { public boolean isValid(String s) { Stack\u003cCharacter\u003e stack = new Stack\u003c\u003e(); for (char c : s.toCharArray()) { if (c == '(' || c == '{' || c == '[') { stack.push(c); } else { // 字符 c 是右括号 if (!stack.isEmpty() \u0026\u0026 stack.peek() == queryMatch(c)) { stack.pop(); }else{ // 和最近的左括号不匹配 return false; } } } // 是否所有的左括号都被匹配了 return stack.isEmpty(); } public Character queryMatch(Character c) { if (c == ')') { return '('; } if (c == ']') { return '['; } if (c == '}') { return '{'; } return null; } } ","date":"2022-09-10","objectID":"/posts/tech/leetcode/collect/:6:0","tags":["综合","leetcode"],"title":"算法-搜集","uri":"/posts/tech/leetcode/collect/"},{"categories":["leetcode"],"content":"21-简单-合并两个有序链表 21-简单-合并两个有序链表 将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 class Solution { /** * 法1- 迭代 * 参见讲解 * https://www.bilibili.com/video/BV1pZ4y1Y76v?spm_id_from=333.337.search-card.all.click */ public ListNode mergeTwoLists(ListNode list1, ListNode list2) { //定义新链表作为结果链表，首节点为哑结点，虚拟头结点 ListNode dump = new ListNode(0); //定义新链表的当前节点，也可以理解为尾部节点，作为指针参与和其他数值做比较运算 ListNode cur = dump; while (list1 != null \u0026\u0026 list2 != null) { // 比较 list1 和 list2 两个指针 // 将值较小的的节点接到 cur 指针 if (list2.val \u003e list1.val) { cur.next = list1; list1 = list1.next; } else { cur.next = list2; list2 = list2.next; } // cur 指针不断前进 cur = cur.next; } cur.next = (list1 == null) ? list2 : list1; return dump.next; } } /** * 法2- 递归调用 */ public ListNode mergeTwoLists(ListNode l1, ListNode l2) { if (l1 == null) { return l2; } else if (l2 == null) { return l1; } else if (l1.val \u003c l2.val) { l1.next = mergeTwoLists(l1.next, l2); return l1; } else { l2.next = mergeTwoLists(l1, l2.next); return l2; } } ","date":"2022-09-10","objectID":"/posts/tech/leetcode/collect/:7:0","tags":["综合","leetcode"],"title":"算法-搜集","uri":"/posts/tech/leetcode/collect/"},{"categories":["leetcode"],"content":"23-困难-合并 k 个有序链表 23-困难-合并 k 个有序链表 给你一个链表数组，每个链表都已经按升序排列。 请你将所有链表合并到一个升序链表中，返回合并后的链表。 class Solution { /** * 法1: 使用优先队列合并 */ public ListNode mergeKLists(ListNode[] lists) { if (lists.length == 0) { return null; } //使用排序队列 PriorityQueue\u003cListNode\u003e pq = new PriorityQueue\u003c\u003e(lists.length, (a, b) -\u003e a.val - b.val); for (int i = 0; i \u003c lists.length; i++) { if (lists[i] != null) { pq.add(lists[i]); } } ListNode dump = new ListNode(0); ListNode cur = dump; while (!pq.isEmpty()) { ListNode node = pq.poll(); cur.next = node; cur = cur.next; if (node.next != null) { pq.add(node.next); } } return dump.next; } /** * 法2: 顺序合并 */ public ListNode mergeKLists(ListNode[] lists) { if (lists.length == 0) { return null; } ListNode ans = null; for (int i = 0; i \u003c lists.length; i++) { // mergeTwoLists 参照合并两个有序链表的解法 ans = mergeTwoLists(ans, lists[i]); } return ans; } } ","date":"2022-09-10","objectID":"/posts/tech/leetcode/collect/:8:0","tags":["综合","leetcode"],"title":"算法-搜集","uri":"/posts/tech/leetcode/collect/"},{"categories":["leetcode"],"content":"28-简单-实现 strStr() 28-简单-实现 strStr() 给你两个字符串haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串出现的第一个位置（下标从 0 开始）。如果不存在，则返回 -1 。 class Solution { /** * 法1： 朴素解法-匹配-代码优化 */ public int strStr(String haystack, String needle) { int len = haystack.length(); int lengthNeeded = needle.length(); for (int i = 0; i \u003c= len - lengthNeeded; i++) { int a = i; int b = 0; //注意边界判定 b\u003clengthNeeded while (b\u003clengthNeeded \u0026\u0026 haystack.charAt(a) == needle.charAt(b)) { a++; b++; } if (b == lengthNeeded) { return i; } } return -1; } /** * KMP 解法 */ public int strStr2(String haystack, String needle) { } /** * 暴力解法 */ public int strStr3(String haystack, String needle) { if (needle.length() == 0 || needle.length() \u003e haystack.length()) { return -1; } int objLength = needle.length(); int left = 0, right = left + objLength - 1; while (right \u003c haystack.length()) { if (compare(haystack, needle, left, right)) { break; } left++; right = left + objLength - 1; } return left != -1 ? left : -1; } public boolean compare(String haystack, String needle, int start, int end) { int i = 0; boolean result = true; while (start \u003c= end) { if (haystack.charAt(start++) != needle.charAt(i++)) { result = false; break; } } return result; } } ","date":"2022-09-10","objectID":"/posts/tech/leetcode/collect/:9:0","tags":["综合","leetcode"],"title":"算法-搜集","uri":"/posts/tech/leetcode/collect/"},{"categories":["leetcode"],"content":"66-简单-加一 66-简单-加一 给定一个由 整数 组成的 非空 数组所表示的非负整数，在该数的基础上加一。 最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。 你可以假设除了整数 0 之外，这个整数不会以零开头。 class Solution { /** * 不用纠结某一位是不是9，而应该去判断加1之后是不是0 */ public int[] plusOne(int[] digits) { int len = digits.length; for (int i = len - 1; i \u003e= 0; i--) { //每一位数，加1 digits[i] = (digits[i] + 1) % 10; //若为+1后为0，则进行下一循环，继续+1 if (digits[i] != 0) { return digits; } } //此时，digits内数值已均为0 //对所有为均为9的特殊情况 digits = new int[len + 1]; digits[0] = 1; return digits; } } ","date":"2022-09-10","objectID":"/posts/tech/leetcode/collect/:10:0","tags":["综合","leetcode"],"title":"算法-搜集","uri":"/posts/tech/leetcode/collect/"},{"categories":["leetcode"],"content":"83-简单-删除排序链表中的重复元素 83-简单-删除排序链表中的重复元素 给定一个已排序的链表的头 head ， 删除所有重复的元素，使每个元素只出现一次 。返回 已排序的链表 。 ListNode deleteDuplicates(ListNode head) { if (head == null) return null; ListNode slow = head, fast = head; while (fast != null) { if (fast.val != slow.val) { // nums[slow] = nums[fast]; slow.next = fast; // slow++; slow = slow.next; } // fast++ fast = fast.next; } // 断开与后面重复元素的连接 slow.next = null; return head; } ","date":"2022-09-10","objectID":"/posts/tech/leetcode/collect/:11:0","tags":["综合","leetcode"],"title":"算法-搜集","uri":"/posts/tech/leetcode/collect/"},{"categories":["leetcode"],"content":"86-中等-单链表的分解 86-中等-单链表的分解 给你一个链表的头节点 head 和一个特定值 x ，请你对链表进行分隔，使得所有 小于 x 的节点都出现在 大于或等于 x 的节点之前。 你应当 保留 两个分区中每个节点的初始相对位置。 class Solution { public ListNode partition(ListNode head, int x) { // 存放小于 x 的链表的虚拟头结点 ListNode dump1 = new ListNode(0); // 存放大于等于 x 的链表的虚拟头结点 ListNode dump2 = new ListNode(0); // cur1, cur2 指针负责生成结果链表 ListNode cur1 = dump1; ListNode cur2 = dump2; // 遍历原链表，类似合并两个有序链表的逻辑 // 这里是将一个链表分解成两个链表 while (head != null) { if (head.val \u003c x) { cur1.next = head; cur1 = cur1.next; } else { cur2.next = head; cur2 = cur2.next; } // 断开原链表中的每个节点的 next 指针 ??? 没理解 ！！！ ListNode tmp = head.next; head.next = null; head = tmp; } // 连接两个链表 cur1.next = dump2.next; return dump1.next; } } ","date":"2022-09-10","objectID":"/posts/tech/leetcode/collect/:12:0","tags":["综合","leetcode"],"title":"算法-搜集","uri":"/posts/tech/leetcode/collect/"},{"categories":["leetcode"],"content":"92-中等-反转链表 II 92-中等-反转链表 II 给你单链表的头指针 head 和两个整数 left 和 right ，其中 left \u003c= right 。请你反转从位置 left 到位置 right 的链表节点，返回 反转后的链表 。 1 ","date":"2022-09-10","objectID":"/posts/tech/leetcode/collect/:13:0","tags":["综合","leetcode"],"title":"算法-搜集","uri":"/posts/tech/leetcode/collect/"},{"categories":["leetcode"],"content":"104-简单-二叉树的最大深度 104-简单-二叉树的最大深度 给定一个二叉树，找出其最大深度。 二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。 说明: 叶子节点是指没有子节点的节点。 /** * 递归解法 */ public int maxDepth(TreeNode root) { //当root为0是，则代表tree不存在 if (root == null) { return 0; } // 利用定义，计算左右子树的最大深度 int maxLeft = maxDepth(root.left); int maxRight = maxDepth(root.right); // 整棵树的最大深度等于左右子树的最大深度取最大值， // 然后再加上根节点自己 return Math.max(maxLeft, maxRight) + 1; } ","date":"2022-09-10","objectID":"/posts/tech/leetcode/collect/:14:0","tags":["综合","leetcode"],"title":"算法-搜集","uri":"/posts/tech/leetcode/collect/"},{"categories":["leetcode"],"content":"106-简单-相交链表 106-简单-相交链表 给定一个头结点为 head 的非空单链表，返回链表的中间结点。 如果有两个中间结点，则返回第二个中间结点。 public class Solution { /** * 方法1 ： 双指针 On (a+b) */ public ListNode getIntersectionNode(ListNode headA, ListNode headB) { // p1 指向 A 链表头结点，p2 指向 B 链表头结点 ListNode p1 = headA, p2 = headB; while (p1 != p2) { // p1 走一步，如果走到 A 链表末尾，转到 B 链表 if (p1 == null) { p1 = headB; } else { p1 = p1.next; } // p2 走一步，如果走到 B 链表末尾，转到 A 链表 if (p2 == null) { p2 = headA; } else { p2 = p2.next; } } return p1; } /** * 方法2 哈希 */ public ListNode getIntersectionNode2(ListNode headA, ListNode headB) { Set\u003cListNode\u003e set = new HashSet\u003c\u003e(); ListNode temp = headA; while (temp != null) { set.add(temp); temp = temp.next; } temp = headB; while (temp != null) { if (set.contains(temp)) { return temp; } temp = temp.next; } return null; } } ","date":"2022-09-10","objectID":"/posts/tech/leetcode/collect/:15:0","tags":["综合","leetcode"],"title":"算法-搜集","uri":"/posts/tech/leetcode/collect/"},{"categories":["leetcode"],"content":"114-中等-将二叉树展开为链表 114-中等-将二叉树展开为链表 给你二叉树的根结点 root ，请你将它展开为一个单链表： 展开后的单链表应该同样使用 TreeNode ，其中 right 子指针指向链表中下一个结点，而左子指针始终为 null 。 展开后的单链表应该与二叉树 先序遍历 顺序相同。 class Solution { // 定义：将以 root 为根的树拉平为链表 void flatten(TreeNode root) { // base case if (root == null) return; // 利用定义，把左右子树拉平 flatten(root.left); flatten(root.right); /**** 后序遍历位置 ****/ // 1、左右子树已经被拉平成一条链表 TreeNode left = root.left; TreeNode right = root.right; // 2、将左子树作为右子树 root.left = null; root.right = left; // 3、将原先的右子树接到当前右子树的末端 TreeNode p = root; while (p.right != null) { p = p.right; } p.right = right; } } ","date":"2022-09-10","objectID":"/posts/tech/leetcode/collect/:16:0","tags":["综合","leetcode"],"title":"算法-搜集","uri":"/posts/tech/leetcode/collect/"},{"categories":["leetcode"],"content":"116-中等-填充节点的右侧指针 116-中等-填充节点的右侧指针 给定一个 完美二叉树 ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下： struct Node { int val; Node *left; Node *right; Node *next; } 填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。 初始状态下，所有 next 指针都被设置为 NULL。 来源：力扣（LeetCode） 链接：https://leetcode.cn/problems/populating-next-right-pointers-in-each-node 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 class Solution { /** * 法1：层次遍历 */ public Node connect(Node root) { if (root == null) { return root; } // 初始化队列同时将第一层节点加入队列中，即根节点 Queue\u003cNode\u003e queue = new LinkedList\u003cNode\u003e(); queue.add(root); // 外层的 while 循环迭代的是层数 while (!queue.isEmpty()) { // 记录当前队列大小 int size = queue.size(); // 遍历这一层的所有节点 for (int i = 0; i \u003c size; i++) { // 从队首取出元素 Node node = queue.poll(); // 连接 if (i \u003c size - 1) { node.next = queue.peek(); } // 拓展下一层节点 if (node.left != null) { queue.add(node.left); } if (node.right != null) { queue.add(node.right); } } } // 返回根节点 return root; } /** * 法2：三叉树 解法 * 1. 连接相同父节点的两个子节点 * 2. 连接跨越父节点的两个子节点 */ public Node connect2(Node root) { if (root == null) { return null; } traverse(root.left, root.right); return root; } /** * 三叉树遍历框架 */ public void traverse(Node node1, Node node2) { if (node1 == null || node2 == null) { return; } /**** 前序位置 ****/ // 将传入的两个节点穿起来 node1.next = node2; // 连接相同父节点的两个子节点 traverse(node1.left, node1.right); traverse(node2.left, node2.right); // 连接跨越父节点的两个子节点 traverse(node1.right, node2.left); } } ","date":"2022-09-10","objectID":"/posts/tech/leetcode/collect/:17:0","tags":["综合","leetcode"],"title":"算法-搜集","uri":"/posts/tech/leetcode/collect/"},{"categories":["leetcode"],"content":"125-简单-验证回文串 125-简单-验证回文串 如果在将所有大写字符转换为小写字符、并移除所有非字母数字字符之后，短语正着读和反着读都一样。则可以认为该短语是一个 回文串 。 字母和数字都属于字母数字字符。 给你一个字符串 s，如果它是 回文串 ，返回 true ；否则，返回 false 。 class Solution { /** * 左右双指针 */ public boolean isPalindrome(String s) { int n = s.length(); int left = 0, right = n - 1; while (left \u003c right) { while (left \u003c right \u0026\u0026 !Character.isLetterOrDigit(s.charAt(left))) { ++left; } while (left \u003c right \u0026\u0026 !Character.isLetterOrDigit(s.charAt(right))) { --right; } if (left \u003c right) { if (Character.toLowerCase(s.charAt(left)) != Character.toLowerCase(s.charAt(right))) { return false; } ++left; --right; } } return true; } } ","date":"2022-09-10","objectID":"/posts/tech/leetcode/collect/:18:0","tags":["综合","leetcode"],"title":"算法-搜集","uri":"/posts/tech/leetcode/collect/"},{"categories":["leetcode"],"content":"136-简单-只出现一次的数字 136-简单-只出现一次的数字 给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。 说明： 你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？ class Solution { /** * 使用异或运算，将所有值进行异或 * 异或运算，相异为真，相同为假，所以 a^a = 0 ;0^a = a * 因为异或运算 满足交换律 a^b^a = a^a^b = b 所以数组经过异或运算，单独的值就剩下了 */ public int singleNumber(int[] nums) { int value = 0; for (int num : nums) { //注意异或运算符 value ^= num; } return value; } } ","date":"2022-09-10","objectID":"/posts/tech/leetcode/collect/:19:0","tags":["综合","leetcode"],"title":"算法-搜集","uri":"/posts/tech/leetcode/collect/"},{"categories":["leetcode"],"content":"141-简单-环形链表 141-简单-环形链表 给你一个链表的头节点 head ，判断链表中是否有环。 如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 public class Solution { /** * 法1： 哈希 */ public boolean hasCycle(ListNode head) { Set\u003cListNode\u003e seen = new HashSet\u003cListNode\u003e(); while (head != null) { if (!seen.add(head)) { return true; } head = head.next; } return false; } /** * 法2：双指针 */ public boolean hasCycle2(ListNode head) { if (head == null || head.next == null) { return false; } ListNode slow = head; //注意：此处fast定义 ListNode fast = head.next; //注意：循环条件 while (slow != fast) { //注意：此处判断条件 if (fast == null || fast.next == null) { return false; } slow = slow.next; fast = fast.next.next; } return true; } } ","date":"2022-09-10","objectID":"/posts/tech/leetcode/collect/:20:0","tags":["综合","leetcode"],"title":"算法-搜集","uri":"/posts/tech/leetcode/collect/"},{"categories":["leetcode"],"content":"151-中等-反转字符串中的单词 151-中等-反转字符串中的单词 给你一个字符串 s ，请你反转字符串中 单词 的顺序。 单词 是由非空格字符组成的字符串。s 中使用至少一个空格将字符串中的 单词 分隔开。 返回 单词 顺序颠倒且 单词 之间用单个空格连接的结果字符串。 注意：输入字符串 s中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。 class Solution { /** * 1. 去除多余空格 * 2. 翻转整个字符串 * 3. 逐个按单词再翻转 */ public String reverseWords(String s) { StringBuilder sb = trimSpaces(s); // 翻转字符串 reverse(sb, 0, sb.length() - 1); // 翻转每个单词 reverseEachWord(sb); return sb.toString(); } public StringBuilder trimSpaces(String s) { int left = 0, right = s.length() - 1; // 去掉字符串开头的空白字符，优秀想法 while (s.charAt(left) == ' ') { left++; } // 去掉字符串末尾的空白字符，优秀想法 while (s.charAt(right) == ' ') { right--; } // 将字符串间多余的空白字符去除 StringBuilder sb = new StringBuilder(); while (left \u003c= right) { char c = s.charAt(left); //s.charAt(str.length() - 1) != ' ' 是为了判断 不连续2个空格 if (c != ' ' || sb.charAt(sb.length() - 1) != ' ') { sb.append(c); } //别漏了 left++; } return sb; } public void reverse(StringBuilder sb, int left, int right) { while (left \u003c right) { char tmp = sb.charAt(left); sb.setCharAt(left++, sb.charAt(right)); sb.setCharAt(right--, tmp); } } public void reverseEachWord(StringBuilder sb) { int n = sb.length(); int start = 0, end = 0; while (start \u003c n) { // 循环至单词的末尾 while (end \u003c n \u0026\u0026 sb.charAt(end) != ' ') { ++end; } // 翻转单词 reverse(sb, start, end - 1); // 更新start，去找下一个单词 start = end + 1; ++end; } } } ","date":"2022-09-10","objectID":"/posts/tech/leetcode/collect/:21:0","tags":["综合","leetcode"],"title":"算法-搜集","uri":"/posts/tech/leetcode/collect/"},{"categories":["leetcode"],"content":"155-中等-最小栈 155-中等-最小栈 设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。 实现 MinStack 类: MinStack() 初始化堆栈对象。 void push(int val) 将元素val推入堆栈。 void pop() 删除堆栈顶部的元素。 int top() 获取堆栈顶部的元素。 int getMin() 获取堆栈中的最小元素。 /** * 法1：辅助栈 */ class MinStack { Deque\u003cInteger\u003e xStack; Deque\u003cInteger\u003e minStack; public MinStack() { xStack = new LinkedList\u003cInteger\u003e(); minStack = new LinkedList\u003cInteger\u003e(); minStack.push(Integer.MAX_VALUE); } public void push(int x) { xStack.push(x); //辅助栈，每次都新增数值 minStack.push(Math.min(minStack.peek(), x)); } public void pop() { xStack.pop(); minStack.pop(); } public int top() { return xStack.peek(); } public int getMin() { return minStack.peek(); } } /** * 法2：辅助栈 */ class MinStack { // 记录栈中的所有元素 Stack\u003cInteger\u003e nStack; // 阶段性记录栈中的最小元素 Stack\u003cInteger\u003e mStack; public MinStack() { nStack = new Stack\u003c\u003e(); mStack = new Stack\u003c\u003e(); } public void push(int val) { nStack.push(val); //维护 minStk 栈顶为全栈最小元素 if (mStack.isEmpty() || val \u003c= mStack.peek()) { // 新插入的这个元素就是全栈最小的 mStack.push(val); } } public void pop() { // 比较 Integer 相等 用 equal if (nStack.peek().equals(mStack.peek())) { mStack.pop(); } nStack.pop(); } public int top() { return nStack.peek(); } public int getMin() { // minStk 栈顶为全栈最小元素 return mStack.peek(); } } ","date":"2022-09-10","objectID":"/posts/tech/leetcode/collect/:22:0","tags":["综合","leetcode"],"title":"算法-搜集","uri":"/posts/tech/leetcode/collect/"},{"categories":["leetcode"],"content":"204-中等-计数质数 204-中等-计数质数 给定整数 n ，返回 所有小于非负整数 n 的质数的数量 。 /** * 法1：优化【反向思维】 */ public int countPrimes(int n) { int[] array = new int[n + 2]; for (int i = 2; i \u003c n; ++i) { if (array[i] == 0) { //注意 j += i for (int j = 2 * i; j \u003c n; j += i) { array[j] = 1; } } } int ans = 0; for (int i = 2; i \u003c n; i++) { if (array[i] == 0) { ans++; } } return ans; } /** * 法2：暴力, 超出时间限制 */ public int countPrimes2(int n) { int ans = 0; for (int i = 2; i \u003c n; ++i) { ans += isPrime(i) ? 1 : 0; } return ans; } public boolean isPrime(int x) { for (int i = 2; i * i \u003c= x; ++i) { if (x % i == 0) { return false; } } return true; } ","date":"2022-09-10","objectID":"/posts/tech/leetcode/collect/:23:0","tags":["综合","leetcode"],"title":"算法-搜集","uri":"/posts/tech/leetcode/collect/"},{"categories":["leetcode"],"content":"226-简单-翻转二叉树 226-简单-翻转二叉树 给你一棵二叉树的根节点 root ，翻转这棵二叉树，并返回其根节点。 class Solution { public TreeNode invertTree(TreeNode root) { if(root==null){ return root; } // 1. 利用函数定义，先翻转左右子树 TreeNode leftNode= invertTree(root.left); TreeNode rightNode= invertTree(root.right); // 2. 交换左右子节点 root.left=rightNode; root.right=leftNode; return root; } } ","date":"2022-09-10","objectID":"/posts/tech/leetcode/collect/:24:0","tags":["综合","leetcode"],"title":"算法-搜集","uri":"/posts/tech/leetcode/collect/"},{"categories":["leetcode"],"content":"231-简单-2的幂 231-简单-2的幂 给你一个整数 n，请你判断该整数是否是 2 的幂次方。如果是，返回 true ；否则，返回 false 。 如果存在一个整数 x 使得 n == 2x ，则认为 n 是 2 的幂次方。 class Solution { public boolean isPowerOfTwo(int n) { while (n != 0 \u0026\u0026 n % 2 == 0) { n = n / 2; } return n == 1; } } ","date":"2022-09-10","objectID":"/posts/tech/leetcode/collect/:25:0","tags":["综合","leetcode"],"title":"算法-搜集","uri":"/posts/tech/leetcode/collect/"},{"categories":["leetcode"],"content":"234-简单-回文链表 234-简单-回文链表 给你一个单链表的头节点 head ，请你判断该链表是否为回文链表。如果是，返回 true ；否则，返回 false 。 class Solution { /** * 1. 链表遍历 值存list * 2. 对list 进行左右双指针 回文判断 */ public boolean isPalindrome(ListNode head) { List\u003cInteger\u003e vals =new ArrayList\u003cInteger\u003e(); ListNode dump = head; while(dump!=null){ vals.add(dump.val); //注意此处赋值为 dump.next dump = dump.next; } int left=0, right=vals.size()-1; while(left\u003cright){ if(!vals.get(left).equals(vals.get(right))){ return false; } left++; right--; } return true; } } ","date":"2022-09-10","objectID":"/posts/tech/leetcode/collect/:26:0","tags":["综合","leetcode"],"title":"算法-搜集","uri":"/posts/tech/leetcode/collect/"},{"categories":["leetcode"],"content":"237-中等-删除链表中的节点 237-中等-删除链表中的节点 请编写一个函数，用于 删除单链表中某个特定节点 。在设计函数时需要注意，你无法访问链表的头节点 head ，只能直接访问 要被删除的节点 。 题目数据保证需要删除的节点 不是末尾节点 。 class Solution { public void deleteNode(ListNode node) { node.val = node.next.val; node.next = node.next.next; } } ","date":"2022-09-10","objectID":"/posts/tech/leetcode/collect/:27:0","tags":["综合","leetcode"],"title":"算法-搜集","uri":"/posts/tech/leetcode/collect/"},{"categories":["leetcode"],"content":"238-中等-除自身以外数组的乘积 238-中等-除自身以外数组的乘积 给你一个整数数组 nums，返回 数组 answer ，其中 answer[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积 。 题目数据 保证 数组 nums之中任意元素的全部前缀元素和后缀的乘积都在 32 位 整数范围内。 请不要使用除法，且在 O(n) 时间复杂度内完成此题。 class Solution { public int[] productExceptSelf(int[] nums) { int len = nums.length; // L 和 R 分别表示左右两侧的乘积列表 int[] leftValue = new int[len]; int[] rightValue = new int[len]; int[] result = new int[len]; // L[i] 为索引 i 左侧所有元素的乘积 // 对于索引为 '0' 的元素，因为左侧没有元素，所以 L[0] = 1 leftValue[0] = 1; for (int i = 1; i \u003c len; i++) { leftValue[i] = nums[i-1] * leftValue[i - 1]; } // R[i] 为索引 i 右侧所有元素的乘积 // 对于索引为 'length-1' 的元素，因为右侧没有元素，所以 R[length-1] = 1 rightValue[len-1] = 1; for (int i = len - 2; i \u003e= 0; i--) { rightValue[i] = nums[i + 1] * rightValue[i + 1]; } // 对于索引 i，除 nums[i] 之外其余各元素的乘积就是左侧所有元素的乘积乘以右侧所有元素的乘积 for (int i = 0; i \u003c len; i++) { result[i] = leftValue[i] * rightValue[i]; } return result; } } ","date":"2022-09-10","objectID":"/posts/tech/leetcode/collect/:28:0","tags":["综合","leetcode"],"title":"算法-搜集","uri":"/posts/tech/leetcode/collect/"},{"categories":["leetcode"],"content":"242-简单-有效的字母异位词 242-简单-有效的字母异位词 给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。 注意：若 s 和 t 中每个字符出现的次数都相同，则称 s 和 t 互为字母异位词。 class Solution { /** * 方法1： * 1. 26个英文字母数字长度，每个索引的值进行 先加1，后减1， 当所有均为0时，才相等 * t 是 s 的异位词等价于「两个字符串中字符出现的种类和次数均相等」 */ public boolean isAnagram(String s, String t) { int[] record = new int[26]; for (char c : s.toCharArray()) { record[c - 'a'] += 1; } for (char c : t.toCharArray()) { record[c - 'a'] -= 1; } for (int i : record) { // record数组如果有的元素不为零0，说明字符串s和t 一定是谁多了字符或者谁少了字符。 if (i != 0) { return false; } } // record数组所有元素都为零0，说明字符串s和t是字母异位词 return true; } /** * 方法2： * 1.数组排序 * 2.比较 */ public boolean isAnagram2(String s, String t) { if (s.length() != t.length()) { return false; } char[] str1 = s.toCharArray(); char[] str2 = t.toCharArray(); Arrays.sort(str1); Arrays.sort(str2); return Arrays.equals(str1, str2); } } ","date":"2022-09-10","objectID":"/posts/tech/leetcode/collect/:29:0","tags":["综合","leetcode"],"title":"算法-搜集","uri":"/posts/tech/leetcode/collect/"},{"categories":["leetcode"],"content":"268-简单-丢失的数字 268-简单-丢失的数字 给定一个包含 [0, n] 中 n 个数的数组 nums ，找出 [0, n] 这个范围内没有出现在数组中的那个数。 class Solution { /** * 法1：异或运算，异或运算具有交换律 */ public int missingNumber(int[] nums) { int num=0; // 先和新补的索引异或一下 num^=nums.length; // 和其他的元素、索引做异或 for(int i=0;i\u003cnums.length;i++){ num^=i^nums[i]; } return num; } /** * 法2：等差数列求和，减去所有值 */ public int missingNumber2(int[] nums) { int length = nums.length; int sum = (0 + length) * (length + 1) / 2; for (int i = 0; i \u003c length; i++){ sum -= nums[i]; } return sum; } } ","date":"2022-09-10","objectID":"/posts/tech/leetcode/collect/:30:0","tags":["综合","leetcode"],"title":"算法-搜集","uri":"/posts/tech/leetcode/collect/"},{"categories":["leetcode"],"content":"326-简单-3的幂 326-简单-3的幂 给定一个整数，写一个函数来判断它是否是 3 的幂次方。如果是，返回 true ；否则，返回 false 。 class Solution { /** * 方法1： while循环 */ public boolean isPowerOfThree(int n) { while (n != 0 \u0026\u0026 n % 3 == 0) { n = n / 3; } return n == 1; } /** * 方法二：判断是否为最大 33 的幂的约数 * \u003cp\u003e * 我们还可以使用一种较为取巧的做法。 * 在题目给定的 3232 位有符号整数的范围内，最大的 33 的幂为 3^{19} = 11622614673 * =1162261467。我们只需要判断 nn 是否是 3^{19} 的约数即可。 */ public boolean isPowerOfThree(int n) { return n \u003e 0 \u0026\u0026 1162261467 % n == 0; } /** * 方法3：哈希表 */ static Set\u003cInteger\u003e set = new HashSet\u003c\u003e(); static { int cur = 1; set.add(cur); while (cur \u003c= Integer.MAX_VALUE / 3) { cur *= 3; set.add(cur); } } public boolean isPowerOfThree(int n) { return n \u003e 0 \u0026\u0026 set.contains(n); } } ","date":"2022-09-10","objectID":"/posts/tech/leetcode/collect/:31:0","tags":["综合","leetcode"],"title":"算法-搜集","uri":"/posts/tech/leetcode/collect/"},{"categories":["leetcode"],"content":"342-简单-4的幂 342-简单-4的幂 给定一个整数，写一个函数来判断它是否是 4 的幂次方。如果是，返回 true ；否则，返回 false 。 class Solution { public boolean isPowerOfFour(int n) { while (n != 0 \u0026\u0026 n % 4 == 0) { n = n / 4; } return n == 1; } } ","date":"2022-09-10","objectID":"/posts/tech/leetcode/collect/:32:0","tags":["综合","leetcode"],"title":"算法-搜集","uri":"/posts/tech/leetcode/collect/"},{"categories":["leetcode"],"content":"384-中等-打乱数组 384-中等-打乱数组 给你一个整数数组 nums ，设计算法来打乱一个没有重复元素的数组。打乱后，数组的所有排列应该是 等可能 的。 实现 Solution class: Solution(int[] nums) 使用整数数组 nums 初始化对象 int[] reset() 重设数组到它的初始状态并返回 int[] shuffle() 返回数组随机打乱后的结果 class Solution { int[] array; public Solution(int[] nums) { array=nums; } public int[] reset() { return array; } public int[] shuffle() { //注意 array.clone(); int[] tmp= array.clone(); Random random =new Random(); int len =tmp.length; for(int i=0;i\u003clen;i++){ //i+random.nextInt(len-i); int j= i+random.nextInt(len-i); int t= tmp[j]; tmp[j]=tmp[i]; tmp[i]=t; } return tmp; } } ","date":"2022-09-10","objectID":"/posts/tech/leetcode/collect/:33:0","tags":["综合","leetcode"],"title":"算法-搜集","uri":"/posts/tech/leetcode/collect/"},{"categories":["leetcode"],"content":"387-简单-字符串中的第一个唯一字符 387-简单-字符串中的第一个唯一字符 给定一个字符串 s ，找到 它的第一个不重复的字符，并返回它的索引 。如果不存在，则返回 -1 。 public int firstUniqChar(String s) { Map\u003cCharacter, Integer\u003e frequency = new HashMap\u003cCharacter, Integer\u003e(); for (int i = 0; i \u003c s.length(); ++i) { char ch = s.charAt(i); frequency.put(ch, frequency.getOrDefault(ch, 0) + 1); } for (int i = 0; i \u003c s.length(); ++i) { if (frequency.get(s.charAt(i)) == 1) { return i; } } return -1; } /** * 法2：数组统计，高效 */ public int firstUniqChar(String s) { int[] arr = new int[26]; int n = s.length(); for (int i = 0; i \u003c n; i++) { arr[s.charAt(i)-'a']++ ; } for (int i = 0; i \u003c n; i++) { if (arr[s.charAt(i)-'a'] == 1) { return i; } } return -1; } ","date":"2022-09-10","objectID":"/posts/tech/leetcode/collect/:34:0","tags":["综合","leetcode"],"title":"算法-搜集","uri":"/posts/tech/leetcode/collect/"},{"categories":["leetcode"],"content":"412-简单-Fizz Buzz 412-简单-Fizz Buzz 给你一个整数 n ，找出从 1 到 n 各个整数的 Fizz Buzz 表示，并用字符串数组 answer（下标从 1 开始）返回结果，其中： answer[i] == “FizzBuzz” 如果 i 同时是 3 和 5 的倍数。 answer[i] == “Fizz” 如果 i 是 3 的倍数。 answer[i] == “Buzz” 如果 i 是 5 的倍数。 answer[i] == i （以字符串形式）如果上述条件全不满足。 /** * 法1：优化【反向思维】 */ public int countPrimes(int n) { int[] array = new int[n + 2]; for (int i = 2; i \u003c n; ++i) { if (array[i] == 0) { //注意 j += i for (int j = 2 * i; j \u003c n; j += i) { array[j] = 1; } } } int ans = 0; for (int i = 2; i \u003c n; i++) { if (array[i] == 0) { ans++; } } return ans; } /** * 法2：暴力, 超出时间限制 */ public int countPrimes2(int n) { int ans = 0; for (int i = 2; i \u003c n; ++i) { ans += isPrime(i) ? 1 : 0; } return ans; } public boolean isPrime(int x) { for (int i = 2; i * i \u003c= x; ++i) { if (x % i == 0) { return false; } } return true; } ","date":"2022-09-10","objectID":"/posts/tech/leetcode/collect/:35:0","tags":["综合","leetcode"],"title":"算法-搜集","uri":"/posts/tech/leetcode/collect/"},{"categories":["leetcode"],"content":"543-简单-二叉树的直径 543-简单-二叉树的直径 给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。 class Solution { // 记录最大直径的长度 int max = 0; public int diameterOfBinaryTree(TreeNode root) { maxDepth(root); return max; } public int maxDepth(TreeNode root) { if (root == null) { return 0; } int left = cal(root.left); int right = cal(root.right); // 后序位置，顺便计算最大直径 : left+right max = Math.max(max, left + right); return Math.max(left, right) + 1; } } ","date":"2022-09-10","objectID":"/posts/tech/leetcode/collect/:36:0","tags":["综合","leetcode"],"title":"算法-搜集","uri":"/posts/tech/leetcode/collect/"},{"categories":["leetcode"],"content":"640-中等-求解方程 640-中等-求解方程 求解一个给定的方程，将x以字符串 “x=#value” 的形式返回。该方程仅包含 ‘+’ ， ‘-’ 操作，变量 x 和其对应系数。 如果方程没有解或存在的解不为整数，请返回 “No solution” 。如果方程有无限解，则返回 “Infinite solutions” 。 题目保证，如果方程中只有一个解，则 ‘x’ 的值是一个整数。 class Solution { public String solveEquation(String s) { int x = 0, num = 0, length = s.length(); char[] array = s.toCharArray(); //定义op为操作符，若+号则为1，-号则为-1； for (int i = 0, op = 1; i \u003c length; ) { if (array[i] == '+') { op = 1; i++; } else if (array[i] == '-') { op = -1; i++; } else if (array[i] == '=') { //若为等号开始，马上右边 x *= -1; num *= -1; op = 1; i++; } else { int j = i; while (j \u003c length \u0026\u0026 array[j] != '+' \u0026\u0026 array[j] != '-' \u0026\u0026 array[j] != '=') { j++; } if (array[j - 1] == 'x') { x += (i \u003c j - 1 ? Integer.parseInt(s.substring(i, j - 1)) : 1) * op; } else { num += Integer.parseInt(s.substring(i, j)) * op; } i = j; } } if (x == 0) { return num == 0 ? \"Infinite solutions\" : \"No solution\"; } else { return \"x=\" + (num / -x); } } } ","date":"2022-09-10","objectID":"/posts/tech/leetcode/collect/:37:0","tags":["综合","leetcode"],"title":"算法-搜集","uri":"/posts/tech/leetcode/collect/"},{"categories":["leetcode"],"content":"654-中等-最大二叉树 654-中等-最大二叉树 给定一个不重复的整数数组 nums 。 最大二叉树 可以用下面的算法从 nums 递归地构建: 创建一个根节点，其值为 nums 中的最大值。 递归地在最大值 左边 的 子数组前缀上 构建左子树。 递归地在最大值 右边 的 子数组后缀上 构建右子树。 返回 nums 构建的 最大二叉树 。 class Solution { /** * 递归解法 */ public TreeNode constructMaximumBinaryTree(int[] nums) { return build(nums, 0, nums.length - 1); } TreeNode build(int[] nums, int left, int right) { if (left \u003e right) { return null; } int maxValIndex = left; //注意：i\u003c=right //1. 找出区间最大值索引 for (int i = left; i \u003c= right; i++) { if (nums[i] \u003e nums[maxValIndex]) { maxValIndex = i; } } //2. 节点赋值 TreeNode ans = new TreeNode(nums[maxValIndex]); //3. 左右树递归 ans.left = build(nums, left, maxValIndex - 1); ans.right = build(nums, maxValIndex + 1, right); return ans; } } ","date":"2022-09-10","objectID":"/posts/tech/leetcode/collect/:38:0","tags":["综合","leetcode"],"title":"算法-搜集","uri":"/posts/tech/leetcode/collect/"},{"categories":["leetcode"],"content":"876-简单-单链表的中点 876-简单-单链表的中点 给定一个头结点为 head 的非空单链表，返回链表的中间结点。 如果有两个中间结点，则返回第二个中间结点。 class Solution { ListNode middleNode(ListNode head) { // 快慢指针初始化指向 head ListNode slow = head, fast = head; // 快指针走到末尾时停止 while (fast != null \u0026\u0026 fast.next != null) { // 慢指针走一步，快指针走两步 slow = slow.next; fast = fast.next.next; } // 慢指针指向中点 return slow; } } ","date":"2022-09-10","objectID":"/posts/tech/leetcode/collect/:39:0","tags":["综合","leetcode"],"title":"算法-搜集","uri":"/posts/tech/leetcode/collect/"},{"categories":["leetcode"],"content":"10001-简单-树的前序遍历结果 10001-简单-树的前序遍历结果 输入一棵二叉树的根节点，返回这棵树的前序遍历结果 // 定义：输入一棵二叉树的根节点，返回这棵树的前序遍历结果 List\u003cInteger\u003e preorderTraverse(TreeNode root) { List\u003cInteger\u003e res = new LinkedList\u003c\u003e(); if (root == null) { return res; } // 前序遍历的结果，root.val 在第一个 res.add(root.val); // 利用函数定义，后面接着左子树的前序遍历结果 res.addAll(preorderTraverse(root.left)); // 利用函数定义，最后接着右子树的前序遍历结果 res.addAll(preorderTraverse(root.right)); return res; } ","date":"2022-09-10","objectID":"/posts/tech/leetcode/collect/:40:0","tags":["综合","leetcode"],"title":"算法-搜集","uri":"/posts/tech/leetcode/collect/"},{"categories":["hugo"],"content":"LoveIt 使用Algolia搜索 Hugo-LoveIt添加Algolia搜索 loveit支持两种搜索：lunr和algolia。 lunr性能实在堪忧，特别是对于中文而言基本上不能用。 因此我们选用algolia，社区版10000条（不知道是按什么计算的，反正肯定不是按文章）搜索项，每月10000次搜索，对于小网站来说也够用了。之后我打算抽空自己用微服务写一个，到时候和博客挂在一起。 操作： 前往官网注册账号algolia 在左侧第二个Indices下选择New，创建Index（我的名称为 blog ） 在API Keys上拿到Search-Only API Key作为searchKey和Application ID作为appID。 配置 config.toml 文件，如下： [params.search] enable = true type = \"algolia\" contentLength = 4000 placeholder = \"\" maxResultLength = 10 snippetLength = 50 highlightTag = \"em\" absoluteURL = false [params.search.algolia] index = \"blog\" appID = \"xxxx\" searchKey = \"xxxx\" [outputs] home = [\"HTML\", \"RSS\", \"JSON\"] # 这个一定要带上JSON，不然不会产生对应的JSON文件 每次 hugo 命令之后会产生/public/index.json文件，需要将这个文件上传到algolia中 ","date":"2022-09-04","objectID":"/posts/tech/tools/hugo-search/:1:0","tags":["search","hugo"],"title":"Hugo Search","uri":"/posts/tech/tools/hugo-search/"},{"categories":["hugo"],"content":"使用Algolia搜索支持 Hugo-Even ","date":"2022-09-04","objectID":"/posts/tech/tools/hugo-search/:2:0","tags":["search","hugo"],"title":"Hugo Search","uri":"/posts/tech/tools/hugo-search/"},{"categories":["hugo"],"content":"使用hugofastsearch hugofastsearch.md 当前仅支持搜索标题 ","date":"2022-09-04","objectID":"/posts/tech/tools/hugo-search/:3:0","tags":["search","hugo"],"title":"Hugo Search","uri":"/posts/tech/tools/hugo-search/"},{"categories":["hugo"],"content":"Setup Add index.json file to layouts/_default Add JSON as additional output format in config.toml Add fastsearch.js and fuse.js (downloaded from fusejs.io) to static/js Add searchbox html to bottom of layouts/_default/baseof.html Add css styles to your site’s main css file or top of baseof.html hugo Visit localhost:1313/ Press CMD-/ to invoke search You can check the json index by visiting localhost:1313/index.json ","date":"2022-09-04","objectID":"/posts/tech/tools/hugo-search/:4:0","tags":["search","hugo"],"title":"Hugo Search","uri":"/posts/tech/tools/hugo-search/"},{"categories":["hugo"],"content":"Detail ","date":"2022-09-04","objectID":"/posts/tech/tools/hugo-search/:5:0","tags":["search","hugo"],"title":"Hugo Search","uri":"/posts/tech/tools/hugo-search/"},{"categories":["hugo"],"content":"index.json layouts/_default/index.json Hugo already builds indexes of all pages, we can cherry-pick which aspects should be searchable. The result is a newly created JSON index at /index.json {{- $.Scratch.Add \"index\" slice -}} {{- range .Site.RegularPages -}} {{- $.Scratch.Add \"index\" (dict \"title\" .Title \"tags\" .Params.tags \"categories\" .Params.categories \"contents\" .Plain \"permalink\" .Permalink) -}} {{- end -}} {{- $.Scratch.Get \"index\" | jsonify -}} ","date":"2022-09-04","objectID":"/posts/tech/tools/hugo-search/:5:1","tags":["search","hugo"],"title":"Hugo Search","uri":"/posts/tech/tools/hugo-search/"},{"categories":["hugo"],"content":"Config.toml Add this snippet to your config file to instruct Hugo to create the index file in JSON format. (RSS and HTML are default outputs, what’s important is to add JSON. [outputs] home = [\"HTML\", \"RSS\", \"JSON\"] ","date":"2022-09-04","objectID":"/posts/tech/tools/hugo-search/:5:2","tags":["search","hugo"],"title":"Hugo Search","uri":"/posts/tech/tools/hugo-search/"},{"categories":["hugo"],"content":"static/js/fastsearch.js This “makes” the search engine based on the index.json file, and wires up all keyboard handling var fuse; // holds our search engine var searchVisible = false; var firstRun = true; // allow us to delay loading json data unless search activated var list = document.getElementById('searchResults'); // targets the \u003cul\u003e var first = list.firstChild; // first child of search list var last = list.lastChild; // last child of search list var maininput = document.getElementById('searchInput'); // input box for search var resultsAvailable = false; // Did we get any search results? // ========================================== // The main keyboard event listener running the show // document.addEventListener('keydown', function (event) { // CMD-/ to show / hide Search if (event.metaKey \u0026\u0026 event.which === 191) { // Load json search index if first time invoking search // Means we don't load json unless searches are going to happen; keep user payload small unless needed if (firstRun) { loadSearch(); // loads our json data and builds fuse.js search index firstRun = false; // let's never do this again } // Toggle visibility of search box if (!searchVisible) { document.getElementById(\"fastSearch\").style.visibility = \"visible\"; // show search box document.getElementById(\"searchInput\").focus(); // put focus in input box so you can just start typing searchVisible = true; // search visible } else { document.getElementById(\"fastSearch\").style.visibility = \"hidden\"; // hide search box document.activeElement.blur(); // remove focus from search box searchVisible = false; // search not visible } } // Allow ESC (27) to close search box if (event.keyCode == 27) { if (searchVisible) { document.getElementById(\"fastSearch\").style.visibility = \"hidden\"; document.activeElement.blur(); searchVisible = false; } } // DOWN (40) arrow if (event.keyCode == 40) { if (searchVisible \u0026\u0026 resultsAvailable) { console.log(\"down\"); event.preventDefault(); // stop window from scrolling if (document.activeElement == maininput) { first.focus(); } // if the currently focused element is the main input --\u003e focus the first \u003cli\u003e else if (document.activeElement == last) { last.focus(); } // if we're at the bottom, stay there else { document.activeElement.parentElement.nextSibling.firstElementChild.focus(); } // otherwise select the next search result } } // UP (38) arrow if (event.keyCode == 38) { if (searchVisible \u0026\u0026 resultsAvailable) { event.preventDefault(); // stop window from scrolling if (document.activeElement == maininput) { maininput.focus(); } // If we're in the input box, do nothing else if (document.activeElement == first) { maininput.focus(); } // If we're at the first item, go to input box else { document.activeElement.parentElement.previousSibling.firstElementChild.focus(); } // Otherwise, select the search result above the current active one } } }); // ========================================== // execute search as each character is typed // document.getElementById(\"searchInput\").onkeyup = function (e) { executeSearch(this.value); } // ========================================== // fetch some json without jquery // function fetchJSONFile(path, callback) { var httpRequest = new XMLHttpRequest(); httpRequest.onreadystatechange = function () { if (httpRequest.readyState === 4) { if (httpRequest.status === 200) { var data = JSON.parse(httpRequest.responseText); if (callback) callback(data); } } }; httpRequest.open('GET', path); httpRequest.send(); } // ========================================== // load our search index, only executed once // on first call of search box (CMD-/) // function loadSearch() { fetchJSONFile('/index.json', function (data) { var options = { // fuse.js options; check fuse.js website for details shouldSort: true, location: 0, distance: 100, threshold: 0.4, minMatchCharLength: 2, keys: [ 'title', 'permalink', 'summary' ] }; fuse = new Fuse(data, options); // build the index from the json file }); } // ============================","date":"2022-09-04","objectID":"/posts/tech/tools/hugo-search/:5:3","tags":["search","hugo"],"title":"Hugo Search","uri":"/posts/tech/tools/hugo-search/"},{"categories":["hugo"],"content":"static/js/fuse.js fuse.js (downloaded from fusejs.io )) to static/js ","date":"2022-09-04","objectID":"/posts/tech/tools/hugo-search/:5:4","tags":["search","hugo"],"title":"Hugo Search","uri":"/posts/tech/tools/hugo-search/"},{"categories":["hugo"],"content":"baseof.html Add this block to the bottom of your baseof.html file, just before the footer \u003cdiv id=\"fastSearch\"\u003e \u003cinput id=\"searchInput\" tabindex=\"0\"\u003e \u003cul id=\"searchResults\"\u003e \u003c/ul\u003e \u003c/div\u003e \u003cscript src=\"/js/fuse.js\"\u003e\u003c/script\u003e \u003c!-- download and copy over fuse.js file from fusejs.io --\u003e \u003cscript src=\"/js/fastsearch.js\"\u003e\u003c/script\u003e CSS Styling Add css styles to your site’s main css file or top of baseof.html #fastSearch { visibility: hidden; position: absolute; right: 0px; top: 0px; display: inline-block; width: 300px; } #fastSearch input { padding: 4px 10px; width: 100%; height: 31px; font-size: 1.6em; color: #aaa; font-weight: bold; background-color: #000; border-radius: 3px 3px 0px 0px; border: none; outline: none; text-align: left; display: inline-block; } #searchResults li { list-style: none; margin-left: 0em; background-color: #aaa; border-bottom: 1px dotted #000; } #searchResults li .title { font-size: 1.1em; margin-bottom: 10px; display: inline-block;} #searchResults { visibility: inherit; display: inline-block; width: 320px; } #searchResults a { text-decoration: none !important; padding: 10px; display: inline-block; } #searchResults a:hover, a:focus { outline: 0; background-color: #666; color: #fff; } ","date":"2022-09-04","objectID":"/posts/tech/tools/hugo-search/:5:5","tags":["search","hugo"],"title":"Hugo Search","uri":"/posts/tech/tools/hugo-search/"},{"categories":["leetcode"],"content":"二叉树 二叉树题型主要是用来培养递归思维的 ","date":"2022-08-21","objectID":"/posts/tech/leetcode/tree/:0:0","tags":["二叉树","leetcode"],"title":"算法-二叉树","uri":"/posts/tech/leetcode/tree/"},{"categories":["leetcode"],"content":"二叉树解题的思维模式分两类： 1、是否可以通过遍历一遍二叉树得到答案？如果可以，用一个 traverse 函数配合外部变量来实现，这叫「遍历」的思维模式。 2、是否可以定义一个递归函数，通过子问题（子树）的答案推导出原问题的答案？如果可以，写出这个递归函数的定义，并充分利用这个函数的返回值，这叫「分解问题」的思维模式。 无论使用哪种思维模式，你都需要思考： 如果单独抽出一个二叉树节点，它需要做什么事情？需要在什么时候（前/中/后序位置）做？其他的节点不用你操心，递归函数会帮你在所有节点上执行相同的操作。 二叉树的构造问题一般都是使用「分解问题」的思路：构造整棵树 = 根节点 + 构造左子树 + 构造右子树。 ","date":"2022-08-21","objectID":"/posts/tech/leetcode/tree/:1:0","tags":["二叉树","leetcode"],"title":"算法-二叉树","uri":"/posts/tech/leetcode/tree/"},{"categories":["leetcode"],"content":"二叉树的重要性 举个例子，比如两个经典排序算法 快速排序 和 归并排序，对于它俩，你有什么理解？ 如果你告诉我，快速排序就是个二叉树的前序遍历，归并排序就是个二叉树的后序遍历，那么我就知道你是个算法高手了。 ","date":"2022-08-21","objectID":"/posts/tech/leetcode/tree/:2:0","tags":["二叉树","leetcode"],"title":"算法-二叉树","uri":"/posts/tech/leetcode/tree/"},{"categories":["leetcode"],"content":"深入理解前中后序 几个问题，请默默思考 30 秒： 1、你理解的二叉树的前中后序遍历是什么，仅仅是三个顺序不同的 List 吗？ 2、请分析，后序遍历有什么特殊之处？ 3、请分析，为什么多叉树没有中序遍历？ 二叉树遍历框架 void traverse(TreeNode root) { if (root == null) { return; } // 前序位置 traverse(root.left); // 中序位置 traverse(root.right); // 后序位置 } 单链表和数组的遍历可以是迭代的，也可以是递归的，二叉树这种结构无非就是二叉链表，由于没办法简单改写成迭代形式，所以一般说二叉树的遍历框架都是指递归的形式。 你也注意到了，只要是递归形式的遍历，都可以有前序位置和后序位置，分别在递归之前和递归之后。 所谓前序位置，就是刚进入一个节点（元素）的时候，后序位置就是即将离开一个节点（元素）的时候，那么进一步，你把代码写在不同位置，代码执行的时机也不同： 比如说，如果让你倒序打印一条单链表上所有节点的值，你怎么搞？ 实现方式当然有很多，但如果你对递归的理解足够透彻，可以利用后序位置来操作： /* 递归遍历单链表，倒序打印链表元素 */ void traverse(ListNode head) { if (head == null) { return; } traverse(head.next); // 后序位置 print(head.val); } 为什么多叉树没有中序位置，因为二叉树的每个节点只会进行唯一一次左子树切换右子树，而多叉树节点可能有很多子节点，会多次切换子树去遍历，所以多叉树节点没有「唯一」的中序遍历位置。 二叉树的所有问题，就是让你在前中后序位置注入巧妙的代码逻辑，去达到自己的目的，你只需要单独思考每一个节点应该做什么，其他的不用你管，抛给二叉树遍历框架，递归会在所有节点上做相同的操作。 ","date":"2022-08-21","objectID":"/posts/tech/leetcode/tree/:3:0","tags":["二叉树","leetcode"],"title":"算法-二叉树","uri":"/posts/tech/leetcode/tree/"},{"categories":["leetcode"],"content":"两种解题思路 二叉树题目的递归解法可以分两类思路，第一类是遍历一遍二叉树得出答案，第二类是通过分解问题计算出答案，这两类思路分别对应着 回溯算法核心框架 和 动态规划核心框架。 一棵二叉树的前序遍历结果 = 根节点 + 左子树的前序遍历结果 + 右子树的前序遍历结果。 题解 ","date":"2022-08-21","objectID":"/posts/tech/leetcode/tree/:4:0","tags":["二叉树","leetcode"],"title":"算法-二叉树","uri":"/posts/tech/leetcode/tree/"},{"categories":["leetcode"],"content":"二叉树的最大深度-E 力扣第 104 题 二叉树的最大深度 给定一个二叉树，找出其最大深度。 二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。 说明: 叶子节点是指没有子节点的节点。 /** * 递归解法 */ public int maxDepth(TreeNode root) { //当root为0是，则代表tree不存在 if (root == null) { return 0; } // 利用定义，计算左右子树的最大深度 int maxLeft = maxDepth(root.left); int maxRight = maxDepth(root.right); // 整棵树的最大深度等于左右子树的最大深度取最大值， // 然后再加上根节点自己 return Math.max(maxLeft, maxRight) + 1; } ","date":"2022-08-21","objectID":"/posts/tech/leetcode/tree/:5:0","tags":["二叉树","leetcode"],"title":"算法-二叉树","uri":"/posts/tech/leetcode/tree/"},{"categories":["leetcode"],"content":"树的前序遍历结果 输入一棵二叉树的根节点，返回这棵树的前序遍历结果 // 定义：输入一棵二叉树的根节点，返回这棵树的前序遍历结果 List\u003cInteger\u003e preorderTraverse(TreeNode root) { List\u003cInteger\u003e res = new LinkedList\u003c\u003e(); if (root == null) { return res; } // 前序遍历的结果，root.val 在第一个 res.add(root.val); // 利用函数定义，后面接着左子树的前序遍历结果 res.addAll(preorderTraverse(root.left)); // 利用函数定义，最后接着右子树的前序遍历结果 res.addAll(preorderTraverse(root.right)); return res; } 中序和后序遍历也是类似的，只要把 add(root.val) 放到中序和后序对应的位置就行了。 这个解法短小精干，但为什么不常见呢？ 一个原因是这个算法的复杂度不好把控，比较依赖语言特性。 Java 的话无论 ArrayList 还是 LinkedList，addAll 方法的复杂度都是 O(N)，所以总体的最坏时间复杂度会达到 O(N^2)，除非你自己实现一个复杂度为 O(1) 的 addAll 方法，底层用链表的话并不是不可能。 当然，最主要的原因还是因为教科书上从来没有这么教过…… 上文举了两个简单的例子，但还有不少二叉树的题目是可以同时使用两种思路来思考和求解的，这就要靠你自己多去练习和思考，不要仅仅满足于一种熟悉的解法思路。 综上，遇到一道二叉树的题目时的通用思考过程是： 1、是否可以通过遍历一遍二叉树得到答案？如果可以，用一个 traverse 函数配合外部变量来实现。 2、是否可以定义一个递归函数，通过子问题（子树）的答案推导出原问题的答案？如果可以，写出这个递归函数的定义，并充分利用这个函数的返回值。 3、无论使用哪一种思维模式，你都要明白二叉树的每一个节点需要做什么，需要在什么时候（前中后序）做。 ","date":"2022-08-21","objectID":"/posts/tech/leetcode/tree/:6:0","tags":["二叉树","leetcode"],"title":"算法-二叉树","uri":"/posts/tech/leetcode/tree/"},{"categories":["leetcode"],"content":"后序位置的特殊之处 前序位置的代码执行是自顶向下的，而后序位置的代码执行是自底向上的： 前序位置的代码只能从函数参数中获取父节点传递来的数据，而后序位置的代码不仅可以获取参数数据，还可以获取到子树通过函数返回值传递回来的数据。 举具体的例子，现在给你一棵二叉树，两个简单的问题： 1、如果把根节点看做第 1 层，如何打印出每一个节点所在的层数？ 2、如何打印出每个节点的左右子树各有多少节点？ 第一个问题可以这样写代码： // 二叉树遍历函数 void traverse(TreeNode root, int level) { if (root == null) { return; } // 前序位置 printf(\"节点 %s 在第 %d 层\", root, level); traverse(root.left, level + 1); traverse(root.right, level + 1); } // 这样调用 traverse(root, 1); 第二个问题可以这样写代码： // 定义：输入一棵二叉树，返回这棵二叉树的节点总数 int count(TreeNode root) { if (root == null) { return 0; } int leftCount = count(root.left); int rightCount = count(root.right); // 后序位置 printf(\"节点 %s 的左子树有 %d 个节点，右子树有 %d 个节点\", root, leftCount, rightCount); return leftCount + rightCount + 1; } 这两个问题的根本区别在于： 一个节点在第几层，你从根节点遍历过来的过程就能顺带记录； 而以一个节点为根的整棵子树有多少个节点，你需要遍历完子树之后才能数清楚。 结合这两个简单的问题，你品味一下后序位置的特点，只有后序位置才能通过返回值获取子树的信息。 那么换句话说，一旦你发现题目和子树有关，那大概率要给函数设置合理的定义和返回值，在后序位置写代码了。 ","date":"2022-08-21","objectID":"/posts/tech/leetcode/tree/:7:0","tags":["二叉树","leetcode"],"title":"算法-二叉树","uri":"/posts/tech/leetcode/tree/"},{"categories":["leetcode"],"content":"二叉树的直径-E 力扣第 543 题 二叉树的直径 ，让你计算一棵二叉树的最长直径长度。 所谓二叉树的「直径」长度，就是任意两个结点之间的路径长度。最长「直径」并不一定要穿过根结点，比如下面这棵二叉树 解决这题的关键在于，每一条二叉树的「直径」长度，就是一个节点的左右子树的最大深度之和。 class Solution { // 记录最大直径的长度 int max = 0; public int diameterOfBinaryTree(TreeNode root) { maxDepth(root); return max; } public int maxDepth(TreeNode root) { if (root == null) { return 0; } int left = cal(root.left); int right = cal(root.right); // 后序位置，顺便计算最大直径 : left+right max = Math.max(max, left + right); return Math.max(left, right) + 1; } } ","date":"2022-08-21","objectID":"/posts/tech/leetcode/tree/:8:0","tags":["二叉树","leetcode"],"title":"算法-二叉树","uri":"/posts/tech/leetcode/tree/"},{"categories":["leetcode"],"content":"层序遍历 二叉树题型主要是用来培养递归思维的，而层序遍历属于迭代遍历，也比较简单，这里就过一下代码框架吧： // 输入一棵二叉树的根节点，层序遍历这棵二叉树 void levelTraverse(TreeNode root) { if (root == null) return; Queue\u003cTreeNode\u003e q = new LinkedList\u003c\u003e(); q.offer(root); // 从上到下遍历二叉树的每一层 while (!q.isEmpty()) { int sz = q.size(); // 从左到右遍历每一层的每个节点 for (int i = 0; i \u003c sz; i++) { TreeNode cur = q.poll(); // 将下一层节点放入队列 if (cur.left != null) { q.offer(cur.left); } if (cur.right != null) { q.offer(cur.right); } } } } 这里面 while 循环和 for 循环分管从上到下和从左到右的遍历. ","date":"2022-08-21","objectID":"/posts/tech/leetcode/tree/:9:0","tags":["二叉树","leetcode"],"title":"算法-二叉树","uri":"/posts/tech/leetcode/tree/"},{"categories":["leetcode"],"content":"翻转二叉树-E 力扣第 226 题 翻转二叉树 给你一棵二叉树的根节点 root ，翻转这棵二叉树，并返回其根节点。 class Solution { public TreeNode invertTree(TreeNode root) { if(root==null){ return root; } // 1. 利用函数定义，先翻转左右子树 TreeNode leftNode= invertTree(root.left); TreeNode rightNode= invertTree(root.right); // 2. 交换左右子节点 root.left=rightNode; root.right=leftNode; return root; } } ","date":"2022-08-21","objectID":"/posts/tech/leetcode/tree/:10:0","tags":["二叉树","leetcode"],"title":"算法-二叉树","uri":"/posts/tech/leetcode/tree/"},{"categories":["leetcode"],"content":"填充节点的右侧指针-M 力扣第 116 题 填充每个二叉树节点的右侧指针 ，看下题目： class Solution { /** * 法1：层次遍历 */ public Node connect(Node root) { if (root == null) { return root; } // 初始化队列同时将第一层节点加入队列中，即根节点 Queue\u003cNode\u003e queue = new LinkedList\u003cNode\u003e(); queue.add(root); // 外层的 while 循环迭代的是层数 while (!queue.isEmpty()) { // 记录当前队列大小 int size = queue.size(); // 遍历这一层的所有节点 for (int i = 0; i \u003c size; i++) { // 从队首取出元素 Node node = queue.poll(); // 连接 if (i \u003c size - 1) { node.next = queue.peek(); } // 拓展下一层节点 if (node.left != null) { queue.add(node.left); } if (node.right != null) { queue.add(node.right); } } } // 返回根节点 return root; } /** * 法2：三叉树 解法 * 1. 连接相同父节点的两个子节点 * 2. 连接跨越父节点的两个子节点 */ public Node connect2(Node root) { if (root == null) { return null; } traverse(root.left, root.right); return root; } /** * 三叉树遍历框架 */ public void traverse(Node node1, Node node2) { if (node1 == null || node2 == null) { return; } /**** 前序位置 ****/ // 将传入的两个节点穿起来 node1.next = node2; // 连接相同父节点的两个子节点 traverse(node1.left, node1.right); traverse(node2.left, node2.right); // 连接跨越父节点的两个子节点 traverse(node1.right, node2.left); } } ","date":"2022-08-21","objectID":"/posts/tech/leetcode/tree/:11:0","tags":["二叉树","leetcode"],"title":"算法-二叉树","uri":"/posts/tech/leetcode/tree/"},{"categories":["leetcode"],"content":"将二叉树展开为链表 【不懂】 力扣第 114 题 将二叉树展开为链表 ，看下题目 给你二叉树的根结点 root ，请你将它展开为一个单链表： class Solution { // 定义：将以 root 为根的树拉平为链表 void flatten(TreeNode root) { // base case if (root == null) return; // 利用定义，把左右子树拉平 flatten(root.left); flatten(root.right); /**** 后序遍历位置 ****/ // 1、左右子树已经被拉平成一条链表 TreeNode left = root.left; TreeNode right = root.right; // 2、将左子树作为右子树 root.left = null; root.right = left; // 3、将原先的右子树接到当前右子树的末端 TreeNode p = root; while (p.right != null) { p = p.right; } p.right = right; } } ","date":"2022-08-21","objectID":"/posts/tech/leetcode/tree/:12:0","tags":["二叉树","leetcode"],"title":"算法-二叉树","uri":"/posts/tech/leetcode/tree/"},{"categories":["leetcode"],"content":"最大二叉树-M[复习] 力扣第 654 题 最大二叉树 ，看下题目 给定一个不重复的整数数组nums 。最大二叉树可以用下面的算法从nums 递归地构建: 创建一个根节点，其值为nums 中的最大值。 递归地在最大值左边的子数组前缀上构建左子树。 递归地在最大值 右边 的子数组后缀上构建右子树。 返回nums 构建的 最大二叉树。 class Solution { /** * 递归解法 */ public TreeNode constructMaximumBinaryTree(int[] nums) { return build(nums, 0, nums.length - 1); } TreeNode build(int[] nums, int left, int right) { if (left \u003e right) { return null; } int maxValIndex = left; //注意：i\u003c=right //1. 找出区间最大值索引 for (int i = left; i \u003c= right; i++) { if (nums[i] \u003e nums[maxValIndex]) { maxValIndex = i; } } //2. 节点赋值 TreeNode ans = new TreeNode(nums[maxValIndex]); //3. 左右树递归 ans.left = build(nums, left, maxValIndex - 1); ans.right = build(nums, maxValIndex + 1, right); return ans; } } ","date":"2022-08-21","objectID":"/posts/tech/leetcode/tree/:13:0","tags":["二叉树","leetcode"],"title":"算法-二叉树","uri":"/posts/tech/leetcode/tree/"},{"categories":["leetcode"],"content":"从前序与中序遍历序列构造二叉树-M【不理解】 力扣第 105 题 从前序与中序遍历序列构造二叉树 ，看下题目 给定两个整数数组preorder 和 inorder，其中preorder 是二叉树的先序遍历， inorder是同一棵树的中序遍历，请构造二叉树并返回其根节点。 ","date":"2022-08-21","objectID":"/posts/tech/leetcode/tree/:14:0","tags":["二叉树","leetcode"],"title":"算法-二叉树","uri":"/posts/tech/leetcode/tree/"},{"categories":["leetcode"],"content":"通过后序和中序遍历结果构造二叉树-M [不理解] 类似上一题，这次我们利用后序和中序遍历的结果数组来还原二叉树，这是力扣第 106 题 从后序和中序遍历序列构造二叉树 ","date":"2022-08-21","objectID":"/posts/tech/leetcode/tree/:15:0","tags":["二叉树","leetcode"],"title":"算法-二叉树","uri":"/posts/tech/leetcode/tree/"},{"categories":["leetcode"],"content":"根据前序和后序遍历构造二叉树-M[不理解] 这是力扣第 889 题 根据前序和后序遍历构造二叉树 ，给你输入二叉树的前序和后序遍历结果，让你还原二叉树的结构。 通过前序中序，或者后序中序遍历结果可以确定唯一一棵原始二叉树，但是通过前序后序遍历结果无法确定唯一的原始二叉树。 ","date":"2022-08-21","objectID":"/posts/tech/leetcode/tree/:16:0","tags":["二叉树","leetcode"],"title":"算法-二叉树","uri":"/posts/tech/leetcode/tree/"},{"categories":["leetcode"],"content":"寻找重复的子树 力扣第 652 题 寻找重复的子树 给定一棵二叉树 root，返回所有重复的子树。 对于同一类的重复子树，你只需要返回其中任意一棵的根结点即可。 如果两棵树具有相同的结构和相同的结点值，则它们是重复的。 ","date":"2022-08-21","objectID":"/posts/tech/leetcode/tree/:17:0","tags":["二叉树","leetcode"],"title":"算法-二叉树","uri":"/posts/tech/leetcode/tree/"},{"categories":["leetcode"],"content":"链表 链表分带头结点的链表 和 不带头结点的链表； 所有的链表都有一个头指针head，带头结点的链表中head的数据项为空，而不带头的链表直接在头结点存入数据，那么当从头插入数据时，head需要时刻变化。 带头结点的单链表的的头结点一般数据域不存元素，指针域指向第一个结点，头指针（假设为pHead）指向头结点; 不带头结点的单链表，头指针指向单链表的第一个结点; 如果把链表中的结点进行编号，带头结点的链表的头结点可以理解为是其第0个结点，头指针pHead指向头结点即第0个结点，不带头结点的指针指向第1个结点。 ","date":"2022-08-21","objectID":"/posts/tech/leetcode/listnode/:0:0","tags":["链表","leetcode"],"title":"算法-链表","uri":"/posts/tech/leetcode/listnode/"},{"categories":["leetcode"],"content":"双指针技巧 ","date":"2022-08-21","objectID":"/posts/tech/leetcode/listnode/:1:0","tags":["链表","leetcode"],"title":"算法-链表","uri":"/posts/tech/leetcode/listnode/"},{"categories":["leetcode"],"content":"删除排序链表中的重复元素 力扣第 83 题「 删除排序链表中的重复元素」 给定一个已排序的链表的头 head ， 删除所有重复的元素，使每个元素只出现一次 。返回 已排序的链表 。 ListNode deleteDuplicates(ListNode head) { if (head == null) return null; ListNode slow = head, fast = head; while (fast != null) { if (fast.val != slow.val) { // nums[slow] = nums[fast]; slow.next = fast; // slow++; slow = slow.next; } // fast++ fast = fast.next; } // 断开与后面重复元素的连接 slow.next = null; return head; } ","date":"2022-08-21","objectID":"/posts/tech/leetcode/listnode/:1:1","tags":["链表","leetcode"],"title":"算法-链表","uri":"/posts/tech/leetcode/listnode/"},{"categories":["leetcode"],"content":"合并两个有序链表 这是最基本的链表技巧，力扣第 21 题 「 合并两个有序链表」 class Solution { /** * 法1- 迭代 * 参见讲解 * https://www.bilibili.com/video/BV1pZ4y1Y76v?spm_id_from=333.337.search-card.all.click */ public ListNode mergeTwoLists(ListNode list1, ListNode list2) { //定义新链表作为结果链表，首节点为哑结点，虚拟头结点 ListNode dump = new ListNode(0); //定义新链表的当前节点，也可以理解为尾部节点，作为指针参与和其他数值做比较运算 ListNode cur = dump; while (list1 != null \u0026\u0026 list2 != null) { // 比较 list1 和 list2 两个指针 // 将值较小的的节点接到 cur 指针 if (list2.val \u003e list1.val) { cur.next = list1; list1 = list1.next; } else { cur.next = list2; list2 = list2.next; } // cur 指针不断前进 cur = cur.next; } cur.next = (list1 == null) ? list2 : list1; return dump.next; } } /** * 法2- 递归调用 */ public ListNode mergeTwoLists(ListNode l1, ListNode l2) { if (l1 == null) { return l2; } else if (l2 == null) { return l1; } else if (l1.val \u003c l2.val) { l1.next = mergeTwoLists(l1.next, l2); return l1; } else { l2.next = mergeTwoLists(l1, l2.next); return l2; } } ","date":"2022-08-21","objectID":"/posts/tech/leetcode/listnode/:1:2","tags":["链表","leetcode"],"title":"算法-链表","uri":"/posts/tech/leetcode/listnode/"},{"categories":["leetcode"],"content":"单链表的分解 直接看下力扣第 86 题「 分隔链表」： class Solution { public ListNode partition(ListNode head, int x) { // 存放小于 x 的链表的虚拟头结点 ListNode dump1 = new ListNode(0); // 存放大于等于 x 的链表的虚拟头结点 ListNode dump2 = new ListNode(0); // cur1, cur2 指针负责生成结果链表 ListNode cur1 = dump1; ListNode cur2 = dump2; // 遍历原链表，类似合并两个有序链表的逻辑 // 这里是将一个链表分解成两个链表 while (head != null) { if (head.val \u003c x) { cur1.next = head; cur1 = cur1.next; } else { cur2.next = head; cur2 = cur2.next; } // 断开原链表中的每个节点的 next 指针 ??? 没理解 ！！！ ListNode tmp = head.next; head.next = null; head = tmp; } // 连接两个链表 cur1.next = dump2.next; return dump1.next; } } ","date":"2022-08-21","objectID":"/posts/tech/leetcode/listnode/:1:3","tags":["链表","leetcode"],"title":"算法-链表","uri":"/posts/tech/leetcode/listnode/"},{"categories":["leetcode"],"content":"合并 k 个有序链表 看下力扣第 23 题「 合并K个升序链表」 class Solution { /** * 法1: 使用优先队列合并 */ public ListNode mergeKLists(ListNode[] lists) { if (lists.length == 0) { return null; } //使用排序队列 PriorityQueue\u003cListNode\u003e pq = new PriorityQueue\u003c\u003e(lists.length, (a, b) -\u003e a.val - b.val); for (int i = 0; i \u003c lists.length; i++) { if (lists[i] != null) { pq.add(lists[i]); } } ListNode dump = new ListNode(0); ListNode cur = dump; while (!pq.isEmpty()) { ListNode node = pq.poll(); cur.next = node; cur = cur.next; if (node.next != null) { pq.add(node.next); } } return dump.next; } /** * 法2: 顺序合并 */ public ListNode mergeKLists(ListNode[] lists) { if (lists.length == 0) { return null; } ListNode ans = null; for (int i = 0; i \u003c lists.length; i++) { // mergeTwoLists 参照合并两个有序链表的解法 ans = mergeTwoLists(ans, lists[i]); } return ans; } } ","date":"2022-08-21","objectID":"/posts/tech/leetcode/listnode/:1:4","tags":["链表","leetcode"],"title":"算法-链表","uri":"/posts/tech/leetcode/listnode/"},{"categories":["leetcode"],"content":"（删除）单链表的倒数第 k 个节点 力扣第 19 题 删除链表的倒数第 N 个结点 给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。 进阶：你能尝试使用一趟扫描实现吗？ 从前往后寻找单链表的第 k 个节点很简单，一个 for 循环遍历过去就找到了，但是如何寻找从后往前数的第 k 个节点呢？ 那你可能说，假设链表有 n 个节点，倒数第 k 个节点就是正数第 n - k + 1 个节点，不也是一个 for 循环的事儿吗？ 是的，但是算法题一般只给你一个 ListNode 头结点代表一条单链表，你不能直接得出这条链表的长度 n，而需要先遍历一遍链表算出 n 的值，然后再遍历链表计算第 n - k + 1 个节点。 也就是说，这个解法需要遍历两次链表才能得到出倒数第 k 个节点。 那么，我们能不能只遍历一次链表，就算出倒数第 k 个节点？可以做到的，如果是面试问到这道题，面试官肯定也是希望你给出只需遍历一次链表的解法。 这个解法就比较巧妙了，假设 k = 2，思路如下： 首先，我们先让一个指针 p1 指向链表的头节点 head，然后走 k 步： 现在的 p1，只要再走 n - k 步，就能走到链表末尾的空指针了对吧？ 趁这个时候，再用一个指针 p2 指向链表头节点 head： 接下来就很显然了，让 p1 和 p2 同时向前走，p1 走到链表末尾的空指针时前进了 n - k 步，p2 也从 head 开始前进了 n - k 步，停留在第 n - k + 1 个节点上，即恰好停链表的倒数第 k 个节点上： 详细解释 refer to class Solution { /** * 法1：双指针，单次链表遍历 */ public ListNode removeNthFromEnd(ListNode head, int n) { // 虚拟头结点 ListNode dump = new ListNode(0); //注意此处 dump.next = head; // 删除倒数第 n 个，先找倒数第 n + 1 个节点 [注意此处 为n+1] ListNode objNode = findFromEnd(dump, n + 1); // 删掉倒数第 n 个节点 objNode.next = objNode.next.next; return dump.next; } // 返回链表的倒数第 n 个节点 public ListNode findFromEnd(ListNode head, int n) { ListNode p1 = head; // p1 先走 n 步 for (int i = 0; i \u003c n; i++) { p1 = p1.next; } ListNode p2 = head; // p1 和 p2 同时走 len - k 步 while (p1 != null) { p1 = p1.next; p2 = p2.next; } // p2 现在指向第 len - n + 1 个节点，即倒数第 n 个节点 return p2; } /** * 法2：2次链表遍历； 先循环查询链表总长度，在走到特定节点，操作； */ public ListNode removeNthFromEnd2(ListNode head, int n) { ListNode dummy = new ListNode(0, head); int length = getLength(head); ListNode cur = dummy; for (int i = 1; i \u003c length - n + 1; ++i) { cur = cur.next; } cur.next = cur.next.next; //注意：此处return不能是cur.next，原因？ return dummy.next; // ListNode ans = dummy.next; // return ans; } public int getLength(ListNode head) { int length = 0; while (head != null) { ++length; head = head.next; } return length; } } ","date":"2022-08-21","objectID":"/posts/tech/leetcode/listnode/:1:5","tags":["链表","leetcode"],"title":"算法-链表","uri":"/posts/tech/leetcode/listnode/"},{"categories":["leetcode"],"content":"单链表的中点 [错题] 力扣第 876 题「 链表的中间结点」 问题的关键也在于我们无法直接得到单链表的长度 n，常规方法也是先遍历链表计算 n，再遍历一次得到第 n / 2 个节点，也就是中间节点。 如果想一次遍历就得到中间节点，也需要耍点小聪明，使用「快慢指针」的技巧： 我们让两个指针 slow 和 fast 分别指向链表头结点 head。 每当慢指针 slow 前进一步，快指针 fast 就前进两步，这样，当 fast 走到链表末尾时，slow 就指向了链表中点。 class Solution { ListNode middleNode(ListNode head) { // 快慢指针初始化指向 head ListNode slow = head, fast = head; // 快指针走到末尾时停止 while (fast != null \u0026\u0026 fast.next != null) { // 慢指针走一步，快指针走两步 slow = slow.next; fast = fast.next.next; } // 慢指针指向中点 return slow; } } 需要注意的是，如果链表长度为偶数，也就是说中点有两个的时候，我们这个解法返回的节点是靠后的那个节点。 另外，这段代码稍加修改就可以直接用到判断链表成环的算法题上。 ","date":"2022-08-21","objectID":"/posts/tech/leetcode/listnode/:1:6","tags":["链表","leetcode"],"title":"算法-链表","uri":"/posts/tech/leetcode/listnode/"},{"categories":["leetcode"],"content":"判断链表是否包含环 boolean hasCycle(ListNode head) { // 快慢指针初始化指向 head ListNode slow = head, fast = head; // 快指针走到末尾时停止 while (fast != null \u0026\u0026 fast.next != null) { // 慢指针走一步，快指针走两步 slow = slow.next; fast = fast.next.next; // 快慢指针相遇，说明含有环 if (slow == fast) { return true; } } // 不包含环 return false; } 当然，这个问题还有进阶版：如果链表中含有环，如何计算这个环的起点？ ","date":"2022-08-21","objectID":"/posts/tech/leetcode/listnode/:1:7","tags":["链表","leetcode"],"title":"算法-链表","uri":"/posts/tech/leetcode/listnode/"},{"categories":["leetcode"],"content":"链表包含环的起点 ListNode detectCycle(ListNode head) { ListNode fast, slow; fast = slow = head; while (fast != null \u0026\u0026 fast.next != null) { fast = fast.next.next; slow = slow.next; if (fast == slow) break; } // 上面的代码类似 hasCycle 函数 if (fast == null || fast.next == null) { // fast 遇到空指针说明没有环 return null; } // 重新指向头结点 slow = head; // 快慢指针同步前进，相交点就是环起点 while (slow != fast) { fast = fast.next; slow = slow.next; } return slow; } 可以看到，当快慢指针相遇时，让其中任一个指针指向头节点，然后让它俩以相同速度前进，再次相遇时所在的节点位置就是环开始的位置。 为什么要这样呢？这里简单说一下其中的原理。 我们假设快慢指针相遇时，慢指针 slow 走了 k 步，那么快指针 fast 一定走了 2k 步： ","date":"2022-08-21","objectID":"/posts/tech/leetcode/listnode/:1:8","tags":["链表","leetcode"],"title":"算法-链表","uri":"/posts/tech/leetcode/listnode/"},{"categories":["leetcode"],"content":"两个链表是否相交 力扣第 160 题「 相交链表」 public class Solution { /** * 方法1 ： 双指针 On (a+b) */ public ListNode getIntersectionNode(ListNode headA, ListNode headB) { // p1 指向 A 链表头结点，p2 指向 B 链表头结点 ListNode p1 = headA, p2 = headB; while (p1 != p2) { // p1 走一步，如果走到 A 链表末尾，转到 B 链表 if (p1 == null) { p1 = headB; } else { p1 = p1.next; } // p2 走一步，如果走到 B 链表末尾，转到 A 链表 if (p2 == null) { p2 = headA; } else { p2 = p2.next; } } return p1; } /** * 方法2 哈希 */ public ListNode getIntersectionNode2(ListNode headA, ListNode headB) { Set\u003cListNode\u003e set = new HashSet\u003c\u003e(); ListNode temp = headA; while (temp != null) { set.add(temp); temp = temp.next; } temp = headB; while (temp != null) { if (set.contains(temp)) { return temp; } temp = temp.next; } return null; } } ","date":"2022-08-21","objectID":"/posts/tech/leetcode/listnode/:1:9","tags":["链表","leetcode"],"title":"算法-链表","uri":"/posts/tech/leetcode/listnode/"},{"categories":["leetcode"],"content":"回文链表-E 力扣第 234 题回文链表 给你一个单链表的头节点 head ，请你判断该链表是否为回文链表。如果是，返回 true ；否则，返回 false 。 class Solution { /** * 1. 链表遍历 值存list * 2. 对list 进行左右双指针 回文判断 */ public boolean isPalindrome(ListNode head) { List\u003cInteger\u003e vals =new ArrayList\u003cInteger\u003e(); ListNode dump = head; while(dump!=null){ vals.add(dump.val); //注意此处赋值为 dump.next dump = dump.next; } int left=0, right=vals.size()-1; while(left\u003cright){ if(!vals.get(left).equals(vals.get(right))){ return false; } left++; right--; } return true; } } ","date":"2022-08-21","objectID":"/posts/tech/leetcode/listnode/:1:10","tags":["链表","leetcode"],"title":"算法-链表","uri":"/posts/tech/leetcode/listnode/"},{"categories":["leetcode"],"content":"环形链表-E 力扣第 141 题环形链表 给你一个链表的头节点 head ，判断链表中是否有环。 如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 public class Solution { /** * 法1： 哈希 */ public boolean hasCycle(ListNode head) { Set\u003cListNode\u003e seen = new HashSet\u003cListNode\u003e(); while (head != null) { if (!seen.add(head)) { return true; } head = head.next; } return false; } /** * 法2：双指针 */ public boolean hasCycle2(ListNode head) { if (head == null || head.next == null) { return false; } ListNode slow = head; //注意：此处fast定义 ListNode fast = head.next; //注意：循环条件 while (slow != fast) { //注意：此处判断条件 if (fast == null || fast.next == null) { return false; } slow = slow.next; fast = fast.next.next; } return true; } } ","date":"2022-08-21","objectID":"/posts/tech/leetcode/listnode/:1:11","tags":["链表","leetcode"],"title":"算法-链表","uri":"/posts/tech/leetcode/listnode/"},{"categories":["leetcode"],"content":"递归魔法：反转单链表 什么叫反转单链表的一部分呢，就是给你一个索引区间，让你把单链表中这部分元素反转，其他部分不变。 看下力扣第 92 题「 反转链表 II」： ","date":"2022-08-21","objectID":"/posts/tech/leetcode/listnode/:2:0","tags":["链表","leetcode"],"title":"算法-链表","uri":"/posts/tech/leetcode/listnode/"},{"categories":["leetcode"],"content":"递归反转整个链表 【太绕，没理解！！】 这也是力扣第 206 题「 反转链表」 可以使用递归的3个条件： 大问题拆成2个子问题。 子问题求解方式和大问题一样。 存在最小子问题。 class Solution { /** * 方法1： 迭代反转 * 单链表反转视频讲解： https://leetcode.cn/problems/reverse-linked-list/solution/shi-pin-jiang-jie-die-dai-he-di-gui-hen-hswxy/ */ public ListNode reverseList(ListNode head) { ListNode prev = null; ListNode curr = head; while (curr != null) { //next 为临时变量，做数据临时存储 ListNode next = curr.next; curr.next = prev; prev = curr; curr = next; } return prev; } /** * 方法2：递归反转 * 视频讲解 https://leetcode.cn/problems/reverse-linked-list/solution/shi-pin-jiang-jie-die-dai-he-di-gui-hen-hswxy/ */ public ListNode reverseList2(ListNode head) { if (head == null || head.next == null) { return head; } ListNode last = reverseList2(head.next); head.next.next = head; head.next = null; return last; } } ","date":"2022-08-21","objectID":"/posts/tech/leetcode/listnode/:2:1","tags":["链表","leetcode"],"title":"算法-链表","uri":"/posts/tech/leetcode/listnode/"},{"categories":["leetcode"],"content":"反转链表前 N 个节点【没看懂！！】 解决思路和反转整个链表差不多，只要稍加修改即可： ListNode successor = null; // 后驱节点 // 反转以 head 为起点的 n 个节点，返回新的头结点 ListNode reverseN(ListNode head, int n) { if (n == 1) { // 记录第 n + 1 个节点 successor = head.next; return head; } // 以 head.next 为起点，需要反转前 n - 1 个节点 ListNode last = reverseN(head.next, n - 1); head.next.next = head; // 让反转之后的 head 节点和后面的节点连起来 head.next = successor; return last; } ","date":"2022-08-21","objectID":"/posts/tech/leetcode/listnode/:2:2","tags":["链表","leetcode"],"title":"算法-链表","uri":"/posts/tech/leetcode/listnode/"},{"categories":["leetcode"],"content":"反转链表的一部分 refer to ","date":"2022-08-21","objectID":"/posts/tech/leetcode/listnode/:2:3","tags":["链表","leetcode"],"title":"算法-链表","uri":"/posts/tech/leetcode/listnode/"},{"categories":["leetcode"],"content":"总结 递归的思想相对迭代思想，稍微有点难以理解，处理的技巧是：不要跳进递归，而是利用明确的定义来实现算法逻辑。 处理看起来比较困难的问题，可以尝试化整为零，把一些简单的解法进行修改，解决困难的问题。 值得一提的是，递归操作链表并不高效。和迭代解法相比，虽然时间复杂度都是 O(N)，但是迭代解法的空间复杂度是 O(1)，而递归解法需要堆栈，空间复杂度是 O(N)。 所以递归操作链表可以作为对递归算法的练习或者拿去和小伙伴装逼，但是考虑效率的话还是使用迭代算法更好。 ","date":"2022-08-21","objectID":"/posts/tech/leetcode/listnode/:3:0","tags":["链表","leetcode"],"title":"算法-链表","uri":"/posts/tech/leetcode/listnode/"},{"categories":["leetcode"],"content":"K 个一组翻转链表 力扣第 25 题「 K 个一组翻转链表」 refet to 其他 ","date":"2022-08-21","objectID":"/posts/tech/leetcode/listnode/:4:0","tags":["链表","leetcode"],"title":"算法-链表","uri":"/posts/tech/leetcode/listnode/"},{"categories":["leetcode"],"content":"删除链表中的节点 力扣第 237 题删除链表中的节点 请编写一个函数，用于 删除单链表中某个特定节点 。在设计函数时需要注意，你无法访问链表的头节点 head ，只能直接访问 要被删除的节点 。 题目数据保证需要删除的节点 不是末尾节点 。 class Solution { public void deleteNode(ListNode node) { node.val = node.next.val; node.next = node.next.next; } } ","date":"2022-08-21","objectID":"/posts/tech/leetcode/listnode/:5:0","tags":["链表","leetcode"],"title":"算法-链表","uri":"/posts/tech/leetcode/listnode/"},{"categories":["tech"],"content":"方式1 使用 codeinword 在线工具，选择code对应的语言后，生成copy，粘贴到word中即可。 方式2 使用 Visual Studio code. VSCode 支持复制后直接粘贴到word即是着色后的代码高亮的效果。 注意： 用vscode 写完代码后，一定要保存为指定的格式文件(如.java)； 复制vscode 代码到word，完美。 因为微软自家的软件所用的字符格式是相通的，比如说你写工作邮件，想要从word 或者excel 复制内容到chrome 网页版的邮箱里，这时候你可能发现格式丢失，如果使用微软自家浏览器edge 或者 ie 就不会有这个问题。 ","date":"2022-08-21","objectID":"/posts/tech/tools/wordcode/:0:0","tags":["tools"],"title":"Word中如何插入代码块？","uri":"/posts/tech/tools/wordcode/"},{"categories":["leetcode"],"content":"数组/单链表系列算法 单链表常考的技巧就是双指针 比如判断单链表是否成环，拍脑袋的暴力解是什么？就是用一个 HashSet 之类的数据结构来缓存走过的节点，遇到重复的就说明有环对吧。但我们用快慢指针可以避免使用额外的空间，这就是聪明地穷举嘛。 当然，对于找链表中点这种问题，使用双指针技巧只是显示你学过这个技巧，和遍历两次链表的常规解法从时间空间复杂度的角度来说都是差不多的。 数组常用的技巧有很大一部分还是双指针相关的技巧，说白了是教你如何聪明地进行穷举。 首先说二分搜索技巧，可以归为两端向中心的双指针。如果让你在数组中搜索元素，一个 for 循环穷举肯定能搞定对吧，但如果数组是有序的，二分搜索不就是一种更聪明的搜索方式么。 数组算法 双指针技巧 在处理数组和链表相关问题时，双指针技巧是经常用到的，双指针技巧主要分为两类：左右指针和快慢指针。 所谓左右指针，就是两个指针相向而行或者相背而行；而所谓快慢指针，就是两个指针同向而行，一快一慢。 ","date":"2022-08-19","objectID":"/posts/tech/leetcode/array/:0:0","tags":["数组","leetcode"],"title":"算法-数组","uri":"/posts/tech/leetcode/array/"},{"categories":["leetcode"],"content":"一、快慢指针技巧 数组问题中比较常见的快慢指针技巧，是让你原地修改数组。 ","date":"2022-08-19","objectID":"/posts/tech/leetcode/array/:1:0","tags":["数组","leetcode"],"title":"算法-数组","uri":"/posts/tech/leetcode/array/"},{"categories":["leetcode"],"content":"删除有序数组中的重复项 第 26 题「 删除有序数组中的重复项」 class Solution { public int removeDuplicates(int[] nums) { int len = nums.length; if (len == 0) { return 0; } //此处slow 代表新数组的长度，至少是1起 int slow = 1; //此处fast 代表比较指针，参与值比较 int fast = 1; while (fast \u003c len) { if (nums[fast] != nums[fast-1]) { nums[slow] = nums[fast]; slow++; } fast++; } return slow; } } ","date":"2022-08-19","objectID":"/posts/tech/leetcode/array/:1:1","tags":["数组","leetcode"],"title":"算法-数组","uri":"/posts/tech/leetcode/array/"},{"categories":["leetcode"],"content":"删除排序链表中的重复元素 第 83 题 删除排序链表中的重复元素 /** * 双指针 */ ListNode deleteDuplicates(ListNode head) { if (head == null) { return null; } ListNode slow = head, fast = head; while (fast != null) { if (fast.val != slow.val) { // nums[slow] = nums[fast]; slow.next = fast; // slow++; slow = slow.next; } // fast++ fast = fast.next; } // 断开与后面重复元素的连接 slow.next = null; return head; } /** * 单指针 */ ListNode deleteDuplicates1(ListNode head) { if (head == null) { return head; } ListNode cur = head; while (cur.next != null) { if (cur.val == cur.next.val) { cur.next = cur.next.next; } else { cur = cur.next; } } return head; } 除了让你在有序数组/链表中去重，题目还可能让你对数组中的某些元素进行「原地删除」。 ","date":"2022-08-19","objectID":"/posts/tech/leetcode/array/:1:2","tags":["数组","leetcode"],"title":"算法-数组","uri":"/posts/tech/leetcode/array/"},{"categories":["leetcode"],"content":"移除元素 如力扣第 27 题「 移除元素」 class Solution { /** * 移动完成后， nums[0]-nums[slow-1] 之间不包含val； nums[slow]-nums[nums.Length-1] 之间包含val */ public int removeElement(int[] nums, int val) { int slow = 0 ; int len = nums.length; for (int i = 0; i \u003c len; i++) { if (nums[i] != val) { // nums[slow] = nums[i]; // slow++; //等同于上面 nums[slow++] = nums[i]; } } return slow; } } ","date":"2022-08-19","objectID":"/posts/tech/leetcode/array/:1:3","tags":["数组","leetcode"],"title":"算法-数组","uri":"/posts/tech/leetcode/array/"},{"categories":["leetcode"],"content":"移动零-E 第 283 题「 移动零」 给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。 请注意 ，必须在不复制数组的情况下原地对数组进行操作。 class Solution { public void moveZeroes(int[] nums) { int tmp = 0; int last = nums.length - 1; for (int i = 0; i \u003c nums.length; i++) { if (nums[i] != 0) { // nums[tmp] = nums[i]; // tmp++; //等同于上述 nums[tmp++] = nums[i]; } } while (tmp \u003c nums.length) { // nums[tmp] = 0; // tmp++; //等同于上述 nums[tmp++] = 0; } } } ","date":"2022-08-19","objectID":"/posts/tech/leetcode/array/:1:4","tags":["数组","leetcode"],"title":"算法-数组","uri":"/posts/tech/leetcode/array/"},{"categories":["leetcode"],"content":"合并两个有序数组 第 88 题 合并两个有序数组 给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。 请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。 最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。 class Solution { /** * 方法1：双指针法 （低耗时） */ public void merge(int[] nums1, int m, int[] nums2, int n) { int[] array = new int[m + n]; int p1 = 0; int p2 = 0; int v; while (p1 \u003c m || p2 \u003c n) { if (p1 == m) { v = nums2[p2++]; } else if (p2 == n) { v = nums1[p1++]; } else if (nums1[p1] \u003e nums2[p2]) { v = nums2[p2++]; } else { v = nums1[p1++]; } array[p1 + p2 - 1] = v; } for (int i = 0; i != m + n; ++i) { nums1[i] = array[i]; } } /** * 方法2：直接合并后排序 * 运用函数 */ // public void merge(int[] nums1, int m, int[] nums2, int n) { // for (int i = 0; i \u003c n; i++) { // nums1[m + i] = nums2[i]; // } // Arrays.sort(nums1); // } } ","date":"2022-08-19","objectID":"/posts/tech/leetcode/array/:1:5","tags":["数组","leetcode"],"title":"算法-数组","uri":"/posts/tech/leetcode/array/"},{"categories":["leetcode"],"content":"二、左右指针的常用算法 1、二分查找 最简单的二分算法，旨在突出它的双指针特性： int binarySearch(int[] nums, int target) { // 一左一右两个指针相向而行 int left = 0, right = nums.length - 1; while(left \u003c= right) { int mid = (right + left) / 2; if(nums[mid] == target) return mid; else if (nums[mid] \u003c target) left = mid + 1; else if (nums[mid] \u003e target) right = mid - 1; } return -1; } ","date":"2022-08-19","objectID":"/posts/tech/leetcode/array/:2:0","tags":["数组","leetcode"],"title":"算法-数组","uri":"/posts/tech/leetcode/array/"},{"categories":["leetcode"],"content":"两数之和 2、两数之和 看下力扣第 167 题「 两数之和 II」 只要数组有序，就应该想到双指针技巧。这道题的解法有点类似二分查找，通过调节 left 和 right 就可以调整 sum 的大小： int[] twoSum(int[] nums, int target) { // 一左一右两个指针相向而行 int left = 0, right = nums.length - 1; while (left \u003c right) { int sum = nums[left] + nums[right]; if (sum == target) { // 题目要求的索引是从 1 开始的 return new int[]{left + 1, right + 1}; } else if (sum \u003c target) { left++; // 让 sum 大一点 } else if (sum \u003e target) { right--; // 让 sum 小一点 } } return new int[]{-1, -1}; } ","date":"2022-08-19","objectID":"/posts/tech/leetcode/array/:2:1","tags":["数组","leetcode"],"title":"算法-数组","uri":"/posts/tech/leetcode/array/"},{"categories":["leetcode"],"content":"反转数组 一般编程语言都会提供 reverse 函数，其实这个函数的原理非常简单，力扣第 344 题「 反转字符串」 就是类似的需求，让你反转一个 char[] 类型的字符数组， void reverseString(char[] s) { // 一左一右两个指针相向而行 int left = 0, right = s.length - 1; while (left \u003c right) { // 交换 s[left] 和 s[right] char temp = s[left]; s[left] = s[right]; s[right] = temp; left++; right--; } } ","date":"2022-08-19","objectID":"/posts/tech/leetcode/array/:2:2","tags":["数组","leetcode"],"title":"算法-数组","uri":"/posts/tech/leetcode/array/"},{"categories":["leetcode"],"content":"回文串判断 首先明确一下，回文串就是正着读和反着读都一样的字符串。 比如说字符串 aba 和 abba 都是回文串，因为它们对称，反过来还是和本身一样；反之，字符串 abac 就不是回文串。 现在你应该能感觉到回文串问题和左右指针肯定有密切的联系，比如让你判断一个字符串是不是回文串，你可以写出下面这段代码： boolean isPalindrome(String s) { // 一左一右两个指针相向而行 int left = 0, right = s.length() - 1; while (left \u003c right) { if (s.charAt(left) != s.charAt(right)) { return false; } left++; right--; } return true; } 那接下来我提升一点难度，给你一个字符串，让你用双指针技巧从中找出最长的回文串，你会做吗？ ","date":"2022-08-19","objectID":"/posts/tech/leetcode/array/:2:3","tags":["数组","leetcode"],"title":"算法-数组","uri":"/posts/tech/leetcode/array/"},{"categories":["leetcode"],"content":"最长回文子串 这就是力扣第 5 题「 最长回文子串」 class Solution { /** * 中心扩展算法 * 找到以 s[i] 为中心的回文串 * 找到以 s[i] 和 s[i+1] 为中心的回文串 * 更新答案 */ public String longestPalindrome(String s) { String maxStr = \"\"; for (int i = 0; i \u003c s.length(); i++) { // 以 s[i] 为中心的最长回文子串 String tmp = queryLongStr(s, i, i); maxStr = maxStr.length() \u003e tmp.length() ? maxStr : tmp; // 以 s[i] 和 s[i+1] 为中心的最长回文子串 tmp = queryLongStr(s, i, i + 1); maxStr = maxStr.length() \u003e tmp.length() ? maxStr : tmp; } return maxStr; } // 在 s 中寻找以 s[l] 和 s[r] 为中心的最长回文串 public String queryLongStr(String s, int l, int r) { // 防止索引越界 while (l \u003e= 0 \u0026\u0026 r \u003c s.length() \u0026\u0026 s.charAt(l) == s.charAt(r)) { // 双指针，向两边展开 l--; r++; } // 返回以 s[l] 和 s[r] 为中心的最长回文串 return s.substring(l + 1, r); } } ","date":"2022-08-19","objectID":"/posts/tech/leetcode/array/:2:4","tags":["数组","leetcode"],"title":"算法-数组","uri":"/posts/tech/leetcode/array/"},{"categories":["leetcode"],"content":"第一个错误的版本 力扣第 278 题 第一个错误的版本 你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。 假设你有 n 个版本 [1, 2, …, n]，你想找出导致之后所有版本出错的第一个错误的版本。 你可以通过调用bool isBadVersion(version)接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。 public class Solution extends VersionControl { /** * 二分查找 * 注意到一个性质：当一个版本为正确版本，则该版本之前的所有版本均为正确版本；当一个版本为错误版本，则该版本之后的所有版本均为错误版本。我们可以利用这个性质进行二分查找。 */ public int firstBadVersion(int n) { int left=0,right=n; while(left\u003cright){ int middle =left+(right-left)/2; if(isBadVersion(middle)){ right=middle; }else{ left=middle+1; } } return left; } } ","date":"2022-08-19","objectID":"/posts/tech/leetcode/array/:2:5","tags":["数组","leetcode"],"title":"算法-数组","uri":"/posts/tech/leetcode/array/"},{"categories":["leetcode"],"content":"两个数组的交集 II-E【重复】 力扣第 350 题 两个数组的交集 II 给你两个整数数组nums1 和 nums2 ，请你以数组形式返回两数组的交集。返回结果中每个元素出现的次数，应与元素在两个数组中都出现的次数一致（如果出现次数不一致，则考虑取较小值）。可以不考虑输出结果的顺序。 class Solution { public int[] intersect(int[] nums1, int[] nums2) { Arrays.sort(nums1); Arrays.sort(nums2); int len = nums1.length\u003enums2.length ? nums1.length : nums2.length;; int[] result = new int[len]; int left1=0,left2=0; int i=0; while(left1\u003cnums1.length \u0026\u0026 left2\u003cnums2.length){ if(nums1[left1]==nums2[left2]){ result[i]=nums1[left1]; i++; left1++; left2++; }else if(nums1[left1]\u003enums2[left2]){ left2++; }else if(nums1[left1]\u003cnums2[left2]){ left1++; } } int[] res = new int[i]; for(int n=0;n\u003ci;n++){ res[n]=result[n]; } return res; } } 算法技巧：[前缀和]数组 前缀和主要适用的场景是原始数组不会被修改的情况下，频繁查询某个区间的累加和。 ","date":"2022-08-19","objectID":"/posts/tech/leetcode/array/:2:6","tags":["数组","leetcode"],"title":"算法-数组","uri":"/posts/tech/leetcode/array/"},{"categories":["leetcode"],"content":"一维数组中的 [前缀和] 力扣第 303 题「 区域和检索 - 数组不可变」 ，让你计算数组区间内元素的和，这是一道标准的前缀和问题 class NumArray { // 前缀和数组 int[] sum; /* 输入一个数组，构造前缀和 */ public NumArray(int[] nums) { int len = nums.length(); sum = new int[len + 1]; for (int i = 0; i \u003c len; i++) { // 计算 nums 的累加和 //注意，此处为 sum[i + 1] sum[i + 1] = sum[i] + nums[i]; } } /* 查询闭区间 [left, right] 的累加和 */ public int sumRange(int left, int right) { return sum[right + 1] - sum[left]; } } ","date":"2022-08-19","objectID":"/posts/tech/leetcode/array/:3:0","tags":["数组","leetcode"],"title":"算法-数组","uri":"/posts/tech/leetcode/array/"},{"categories":["leetcode"],"content":"二维矩阵中的 [前缀和] 力扣第 304 题「 二维区域和检索 - 矩阵不可变」 ，其实和上一题类似，上一题是让你计算子数组的元素之和，这道题让你计算二维矩阵中子矩阵的元素之和。 class NumMatrix { // 定义：preSum[i][j] 记录 matrix 中子矩阵 [0, 0, i-1, j-1] 的元素和 int[][] preSum; public NumMatrix(int[][] matrix) { int height = matrix.length; int width = matrix[0].length; if (height == 0 || width == 0){ return; } // 构造前缀和矩阵 preSum = new int[height+1][width+1]; for (int i = 1; i \u003c= height; i++) { for (int j = 1; j \u003c= width; j++) { // 计算每个矩阵 [0, 0, i, j] 的元素和 preSum[i][j] = preSum[i - 1][j] + preSum[i][j - 1] - preSum[i - 1][j - 1] + matrix[i - 1][j - 1]; } } } // 计算子矩阵 [x1, y1, x2, y2] 的元素和 public int sumRegion(int row1, int col1, int row2, int col2) { // 目标矩阵之和由四个相邻矩阵运算获得 [此处注意坐标] return preSum[row2+1][col2+1] - preSum[row1][col2+1] - preSum[row2+1][col1] + preSum[row1][col1]; } } 算法技巧：差分数组 差分数组的主要适用场景是频繁对原始数组的某个区间的元素进行增减。 差分数组对应的概念是前缀 和 数组，对于数组 [1,2,2,4]，其差分数组为 [1,1,0,2] 事例：https://labuladong.gitee.io/algo/2/20/25/ class NumMatrix { // 定义：preSum[i][j] 记录 matrix 中子矩阵 [0, 0, i-1, j-1] 的元素和 int[][] preSum; public NumMatrix(int[][] matrix) { int height = matrix.length; int width = matrix[0].length; if (height == 0 || width == 0){ return; } // 构造前缀和矩阵 preSum = new int[height+1][width+1]; for (int i = 1; i \u003c= height; i++) { for (int j = 1; j \u003c= width; j++) { // 计算每个矩阵 [0, 0, i, j] 的元素和 preSum[i][j] = preSum[i - 1][j] + preSum[i][j - 1] - preSum[i - 1][j - 1] + matrix[i - 1][j - 1]; } } } // 计算子矩阵 [x1, y1, x2, y2] 的元素和 public int sumRegion(int row1, int col1, int row2, int col2) { // 目标矩阵之和由四个相邻矩阵运算获得 [此处注意坐标] return preSum[row2+1][col2+1] - preSum[row1][col2+1] - preSum[row2+1][col1] + preSum[row1][col1]; } } 比如说，我给你输入一个数组 nums，然后又要求给区间 nums[2..6] 全部加 1，再给 nums[3..9] 全部减 3，再给 nums[0..4] 全部加 2，再给… 一通操作猛如虎，然后问你，最后 nums 数组的值是什么？ 常规的思路很容易，你让我给区间 nums[i..j] 加上 val，那我就一个 for 循环给它们都加上呗，还能咋样？这种思路的时间复杂度是 O(N)，由于这个场景下对 nums 的修改非常频繁，所以效率会很低下。 这里就需要差分数组的技巧，类似前缀和技巧构造的 prefix 数组，我们先对 nums 数组构造一个 diff 差分数组，diff[i] 就是 nums[i] 和 nums[i-1] 之差： int[] diff = new int[nums.length]; // 构造差分数组 diff[0] = nums[0]; for (int i = 1; i \u003c nums.length; i++) { diff[i] = nums[i] - nums[i - 1]; } 通过这个 diff 差分数组是可以反推出原始数组 nums 的，代码逻辑如下： int[] res = new int[diff.length]; // 根据差分数组构造结果数组 res[0] = diff[0]; for (int i = 1; i \u003c diff.length; i++) { res[i] = res[i - 1] + diff[i]; } 这样构造差分数组 diff，就可以快速进行区间增减的操作，如果你想对区间 nums[i..j] 的元素全部加 3，那么只需要让 diff[i] += 3，然后再让 diff[j+1] -= 3 即可; 力扣第 370 题「 区间加法」 就直接考察了差分数组技巧 int[] getModifiedArray(int length, int[][] updates) { // nums 初始化为全 0 int[] nums = new int[length]; // 构造差分解法 Difference df = new Difference(nums); for (int[] update : updates) { int i = update[0]; int j = update[1]; int val = update[2]; df.increment(i, j, val); } return df.result(); } // 差分数组工具类 class Difference { // 差分数组 private int[] diff; /* 输入一个初始数组，区间操作将在这个数组上进行 */ public Difference(int[] nums) { assert nums.length \u003e 0; diff = new int[nums.length]; // 根据初始数组构造差分数组 diff[0] = nums[0]; for (int i = 1; i \u003c nums.length; i++) { diff[i] = nums[i] - nums[i - 1]; } } /* 给闭区间 [i, j] 增加 val（可以是负数）*/ public void increment(int i, int j, int val) { diff[i] += val; if (j + 1 \u003c diff.length) { diff[j + 1] -= val; } } /* 返回结果数组 */ public int[] result() { int[] res = new int[diff.length]; // 根据差分数组构造结果数组 res[0] = diff[0]; for (int i = 1; i \u003c diff.length; i++) { res[i] = res[i - 1] + diff[i]; } return res; } } ","date":"2022-08-19","objectID":"/posts/tech/leetcode/array/:4:0","tags":["数组","leetcode"],"title":"算法-数组","uri":"/posts/tech/leetcode/array/"},{"categories":["leetcode"],"content":"航班预定 实际的算法题可能需要我们对题目进行联想和抽象，不会这么直接地让你看出来要用差分数组技巧，这里看一下力扣第 1109 题「 航班预订统计」 这里有 n 个航班，它们分别从 1 到 n 进行编号。 有一份航班预订表 bookings ，表中第 i 条预订记录 bookings[i] = [firsti, lasti, seatsi] 意味着在从 firsti 到 lasti （包含 firsti 和 lasti ）的 每个航班 上预订了 seatsi 个座位。 请你返回一个长度为 n 的数组 answer，里面的元素是每个航班预定的座位总数。 示例 1： 输入：bookings = [[1,2,10],[2,3,20],[2,5,25]], n = 5 输出：[10,55,45,25,25] 解释： 航班编号 1 2 3 4 5 预订记录 1 ： 10 10 预订记录 2 ： 20 20 预订记录 3 ： 25 25 25 25 总座位数： 10 55 45 25 25 因此，answer = [10,55,45,25,25] class Solution { public int[] corpFlightBookings(int[][] bookings, int n) { // nums 初始化为全 0 int[] nums = new int[n]; // 构造差分解法 Difference df = new Difference(nums); for (int[] booking : bookings) { // 注意转成数组索引要减一哦 int i = booking[0] - 1; int j = booking[1] - 1; int val = booking[2]; // 对区间 nums[i..j] 增加 val df.increment(i, j, val); } // 返回最终的结果数组 return df.result(); } } // 差分数组工具类 class Difference { // 差分数组 private int[] diff; /* 输入一个初始数组，区间操作将在这个数组上进行 */ public Difference(int[] nums) { diff = new int[nums.length]; // 根据初始数组构造差分数组 diff[0] = nums[0]; for (int i = 1; i \u003c nums.length; i++) { diff[i] = nums[i] - nums[i - 1]; } } /* 给闭区间 [i, j] 增加 val（可以是负数）*/ public void increment(int i, int j, int val) { diff[i] += val; if (j + 1 \u003c diff.length) { diff[j + 1] -= val; } } /* 返回结果数组 */ public int[] result() { int[] res = new int[diff.length]; // 根据差分数组构造结果数组 res[0] = diff[0]; for (int i = 1; i \u003c diff.length; i++) { res[i] = res[i - 1] + diff[i]; } return res; } } ","date":"2022-08-19","objectID":"/posts/tech/leetcode/array/:5:0","tags":["数组","leetcode"],"title":"算法-数组","uri":"/posts/tech/leetcode/array/"},{"categories":["leetcode"],"content":"拼车 还有一道很类似的题目是力扣第 1094 题「 拼车」 class Solution { public boolean carPooling(int[][] trips, int capacity) { //注意此处的初始化定义 // 最多有 1001 个车站 int[] nums = new int[1001]; // 构造差分解法 Tools tools = new Tools(nums); for (int[] array : trips) { int v = array[0]; // 第 trip[1] 站乘客上车 int i = array[1]; //注意此处赋值 // 第 trip[2] 站乘客已经下车， // 即乘客在车上的区间是 [trip[1], trip[2] - 1] int j = array[2] - 1; tools.add(i, j, v); } int[] res = tools.result(); // 客车自始至终都不应该超载 for (int r : res) { if (r \u003e capacity) { return false; } } return true; } } // 差分数组工具类 class Tools { int preSum[]; public Tools(int[] array) { int len = array.length; preSum = new int[len]; // 根据初始数组构造差分数组 preSum[0] = array[0]; for (int i = 1; i \u003c array.length; i++) { preSum[i] = array[i] - array[i - 1]; } } /* 给闭区间 [i, j] 增加 val（可以是负数）*/ public void add(int i, int j, int v) { preSum[i] += v; if (j + 1 \u003c preSum.length) { preSum[j + 1] -= v; } } /* 返回结果数组 */ public int[] result() { int[] result = new int[preSum.length]; // 根据差分数组构造结果数组 result[0] = preSum[0]; for (int i = 1; i \u003c preSum.length; i++) { //注意此处为 preSum[i] + result[i - 1]; result[i] = preSum[i] + result[i - 1]; } return result; } } 二维数组的花式遍历技巧 ","date":"2022-08-19","objectID":"/posts/tech/leetcode/array/:6:0","tags":["数组","leetcode"],"title":"算法-数组","uri":"/posts/tech/leetcode/array/"},{"categories":["leetcode"],"content":"顺/逆时针旋转矩阵 ","date":"2022-08-19","objectID":"/posts/tech/leetcode/array/:7:0","tags":["数组","leetcode"],"title":"算法-数组","uri":"/posts/tech/leetcode/array/"},{"categories":["leetcode"],"content":"旋转图像 对二维数组进行旋转是常见的笔试题，力扣第 48 题「 旋转图像」 就是很经典的一道： class Solution { // 将二维矩阵原地顺时针旋转 90 度 public void rotate(int[][] matrix) { int high = matrix.length; int width = matrix[0].length; // 先沿对角线镜像对称二维矩阵 for(int i=0;i\u003chigh;i++){ for(int j=i;j\u003cwidth;j++){ int tmp = matrix[i][j]; matrix[i][j] = matrix[j][i]; matrix[j][i] = tmp; } } // 然后反转二维矩阵的每一行 for(int[] array: matrix){ int left=0,right=array.length-1; while(left\u003cright){ int tmp =array[left]; array[left] =array[right]; array[right] =tmp; left++; right--; } } } } 既然说道这里，我们可以发散一下，如何将矩阵逆时针旋转 90 度呢？ 思路是类似的，只要通过另一条对角线镜像对称矩阵，然后再反转每一行，就得到了逆时针旋转矩阵的结果 // 将二维矩阵原地逆时针旋转 90 度 void rotate2(int[][] matrix) { int n = matrix.length; // 沿左下到右上的对角线镜像对称二维矩阵 for (int i = 0; i \u003c n; i++) { for (int j = 0; j \u003c n - i; j++) { // swap(matrix[i][j], matrix[n-j-1][n-i-1]) int temp = matrix[i][j]; matrix[i][j] = matrix[n - j - 1][n - i - 1]; matrix[n - j - 1][n - i - 1] = temp; } } // 然后反转二维矩阵的每一行 for(int[] array: matrix){ int left=0,right=array.length-1; while(left\u003cright){ int tmp =array[left]; array[left] =array[right]; array[right] =tmp; left++; right--; } } } ","date":"2022-08-19","objectID":"/posts/tech/leetcode/array/:7:1","tags":["数组","leetcode"],"title":"算法-数组","uri":"/posts/tech/leetcode/array/"},{"categories":["leetcode"],"content":"矩阵的螺旋遍历 ","date":"2022-08-19","objectID":"/posts/tech/leetcode/array/:8:0","tags":["数组","leetcode"],"title":"算法-数组","uri":"/posts/tech/leetcode/array/"},{"categories":["leetcode"],"content":"螺旋矩阵 力扣第 54 题「 螺旋矩阵」 ，看一看二维矩阵可以如何花式遍历 class Solution { public List\u003cInteger\u003e spiralOrder(int[][] matrix) { List\u003cInteger\u003e result = new ArrayList\u003c\u003e(); //upper_bound right_bound //left_bound lower_bound int m = matrix.length; int n = matrix[0].length; int upper_bound = 0, right_bound = n - 1; int left_bound = 0, lower_bound = m - 1; // result.size() == m * n 则遍历完整个数组 while (result.size() \u003c m * n) { if (upper_bound \u003c= lower_bound) { // 在顶部从左向右遍历 for (int j = left_bound; j \u003c= right_bound; j++) { result.add(matrix[upper_bound][j]); } // 上边界下移 upper_bound++; } if (left_bound \u003c= right_bound) { // 在右侧从上向下遍历 for (int i = upper_bound; i \u003c= lower_bound; i++) { result.add(matrix[i][right_bound]); } // 右边界左移 right_bound--; } if (upper_bound \u003c= lower_bound) { // 在底部从右向左遍历 for (int j = right_bound; j \u003e= left_bound; j--) { result.add(matrix[lower_bound][j]); } // 下边界上移 lower_bound--; } if (left_bound \u003c= right_bound) { // 在左侧从下向上遍历 for (int i = lower_bound; i \u003e= upper_bound; i--) { result.add(matrix[i][left_bound]); } // 左边界右移 left_bound++; } } return result; } } ","date":"2022-08-19","objectID":"/posts/tech/leetcode/array/:8:1","tags":["数组","leetcode"],"title":"算法-数组","uri":"/posts/tech/leetcode/array/"},{"categories":["leetcode"],"content":"螺旋矩阵II 力扣第 59 题「 螺旋矩阵 II」 也是类似的题目，只不过是反过来，让你按照螺旋的顺序生成矩阵 class Solution { public int[][] generateMatrix(int n) { //upper_bound right_bound //left_bound lower_bound int[][] matrix=new int[n][n]; int upper_bound = 0, right_bound = n - 1; int left_bound = 0, lower_bound = n - 1; int sum = 1; // result.size() == m * n 则遍历完整个数组 while (sum \u003c= n*n) { if (upper_bound \u003c= lower_bound) { // 在顶部从左向右遍历 for (int j = left_bound; j \u003c= right_bound; j++) { matrix[upper_bound][j] = sum++; } // 上边界下移 upper_bound++; } if (left_bound \u003c= right_bound) { // 在右侧从上向下遍历 for (int i = upper_bound; i \u003c= lower_bound; i++) { matrix[i][right_bound] = sum++; } // 右边界左移 right_bound--; } if (upper_bound \u003c= lower_bound) { // 在底部从右向左遍历 for (int j = right_bound; j \u003e= left_bound; j--) { matrix[lower_bound][j] = sum++; } // 下边界上移 lower_bound--; } if (left_bound \u003c= right_bound) { // 在左侧从下向上遍历 for (int i = lower_bound; i \u003e= upper_bound; i--) { matrix[i][left_bound] = sum++; } // 左边界右移 left_bound++; } } return matrix; } } 滑动窗口 滑动窗口防滑记 链表子串数组题，用双指针别犹豫。 双指针家三兄弟，各个都是万人迷， 快慢指针最神奇，链表操作无压力。 归并排序找中点，链表成环搞判定。 左右指针最常见，左右两端相向行。 反转数组要靠它，二分搜索是弟弟。 滑动窗口老猛男，子串问题全靠它， 左右指针滑窗口，一前一后齐头进。 算法思想很简单，出了bug想升天。 labuladong稳若狗，一套框架不翻车。 一路漂移带闪电，算法变成默写题。 本文就解决一类最难掌握的双指针技巧：滑动窗口技巧。总结出一套框架，可以保你闭着眼睛都能写出正确的解法。 说起滑动窗口算法，很多读者都会头疼。这个算法技巧的思路非常简单，就是维护一个窗口，不断滑动，然后更新答案么。LeetCode 上有起码 10 道运用滑动窗口算法的题目，难度都是中等和困难。该算法的大致逻辑如下： int left = 0, right = 0; while (right \u003c s.size()) { // 增大窗口 window.add(s[right]); right++; while (window needs shrink) { // 缩小窗口 window.remove(s[left]); left++; } } 这个算法技巧的时间复杂度是 O(N)，比字符串暴力算法要高效得多。 其实困扰大家的，不是算法的思路，而是各种细节问题。比如说如何向窗口中添加新元素，如何缩小窗口，在窗口滑动的哪个阶段更新结果。即便你明白了这些细节，也容易出 bug，找 bug 还不知道怎么找，真的挺让人心烦的。 所以今天我就写一套滑动窗口算法的代码框架，我连再哪里做输出 debug 都给你写好了，以后遇到相关的问题，你就默写出来如下框架然后改三个地方就行，还不会出 bug： /* 滑动窗口算法框架 */ void slidingWindow(string s) { unordered_map\u003cchar, int\u003e window; int left = 0, right = 0; while (right \u003c s.size()) { // c 是将移入窗口的字符 char c = s[right]; // 增大窗口 right++; // 进行窗口内数据的一系列更新 ... /*** debug 输出的位置 ***/ printf(\"window: [%d, %d)\\n\", left, right); /********************/ // 判断左侧窗口是否要收缩 while (window needs shrink) { // d 是将移出窗口的字符 char d = s[left]; // 缩小窗口 left++; // 进行窗口内数据的一系列更新 ... } } } 虽然滑动窗口代码框架中有一个嵌套的 while 循环，但算法的时间复杂度依然是 O(N)，其中 N 是输入字符串/数组的长度。 为什么呢？简单说，字符串/数组中的每个元素都只会进入窗口一次，然后被移出窗口一次，不会说有某些元素多次进入和离开窗口，所以算法的时间复杂度就和字符串/数组的长度成正比。 说句题外话，我发现很多人喜欢执着于表象，不喜欢探求问题的本质。比如说有很多人评论我这个框架，说什么散列表速度慢，不如用数组代替散列表；还有很多人喜欢把代码写得特别短小，说我这样代码太多余，影响编译速度，LeetCode 上速度不够快。 我的意见是，算法主要看时间复杂度，你能确保自己的时间复杂度最优就行了。至于 LeetCode 所谓的运行速度，那个都是玄学，只要不是慢的离谱就没啥问题，根本不值得你从编译层面优化，不要舍本逐末…… ","date":"2022-08-19","objectID":"/posts/tech/leetcode/array/:8:2","tags":["数组","leetcode"],"title":"算法-数组","uri":"/posts/tech/leetcode/array/"},{"categories":["leetcode"],"content":"最小覆盖子串 先来看看力扣第 76 题「 最小覆盖子串」 难度 Hard： class Solution { public String minWindow(String s, String t) { Map\u003cCharacter, Integer\u003e needMap = new HashMap\u003c\u003e(); Map\u003cCharacter, Integer\u003e windowMap = new HashMap\u003c\u003e(); for (char c : t.toCharArray()) { needMap.put(c, needMap.getOrDefault(c, 0) + 1); } int left = 0, right = 0; int valid = 0; // 记录最小覆盖子串的起始索引 及 长度 int startIndex = 0, lenStep = Integer.MAX_VALUE; while (right \u003c s.length()) { // c 是将移入窗口的字符 char c = s.charAt(right); // 扩大窗口 right++; // 进行窗口内数据的一系列更新 if (needMap.containsKey(c)) { windowMap.put(c, windowMap.getOrDefault(c, 0) + 1); //若窗口内某个字符 总数 和 needMap中的该字符的 数量相等时 if (windowMap.get(c).equals(needMap.get(c))) { valid++; } } // 判断左侧窗口是否要收缩 【窗口内的字符，包含needMap中的所有字符】 while (valid == needMap.size()) { // 在这里更新最小覆盖子串, if (right - left \u003c lenStep) { startIndex = left; lenStep = right - left; } // d 是将移出窗口的字符 char d = s.charAt(left); // 缩小窗口 left++; // 进行窗口内数据的一系列更新 if (needMap.containsKey(d)) { if (windowMap.get(d).equals(needMap.get(d))) { valid--; } windowMap.put(d, windowMap.getOrDefault(d, 0) - 1); } } } // 返回最小覆盖子串 return lenStep == Integer.MAX_VALUE ? \"\" : s.substring(startIndex, startIndex + lenStep); } } ","date":"2022-08-19","objectID":"/posts/tech/leetcode/array/:9:0","tags":["数组","leetcode"],"title":"算法-数组","uri":"/posts/tech/leetcode/array/"},{"categories":["leetcode"],"content":"字符串排列 力扣第 567 题「 字符串的排列」 ，难度中等： 这种题目，是明显的滑动窗口算法，相当给你一个 S 和一个 T，请问你 S 中是否存在一个子串，包含 T 中所有字符且不包含其他字符？ 首先，先复制粘贴之前的算法框架代码，然后明确刚才提出的几个问题，即可写出这道题的答案： 对于这道题的解法代码，基本上和最小覆盖子串一模一样，只需要改变几个地方： 1、本题移动 left 缩小窗口的时机是窗口大小大于 t.size() 时，应为排列嘛，显然长度应该是一样的。 2、当发现 valid == need.size() 时，就说明窗口中就是一个合法的排列，所以立即返回 true。 至于如何处理窗口的扩大和缩小，和最小覆盖子串完全相同。 class Solution { /** 滑动窗口解法 */ public boolean checkInclusion(String s1, String s2) { Map\u003cCharacter, Integer\u003e needMap = new HashMap\u003c\u003e(); Map\u003cCharacter, Integer\u003e windowMap = new HashMap\u003c\u003e(); for (char c : s1.toCharArray()) { needMap.put(c, needMap.getOrDefault(c, 0) + 1); } int left = 0, right = 0; int valid = 0; // 记录最小覆盖子串的起始索引 及 长度 int startIndex = 0, lenStep = Integer.MAX_VALUE; while (right \u003c s2.length()) { // c 是将移入窗口的字符 char c = s2.charAt(right); // 扩大窗口 right++; // 进行窗口内数据的一系列更新 if (needMap.containsKey(c)) { windowMap.put(c, windowMap.getOrDefault(c, 0) + 1); //若窗口内某个字符 总数 和 needMap中的该字符的 数量相等时 if (windowMap.get(c).equals(needMap.get(c))) { valid++; } } // 判断左侧窗口是否要收缩 [注意此处为 s1.length()] while (right-left \u003e= s1.length()) { // 在这里判断是否找到了合法的子串 if (valid==needMap.size()) { return true; } // d 是将移出窗口的字符 char d = s2.charAt(left); // 缩小窗口 left++; // 进行窗口内数据的一系列更新 if (needMap.containsKey(d)) { if (windowMap.get(d).equals(needMap.get(d))) { valid--; } windowMap.put(d, windowMap.getOrDefault(d, 0) - 1); } } } return false; } } ","date":"2022-08-19","objectID":"/posts/tech/leetcode/array/:10:0","tags":["数组","leetcode"],"title":"算法-数组","uri":"/posts/tech/leetcode/array/"},{"categories":["leetcode"],"content":"找所有字母异位词 力扣第 438 题「 找到字符串中所有字母异位词」 ，难度中等： 呵呵，这个所谓的字母异位词，不就是排列吗，搞个高端的说法就能糊弄人了吗？ 相当于，输入一个串 S，一个串 T，找到 S 中所有 T 的排列，返回它们的起始索引。 class Solution { /** 滑动窗口解法 */ public List\u003cInteger\u003e findAnagrams(String s, String p) { List\u003cInteger\u003e result = new ArrayList\u003c\u003e(); Map\u003cCharacter, Integer\u003e needMap = new HashMap\u003c\u003e(); Map\u003cCharacter, Integer\u003e windowMap = new HashMap\u003c\u003e(); for (char c : p.toCharArray()) { needMap.put(c, needMap.getOrDefault(c, 0) + 1); } int left = 0, right = 0; int valid = 0; // 记录最小覆盖子串的起始索引 及 长度 int startIndex = 0, lenStep = Integer.MAX_VALUE; while (right \u003c s.length()) { // c 是将移入窗口的字符 char c = s.charAt(right); // 扩大窗口 right++; // 进行窗口内数据的一系列更新 if (needMap.containsKey(c)) { windowMap.put(c, windowMap.getOrDefault(c, 0) + 1); //若窗口内某个字符 总数 和 needMap中的该字符的 数量相等时 if (windowMap.get(c).equals(needMap.get(c))) { valid++; } } // 判断左侧窗口是否要收缩 [注意此处为 p.length()] while (right-left \u003e= p.length()) { // 在这里判断是否找到了合法的子串 if (valid==needMap.size()) { result.add(left); } // d 是将移出窗口的字符 char d = s.charAt(left); // 缩小窗口 left++; // 进行窗口内数据的一系列更新 if (needMap.containsKey(d)) { if (windowMap.get(d).equals(needMap.get(d))) { valid--; } windowMap.put(d, windowMap.getOrDefault(d, 0) - 1); } } } return result; } } ","date":"2022-08-19","objectID":"/posts/tech/leetcode/array/:11:0","tags":["数组","leetcode"],"title":"算法-数组","uri":"/posts/tech/leetcode/array/"},{"categories":["leetcode"],"content":"最长无重复子串 力扣第 3 题「 无重复字符的最长子串」 ，难度中等： class Solution { /** * 滑动窗口 */ public int lengthOfLongestSubstring(String s) { Map\u003cCharacter, Integer\u003e windowMap = new HashMap\u003c\u003e(); int left = 0, right = 0; int max = 0; while (right \u003c s.length()) { // c 是将移入窗口的字符 char c = s.charAt(right); // 扩大窗口 right++; // 判断左侧窗口是否要收缩 [注意此处为 p.length()] windowMap.put(c, windowMap.getOrDefault(c, 0) + 1); while (windowMap.get(c) \u003e 1) { // d 是将移出窗口的字符 char d = s.charAt(left); // 缩小窗口 left++; // 进行窗口内数据的一系列更新 windowMap.put(d, windowMap.getOrDefault(d, 0) - 1); } max = Math.max(max, right - left); } return max; } // public int lengthOfLongestSubstring(String s) { // int ans = 0; // int len = s.length(); // Map\u003cCharacter, Integer\u003e map = new HashMap\u003c\u003e(); // for (int i = 0, j = 0; j \u003c len; j++) { // //判断这个字母是否在map中。 // if(map.containsKey(s.charAt(j))) { // //如果在，说明重复了，需要移动i了，将i移动到 s.charAt(j) 这个字母的下一位。 // //因为map中的key字母可以重复，所以，查找最大的i保证了i是在最右边。 // i = Math.max(map.get(s.charAt(j)), i); // } // //如果不再，说明这位也是字符串的字母，需要加一。 // ans = Math.max(ans, j-i+1); // //将键值对写入map，key是字母，位置是value。不用管重复的问题，只需要移动i到合适的位置即可。 // map.put(s.charAt(j), j+1); // } // return ans; // } } 滑动窗口算法模板就讲到这里，希望大家能理解其中的思想，记住算法模板并融会贯通。回顾一下，遇到子数组/子串相关的问题，你只要能回答出来以下几个问题，就能运用滑动窗口算法： 1、什么时候应该扩大窗口？ 2、什么时候应该缩小窗口？ 3、什么时候得到一个合法的答案？ 旨在强化你对算法的理解和记忆，以后就再也不怕子串、子数组问题了。 算法就是这样，再高大上的技巧，都是在最简单最基本的原理之上构建的. 滑动窗口算法延伸：RABIN KARP 字符匹配算法 refer to ","date":"2022-08-19","objectID":"/posts/tech/leetcode/array/:12:0","tags":["数组","leetcode"],"title":"算法-数组","uri":"/posts/tech/leetcode/array/"},{"categories":["leetcode"],"content":"高效寻找重复子序列 ","date":"2022-08-19","objectID":"/posts/tech/leetcode/array/:13:0","tags":["数组","leetcode"],"title":"算法-数组","uri":"/posts/tech/leetcode/array/"},{"categories":["leetcode"],"content":"重复的 DNA 序列 看下力扣第 187 题「 重复的 DNA 序列」 ，我简单描述下题目： class Solution { /** 穷举 */ public List\u003cString\u003e findRepeatedDnaSequences(String s) { // 记录出现过的子串 Set\u003cString\u003e total = new HashSet\u003c\u003e(); // 记录那些重复出现多次的子串 // 注意要用哈希集合，防止记录重复的结果 Set\u003cString\u003e repeat = new HashSet\u003c\u003e(); for(int i=0;i+10\u003c= s.length();i++){ String str= s.substring(i,i+10); if(total.contains(str)){ repeat.add(str); }else{ total.add(str); } } return new ArrayList\u003c\u003e(repeat); } } 零、二分查找框架 先给大家讲个笑话乐呵一下： 有一天阿东到图书馆借了 N 本书，出图书馆的时候，警报响了，于是保安把阿东拦下，要检查一下哪本书没有登记出借。阿东正准备把每一本书在报警器下过一下，以找出引发警报的书，但是保安露出不屑的眼神：你连二分查找都不会吗？于是保安把书分成两堆，让第一堆过一下报警器，报警器响；于是再把这堆书分成两堆…… 最终，检测了 logN 次之后，保安成功的找到了那本引起警报的书，露出了得意和嘲讽的笑容。于是阿东背着剩下的书走了。 从此，图书馆丢了 N - 1 本书（手动狗头）。 int binarySearch(int[] nums, int target) { int left = 0, right = ...; while(...) { int mid = left + (right - left) / 2; if (nums[mid] == target) { ... } else if (nums[mid] \u003c target) { left = ... } else if (nums[mid] \u003e target) { right = ... } } return ...; } 分析二分查找的一个技巧是：不要出现 else，而是把所有情况用 else if 写清楚，这样可以清楚地展现所有细节。本文都会使用 else if，旨在讲清楚，读者理解后可自行简化。 另外提前说明一下，计算 mid 时需要防止溢出，代码中 left + (right - left) / 2 就和 (left + right) / 2 的结果相同，但是有效防止了 left 和 right 太大，直接相加导致溢出的情况。 ","date":"2022-08-19","objectID":"/posts/tech/leetcode/array/:13:1","tags":["数组","leetcode"],"title":"算法-数组","uri":"/posts/tech/leetcode/array/"},{"categories":["leetcode"],"content":"寻找一个数（基本的二分搜索） 力扣第 704 题「 二分查找」 int binarySearch(int[] nums, int target) { int left = 0; int right = nums.length - 1; // 注意 while(left \u003c= right) { int mid = left + (right - left) / 2; if(nums[mid] == target) return mid; else if (nums[mid] \u003c target) left = mid + 1; // 注意 else if (nums[mid] \u003e target) right = mid - 1; // 注意 } return -1; } ","date":"2022-08-19","objectID":"/posts/tech/leetcode/array/:14:0","tags":["数组","leetcode"],"title":"算法-数组","uri":"/posts/tech/leetcode/array/"},{"categories":["leetcode"],"content":"寻找左侧边界的二分搜索 ","date":"2022-08-19","objectID":"/posts/tech/leetcode/array/:15:0","tags":["数组","leetcode"],"title":"算法-数组","uri":"/posts/tech/leetcode/array/"},{"categories":["leetcode"],"content":"寻找右侧边界的二分查找 int right_bound(int[] nums, int target) { int left = 0, right = nums.length - 1; while (left \u003c= right) { int mid = left + (right - left) / 2; if (nums[mid] \u003c target) { left = mid + 1; } else if (nums[mid] \u003e target) { right = mid - 1; } else if (nums[mid] == target) { // 这里改成收缩左侧边界即可 left = mid + 1; } } // 最后改成返回 left - 1 if (left - 1 \u003c 0) return -1; return nums[left - 1] == target ? (left - 1) : -1; } 带权重的随机选择算法 题解 ","date":"2022-08-19","objectID":"/posts/tech/leetcode/array/:16:0","tags":["数组","leetcode"],"title":"算法-数组","uri":"/posts/tech/leetcode/array/"},{"categories":["leetcode"],"content":"按权重随机选择 [没看懂] 力扣第 528 题「 按权重随机选择」 class Solution { // 前缀和数组 private int[] preSum; private Random rand = new Random(); public Solution(int[] w) { int n = w.length; // 构建前缀和数组，偏移一位留给 preSum[0] preSum = new int[n + 1]; preSum[0] = 0; // preSum[i] = sum(w[0..i-1]) for (int i = 1; i \u003c= n; i++) { preSum[i] = preSum[i - 1] + w[i - 1]; } } public int pickIndex() { int n = preSum.length; // 在闭区间 [1, preSum[n - 1]] 中随机选择一个数字 int target = rand.nextInt(preSum[n - 1]) + 1; // 获取 target 在前缀和数组 preSum 中的索引 // 别忘了前缀和数组 preSum 和原始数组 w 有一位索引偏移 return left_bound(preSum, target) - 1; } // 搜索左侧边界的二分搜索 private int left_bound(int[] nums, int target) { if (nums.length == 0) return -1; int left = 0, right = nums.length; while (left \u003c right) { int mid = left + (right - left) / 2; if (nums[mid] == target) { right = mid; } else if (nums[mid] \u003c target) { left = mid + 1; } else if (nums[mid] \u003e target) { right = mid; } } return left; } } /** * Your Solution object will be instantiated and called as such: * Solution obj = new Solution(w); * int param_1 = obj.pickIndex(); */ 田忌赛马背后的算法决策 力扣第 870 题「 优势洗牌」 基本思路 这题就像田忌赛马的情景，nums1 就是田忌的马，nums2 就是齐王的马，数组中的元素就是马的战斗力，你就是谋士孙膑，请你帮田忌安排赛马顺序，使胜场最多。 最优策略是将齐王和田忌的马按照战斗力排序，然后按照战斗力排名一一对比： 如果田忌的马能赢，那就比赛，如果赢不了，那就换个垫底的来送人头，保存实力。 public int[] advantageCount(int[] nums1, int[] nums2) { int n = nums1.length; // 给 nums2 降序排序 PriorityQueue\u003cint[]\u003e maxpq = new PriorityQueue\u003c\u003e( (int[] pair1, int[] pair2) -\u003e { return pair2[1] - pair1[1]; } ); for (int i = 0; i \u003c n; i++) { maxpq.offer(new int[]{i, nums2[i]}); } // 给 nums1 升序排序 Arrays.sort(nums1); // nums1[left] 是最小值，nums1[right] 是最大值 int left = 0, right = n - 1; int[] res = new int[n]; while (!maxpq.isEmpty()) { int[] pair = maxpq.poll(); // maxval 是 nums2 中的最大值，i 是对应索引 int i = pair[0], maxval = pair[1]; if (maxval \u003c nums1[right]) { // 如果 nums1[right] 能胜过 maxval，那就自己上 res[i] = nums1[right]; right--; } else { // 否则用最小值混一下，养精蓄锐 res[i] = nums1[left]; left++; } } return res; } /** *主要的思路: * 将问题转化成 已知B马出场顺序 以及B马的能力值 如何调整A的出场顺序 使能赢的场次最大 * * 将A马由大到小排序 * B从大到小排序,并记录B马原来的出场顺序() * 比较A当前最小的马和B当前最小的马 * 如果A最小的马\u003c=B最小的马 则让A最小的马和B最大的马对 * 如果A最小的马\u003eB最小的马 则让A最小的马和B最小的马对 * */ public int[] advantageCount(int[] nums1, int[] nums2) { /*让nums1马从小到大排序*/ Arrays.sort(nums1); int len = nums2.length; //0 -\u003e num2的马力值， 1 -\u003e num2的马力值对应的原数组坐标 int[][] sort2 = new int[len][2]; for (int i = 0; i \u003c len; i++) { sort2[i][0] = nums2[i]; sort2[i][1] = i; } /*让 nums2马从小到大排序*/ Arrays.sort(sort2, (a, b) -\u003e a[0] - b[0]); // num2最小值坐标 int left = 0; // num2最大值坐标 int right = len - 1; int[] result = new int[len]; for (int i = 0; i \u003c len; i++) { /*当前的马比最小马小, 就和他最大的马对*/ if (nums1[i] \u003c= sort2[left][0]) { result[sort2[right][1]] = nums1[i]; right--; } else { result[sort2[left][1]] = nums1[i]; left++; } } return result; } 常数时间删除/查找数组中的任意元素 [不懂] 力扣第 380 题「 常数时间插入、删除和获取随机元素」 ","date":"2022-08-19","objectID":"/posts/tech/leetcode/array/:17:0","tags":["数组","leetcode"],"title":"算法-数组","uri":"/posts/tech/leetcode/array/"},{"categories":["leetcode"],"content":"避开黑名单的随机数 力扣第 710 题「 黑名单中的随机数」 数组去重 力扣第 316 题「 去除重复字母」 同 第 1081 题「不同字符的最小子序列」 的解法是完全相同的 #其他 ","date":"2022-08-19","objectID":"/posts/tech/leetcode/array/:18:0","tags":["数组","leetcode"],"title":"算法-数组","uri":"/posts/tech/leetcode/array/"},{"categories":["leetcode"],"content":"有效的数独 力扣第 36 题 有效的数独 看每行、每列、每个9*9区块内，是否有重复的数字. 大多数的哈希表计数问题，都能转换为使用数组解决。 虽然时间复杂度一样，但哈希表的更新和查询复杂度为均摊 O(1)O(1)，而定长数组的的更新和查询复杂度则是严格 O(1)O(1)。 因此从执行效率上来说，数组要比哈希表快上不少。 class Solution { /** * 数组解法， * 从执行效率上来说，数组要比哈希表快上不少。 */ public boolean isValidSudoku(char[][] board) { boolean[][] row = new boolean[10][10]; boolean[][] col = new boolean[10][10]; //9*9区块 boolean[][] area = new boolean[10][10]; for (int i = 0; i \u003c 9; i++) { for (int j = 0; j \u003c 9; j++) { int c = board[i][j]; if (c == '.') { continue; } int u = c - '0'; int idx = i / 3 * 3 + j / 3; if (row[i][u] || col[j][u] || area[idx][u]) { return false; } row[i][u] = col[j][u] = area[idx][u] = true; } } return true; } /** * 哈希解法 * 大多数的哈希表计数问题，都能转换为使用数组解决。 */ public boolean isValidSudoku2(char[][] board) { Map\u003cInteger, Set\u003cInteger\u003e\u003e rowMap = new HashMap(); Map\u003cInteger, Set\u003cInteger\u003e\u003e cloumnMap = new HashMap(); //最小区块map Map\u003cInteger, Set\u003cInteger\u003e\u003e subMap = new HashMap(); //初始化定义 for (int i = 0; i \u003c 9; i++) { rowMap.put(i, new HashSet\u003c\u003e()); cloumnMap.put(i, new HashSet\u003c\u003e()); subMap.put(i, new HashSet\u003c\u003e()); } for (int i = 0; i \u003c board.length; i++) { for (int j = 0; j \u003c board[0].length; j++) { char c = board[i][j]; if (c == '.') { continue; } Integer v = c - '0'; Integer idx = i / 3 * 3 + j / 3; if (rowMap.get(i).contains(v) || cloumnMap.get(j).contains(v) || subMap.get(idx).contains(v)) { return false; } rowMap.get(i).add(v); cloumnMap.get(j).add(v); subMap.get(idx).add(v); } } return true; } } ","date":"2022-08-19","objectID":"/posts/tech/leetcode/array/:19:0","tags":["数组","leetcode"],"title":"算法-数组","uri":"/posts/tech/leetcode/array/"},{"categories":["leetcode"],"content":"多数元素-E 第 169 题 多数元素 给定一个大小为 n 的数组 nums ，返回其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n/2 ⌋ 的元素。 你可以假设数组是非空的，并且给定的数组总是存在多数元素。 class Solution { /** * 法1：比较 */ public int majorityElement(int[] nums) { int target = 0; int count = 0; for (int i = 0; i \u003c nums.length; i++) { if (count == 0) { target = nums[i]; } if (nums[i] == target) { count++; } else { count--; } } return target; } /** * 法2：sort后取值 */ public int majorityElement2(int[] nums) { Arrays.sort(nums); return nums[nums.length / 2]; } } ","date":"2022-08-19","objectID":"/posts/tech/leetcode/array/:20:0","tags":["数组","leetcode"],"title":"算法-数组","uri":"/posts/tech/leetcode/array/"},{"categories":["leetcode"],"content":"搜索二维矩阵 II-M 第 240 题 搜索二维矩阵 II 编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target 。该矩阵具有以下特性： 每行的元素从左到右升序排列。 每 列的元素从上到下升序排列。 class Solution { /** * 法1：Z 字形查找 * 从右上角开始， 向下-\u003e数字变大； 向左-\u003e数字变小； * 也可从左下角开始，只有两个方向可以做到一个变大，一个变小即可 */ public boolean searchMatrix(int[][] matrix, int target) { int width = matrix[0].length; int len = matrix.length; int i = 0, j = width - 1; while (i \u003c len \u0026\u0026 j \u003e= 0) { if (matrix[i][j] == target) { return true; } else if (matrix[i][j] \u003e target) { j--; } else if (matrix[i][j] \u003c target) { i++; } } return false; } /** * 法2：直接查找, 全遍历 */ public boolean searchMatrix2(int[][] matrix, int target) { for (int[] row : matrix) { for (int element : row) { if (element == target) { return true; } } } return false; } } ","date":"2022-08-19","objectID":"/posts/tech/leetcode/array/:21:0","tags":["数组","leetcode"],"title":"算法-数组","uri":"/posts/tech/leetcode/array/"},{"categories":["leetcode"],"content":"其他 ","date":"2022-08-19","objectID":"/posts/tech/leetcode/array/:22:0","tags":["数组","leetcode"],"title":"算法-数组","uri":"/posts/tech/leetcode/array/"},{"categories":["leetcode"],"content":"存在重复元素-E 217题 存在重复元素 给你一个整数数组 nums 。如果任一值在数组中出现 至少两次 ，返回 true ；如果数组中每个元素互不相同，返回 false 。 /** * 方法1：HashSet 解法 */ public boolean containsDuplicate1(int[] nums) { Set\u003cInteger\u003e set = new HashSet\u003cInteger\u003e(); for (int x : nums) { if (!set.add(x)) { return true; } } return false; } /** * 方法2：先排序，然后再比较相邻元素是否相等 */ public boolean containsDuplicate2(int[] nums) { Arrays.sort(nums); int i = 1; while (i \u003c nums.length) { if (nums[i] == nums[i - 1]) { return true; } } return false; } ","date":"2022-08-19","objectID":"/posts/tech/leetcode/array/:22:1","tags":["数组","leetcode"],"title":"算法-数组","uri":"/posts/tech/leetcode/array/"},{"categories":["leetcode"],"content":"除自身以外数组的乘积-M 第 238 题 除自身以外数组的乘积 给你一个整数数组nums，返回 数组answer，其中answer[i]等于nums中除nums[i]之外其余各元素的乘积。 题目数据 保证 数组nums之中任意元素的全部前缀元素和后缀的乘积都在 32 位 整数范围内。 请不要使用除法，且在O(n) 时间复杂度内完成此题。 class Solution { public int[] productExceptSelf(int[] nums) { int len = nums.length; // L 和 R 分别表示左右两侧的乘积列表 int[] leftValue = new int[len]; int[] rightValue = new int[len]; int[] result = new int[len]; // L[i] 为索引 i 左侧所有元素的乘积 // 对于索引为 '0' 的元素，因为左侧没有元素，所以 L[0] = 1 leftValue[0] = 1; for (int i = 1; i \u003c len; i++) { leftValue[i] = nums[i-1] * leftValue[i - 1]; } // R[i] 为索引 i 右侧所有元素的乘积 // 对于索引为 'length-1' 的元素，因为右侧没有元素，所以 R[length-1] = 1 rightValue[len-1] = 1; for (int i = len - 2; i \u003e= 0; i--) { rightValue[i] = nums[i + 1] * rightValue[i + 1]; } // 对于索引 i，除 nums[i] 之外其余各元素的乘积就是左侧所有元素的乘积乘以右侧所有元素的乘积 for (int i = 0; i \u003c len; i++) { result[i] = leftValue[i] * rightValue[i]; } return result; } } ","date":"2022-08-19","objectID":"/posts/tech/leetcode/array/:22:2","tags":["数组","leetcode"],"title":"算法-数组","uri":"/posts/tech/leetcode/array/"},{"categories":["leetcode"],"content":"一、数据结构的存储方式 数据结构的存储方式只有两种：数组（顺序存储）和链表（链式存储） 这句话怎么理解，不是还有散列表、栈、队列、堆、树、图等等各种数据结构吗？ 我们分析问题，一定要有递归的思想，自顶向下，从抽象到具体。你上来就列出这么多，那些都属于「上层建筑」，而数组和链表才是「结构基础」。因为那些多样化的数据结构，究其源头，都是在链表或者数组上的特殊操作，API 不同而已。 比如说「队列」、「栈」这两种数据结构既可以使用链表也可以使用数组实现。用数组实现，就要处理扩容缩容的问题；用链表实现，没有这个问题，但需要更多的内存空间存储节点指针。 「图」的两种表示方法，邻接表就是链表，邻接矩阵就是二维数组。邻接矩阵判断连通性迅速，并可以进行矩阵运算解决一些问题，但是如果图比较稀疏的话很耗费空间。邻接表比较节省空间，但是很多操作的效率上肯定比不过邻接矩阵。 「散列表」就是通过散列函数把键映射到一个大数组里。而且对于解决散列冲突的方法，拉链法需要链表特性，操作简单，但需要额外的空间存储指针；线性探查法就需要数组特性，以便连续寻址，不需要指针的存储空间，但操作稍微复杂些。 「树」，用数组实现就是「堆」，因为「堆」是一个完全二叉树，用数组存储不需要节点指针，操作也比较简单；用链表实现就是很常见的那种「树」，因为不一定是完全二叉树，所以不适合用数组存储。为此，在这种链表「树」结构之上，又衍生出各种巧妙的设计，比如二叉搜索树、AVL 树、红黑树、区间树、B 树等等，以应对不同的问题。 了解 Redis 数据库的朋友可能也知道，Redis 提供列表、字符串、集合等等几种常用数据结构，但是对于每种数据结构，底层的存储方式都至少有两种，以便于根据存储数据的实际情况使用合适的存储方式。 综上，数据结构种类很多，甚至你也可以发明自己的数据结构，但是底层存储无非数组或者链表，二者的优缺点如下： 数组由于是紧凑连续存储,可以随机访问，通过索引快速找到对应元素，而且相对节约存储空间。但正因为连续存储，内存空间必须一次性分配够，所以说数组如果要扩容，需要重新分配一块更大的空间，再把数据全部复制过去，时间复杂度 O(N)；而且你如果想在数组中间进行插入和删除，每次必须搬移后面的所有数据以保持连续，时间复杂度 O(N)。 链表因为元素不连续，而是靠指针指向下一个元素的位置，所以不存在数组的扩容问题；如果知道某一元素的前驱和后驱，操作指针即可删除该元素或者插入新元素，时间复杂度 O(1)。但是正因为存储空间不连续，你无法根据一个索引算出对应元素的地址，所以不能随机访问；而且由于每个元素必须存储指向前后元素位置的指针，会消耗相对更多的储存空间。 二、数据结构的基本操作 对于任何数据结构，其基本操作无非遍历 + 访问，再具体一点就是：增删查改。 数据结构种类很多，但它们存在的目的都是在不同的应用场景，尽可能高效地增删查改。话说这不就是数据结构的使命么？ 如何遍历 + 访问？我们仍然从最高层来看，各种数据结构的遍历 + 访问无非两种形式：线性的和非线性的。 线性就是 for/while 迭代为代表，非线性就是递归为代表。再具体一步，无非以下几种框架： 数组遍历框架，典型的线性迭代结构： void traverse(int[] arr) { for (int i = 0; i \u003c arr.length; i++) { // 迭代访问 arr[i] } } 链表遍历框架，兼具迭代和递归结构： /* 基本的单链表节点 */ class ListNode { int val; ListNode next; } void traverse(ListNode head) { for (ListNode p = head; p != null; p = p.next) { // 迭代访问 p.val } } void traverse(ListNode head) { // 递归访问 head.val traverse(head.next); } 二叉树遍历框架，典型的非线性递归遍历结构： /* 基本的二叉树节点 */ class TreeNode { int val; TreeNode left, right; } void traverse(TreeNode root) { traverse(root.left); traverse(root.right); } 你看二叉树的递归遍历方式和链表的递归遍历方式，相似不？再看看二叉树结构和单链表结构，相似不？如果再多几条叉，N 叉树你会不会遍历？ 二叉树框架可以扩展为 N 叉树的遍历框架： /* 基本的 N 叉树节点 */ class TreeNode { int val; TreeNode[] children; } void traverse(TreeNode root) { for (TreeNode child : root.children) traverse(child); } N 叉树的遍历又可以扩展为图的遍历，因为图就是好几 N 叉棵树的结合体。你说图是可能出现环的？这个很好办，用个布尔数组 visited 做标记就行了，这里就不写代码了。 所谓框架，就是套路。不管增删查改，这些代码都是永远无法脱离的结构，你可以把这个结构作为大纲，根据具体问题在框架上添加代码就行了，下面会具体举例。 三、算法刷题指南 首先要明确的是，数据结构是工具，算法是通过合适的工具解决特定问题的方法。也就是说，学习算法之前，最起码得了解那些常用的数据结构，了解它们的特性和缺陷。 所以我建议的刷题顺序是： 1、先学习像数组、链表这种基本数据结构的常用算法，比如单链表翻转，前缀和数组，二分搜索等。 因为这些算法属于会者不难难者不会的类型，难度不大，学习它们不会花费太多时间。而且这些小而美的算法经常让你大呼精妙，能够有效培养你对算法的兴趣。 2、学会基础算法之后，不要急着上来就刷回溯算法、动态规划这类笔试常考题，而应该先刷二叉树，先刷二叉树，先刷二叉树，重要的事情说三遍。 为什么要先刷二叉树呢，因为二叉树是最容易培养框架思维的，而且大部分算法技巧，本质上都是树的遍历问题。 刷二叉树看到题目没思路？根据很多读者的问题，其实大家不是没思路，只是没有理解我们说的「框架」是什么。 不要小看这几行破代码，几乎所有二叉树的题目都是一套这个框架就出来了： void traverse(TreeNode root) { // 前序位置 traverse(root.left); // 中序位置 traverse(root.right); // 后序位置 } 比如说我随便拿几道题的解法出来，不用管具体的代码逻辑，只要看看框架在其中是如何发挥作用的就行。 力扣第 124 题，难度困难，让你求二叉树中最大路径和，主要代码如下： 比如说我随便拿几道题的解法出来，不用管具体的代码逻辑，只要看看框架在其中是如何发挥作用的就行。 力扣第 124 题，难度困难，让你求二叉树中最大路径和，主要代码如下： int res = Integer.MIN_VALUE; int oneSideMax(TreeNode root) { if (root == null) return 0; int left = max(0, oneSideMax(root.left)); int right = max(0, oneSideMax(root.right)); // 后序位置 res = Math.max(res, left + right + root.val); return Math.max(left, right) + root.val; } 注意递归函数的位置，这就是个后序遍历嘛，无非就是把 traverse 函数名字改成 oneSideMax 了。 力扣第 105 题，难度中等，让你根据前序遍历和中序遍历的结果还原一棵二叉树，很经典的问题吧，主要代码如下： TreeNode build(int[] preorder, int preStart, int preEnd, int[] inorder, int inStart, int inEnd) { // 前序位置，寻找左右子树的索引 if (preStart \u003e preEnd) { return null; } int rootVal = preorder[preStart]; int index = 0; for (int i = inStart; i \u003c= inEnd; i++) { if (inorder[i] == rootVal) { index = i; break; } } int leftSize = index - inStart; TreeNode root = new TreeNode(rootVal); // 递归构造左右子树 root.left = build(preorder, preStart + 1, preStart + leftSize, inorder, inStart, index - 1); root.right = build(preorder, preStart + leftSize + 1, preEnd, inorder, index + 1, inEnd); return root; } 不要看这个函数的参数很多，只是为了控制数组索引而已。注意找递归函数 build 的位置，本质上该算法也就是一个前序遍历，因为它在前序遍历的位置加了一坨代码逻辑。 力扣第 230 题，难度中等，寻找二叉搜索树中的第 k 小的元素，","date":"2022-08-18","objectID":"/posts/tech/leetcode/algorithm/:0:0","tags":["算法","leetcode"],"title":"算法概述","uri":"/posts/tech/leetcode/algorithm/"},{"categories":["github"],"content":"leetcode leetcode-labuladong (109k) labuladong-算法讲解 宫水三叶-blog leetcode-宫水三叶 github-宫水三叶 ","date":"2022-08-18","objectID":"/posts/tech/github/github/:0:0","tags":["github"],"title":"Github","uri":"/posts/tech/github/github/"},{"categories":[""],"content":"天行健，君子以自强不息 SYC出生在河南的一个普通农村，小学初中在乡里，高中在一个五线的小县城，高考那年全省考生近100万，当年本专科录取率30%， 意味着有近70w学生无法继续学习，想想都是泪； 大学毕业后，在上海、杭州工作过，机缘巧合，经历过创业公司、外企、中型民企和互联网大厂，行业横跨 金融、互联网电商等行业。 18年加入阿里，作为一名技术同学，为国际化电商业务添砖加瓦； ","date":"2022-08-14","objectID":"/about/:0:0","tags":[""],"title":"About","uri":"/about/"},{"categories":[""],"content":"天行健，君子以自强不息 SYC出生在河南的一个普通农村，小学初中在乡里，高中在一个五线的小县城，高考那年全省考生近100万，当年本专科录取率30%， 意味着有近70w学生无法继续学习，想想都是泪； 大学毕业后，在上海、杭州工作过，机缘巧合，经历过创业公司、外企、中型民企和互联网大厂，行业横跨 金融、互联网电商等行业。 18年加入阿里，作为一名技术同学，为国际化电商业务添砖加瓦； ","date":"2022-08-14","objectID":"/posts/about/:0:0","tags":[""],"title":"About","uri":"/posts/about/"},{"categories":["社会"],"content":"8.6号，机缘巧合，今天来到花开岭公益基地，“免费午餐”、“微博打拐发起人” 邓飞 老师在这里分享了他的真实经历。 邓飞老师使用微博、抖音等新兴社交媒体，充分发挥使用这些软件且有良知的人，发现丢失儿童，拯救了多个破碎的家庭； ","date":"2022-08-06","objectID":"/posts/life/huakailing/:0:0","tags":["公益"],"title":"花开岭公益行","uri":"/posts/life/huakailing/"},{"categories":["读书笔记"],"content":" 查理就是如此独特的人，他的独特性既表现在他的思想上，也表现在他的人格上。 比如说，查理思考问题总是从逆向开始。如果要明白人生如何得到幸福，查理首先是研究人生如何才能变得痛苦；要研究企业如何做强做大，查理首先研究企业是如何衰败的；大部分人更关心如何在股市投资上成功，查理最关心的是为什么在股市投资上大部分人都失败了。 他的这种思考方法来源于下面这句农夫谚语中所蕴含的哲理：我只想知道将来我会死在什么地方，这样我就就=不去那儿了。”这也是逆向思维的典型例子。 查理对理性有更苛刻的定义。正是这样的“理性”，让查理具有敏說独到的眼光和洞察力，即使对于完全陌生的领域，他也能一眼看到事物的本质。巴菲特就把查理的这个特点称作“两分钟效应”- 他说查理比世界上任何人更能在最短时间之内把一个复杂商业的本质说清楚。 芒格推崇的几个重要的投资原则： ● 逆向思维，凡事总是反过来想； ● 拥有良好的性格，毫不焦躁地持有看好的股票，并保持浓厚的兴趣去提高自己的能力； ● 在自己的“能力圈”中做投资，并不断拓展自己的能力圈； ● 等待好的投资机会出现，一旦出现，倾全力集中投资。 〝我这辈子遇到的聪明人（来自各行各业的聪明人）没有不每天阅读的没有，一个都没有。沃伦读书之多，我读书之多，可能会让你感到吃惊。我的孩子们都笑话我。他们觉得我是一本长了两条腿的书。” 查理论吸引客户：“关健是把手头的事情做好……把手头的事情做好。把已经拥有的客户照顾好，其他的自然会来找你。 查理有把事情彻底弄清楚的欲望。他遇事喜欢穷根究底，无论该事跟他有密切关系与否。任何引起他注意的事情，他都想对其有更多的认识，更多的了解，弄清楚那到底是怎么回事。 “多元思维模型” – “你必须知道重要学科的重要理论，并经常使用它们—-要全部都用上，而不是只用几种。大多数人都只使用学过的一个学科的思维模型，比如说经济学，试图用一种方法来解决所有问题。你知道谚语是怎么说的：“在手里拿着铁锤的人看来，世界就像一颗钉子。”这是处理问题的一种笨办法。 我们看很多书。我认识的聪明人没有不看很多书的。但光看书还不够：你必须拥有一种能够掌握思想和做合理事情的性格。大多数人无法掌握正确的思想，或者不知道该怎么应用它们。 求学之道无坦途，问艺之路无捷径。 -安东尼•特罗洛普 “五何”原则一一你必须说明何人因何故在何时何地做了何事。如果你在布劳恩公司里面写一封信或指示某人去做某事，但没有告诉他原因，那么你可能会被解雇。实际上，你只要犯两次这种错误，就会被解雇。 你们也许会问，这有那么重要吗？嗯，这也跟心理学的原理有关。如果你能够将一堆模式的知识组合起来，回答一个又一个为什么，你就能够更好地思考：同样道理，如果你告诉人们事情的时候，总是告诉他们原因，他们就能更深刻地理解你说的话，就会要加重视你说的话，也会更倾向于听从你说的话。就算他们不理解你的理由，他们也会更倾向于听你的语。 正如你想要从问一个又一个的“为什么”开始获得普世的智慧一样，你在跟别人交流沟通时，也应该把原因讲清楚。就算答案很浅显，你把“为什么”讲清仍是一种明智的做法。 遇到好机会，就全力出击。就是这么简单。 ","date":"2022-07-29","objectID":"/posts/book/poor_charlie_book/:0:0","tags":["理财"],"title":"[读书笔记] 《穷查理宝典》","uri":"/posts/book/poor_charlie_book/"},{"categories":["旅游"],"content":"当六月份看到朋友发的招募贴时，随即决定给自己放一次长假，让自己从持续多年的忙碌状态中抽离出来，腾出几天时间，给自己来一场心灵的放松、灵魂的洗礼和体力的马拉松。 2022.7.8 - 2022.7.17，来阿里四年，给自己休的第一次长假。 ","date":"2022-07-22","objectID":"/posts/travel/xinjiang/:0:0","tags":["新疆"],"title":"新疆旅行-北疆","uri":"/posts/travel/xinjiang/"},{"categories":["旅游"],"content":"行程计划 7.8： 杭州出发； 7.9： 尹宁 伊力特酒厂、六星街、伊犁河；（美食） 7.10：尹宁7点发车（1.5小时车程）、紫仙镇薰衣草庄园（1小时）、（1小时车程）果子沟（1.5小时）、午餐、赛里木湖（落日）（9小时左右）、（1.5小时车程）住清水河镇（预计12点多了）； 7.11：清水河镇8点出发附近看免费薰衣草（1小时），（6.5小时车程）前往夏塔旅游风景区，进景区入住，有时间可以游玩下（星空）； 7.12：6点早起，早餐后徒步夏塔古道（20公里左右，原路往返，也许还有日出）、17点左右出景区晚饭、（3小时）驱车住特克斯、八卦城； 7.13：早起，（8点前）喀拉峻（8小时）、阔克苏大峡谷（4h）、（4小时车程）住那拉提； 7.14：（8点）那拉提风景区（一整天），住那拉提； 7.15：坐车到巴音（2.5小时），巴音天鹅湖、九曲十八弯（落日）、住巴音；（大巴车返回伊宁） 7.16：换5座或7座车，完整独库公路+s101国防公路（百里丹霞，走一段，不然吃不消），到乌鲁木齐； 7.17：返杭； ","date":"2022-07-22","objectID":"/posts/travel/xinjiang/:1:0","tags":["新疆"],"title":"新疆旅行-北疆","uri":"/posts/travel/xinjiang/"},{"categories":["旅游"],"content":"DAY1 2022.7.8, 头天晚上和同事一起吃夜宵到凌晨一点，聊得很嗨，晚上回家后又解决几个工作问题，本打算熬下夜直接去机场，谁知凌晨两点多，收到航空公司航班延迟起飞的信息， 果断睡觉； 早上起床后，收拾行李，刚好赶上早高峰，预估打车的话会堵车，测算地铁到机场的站总数后（地铁时间相对能准确预测），果断选择做地铁去机场； 最终一个半小时准时到达机场，和小伙伴汇合，完美; 11:55起飞，14:55到达兰州中川机场，机场吃了碗拉州拉面，本以为到达兰州本土，味道会有些不一样，结果证明期望过高，味道可能还不如个别面馆； 航班原计划19:35起飞，上飞机后，因为天气原因，硬生生拖到20:45才起飞（小插曲，上飞机后，有些累，就立马闭眼补觉，后来醒了看了下外面，哇塞，落地了，这么快，爽！； 然后在停顿了几秒，懵懵的看了下周围，脑袋瞬间清晰，瓦特… 这都一觉睡醒了，飞机还没起飞！！！），最终23:35到达伊宁。 目前还属于疫情管控时期，到新疆前需要提前申报行程，不然有可能落地后被原地劝返； 今天的时间基本全花在路途中。 ","date":"2022-07-22","objectID":"/posts/travel/xinjiang/:2:0","tags":["新疆"],"title":"新疆旅行-北疆","uri":"/posts/travel/xinjiang/"},{"categories":["旅游"],"content":"DAY2 今日安排：伊力特酒厂、六星街、伊犁河、喀赞其民宿旅游区。 借助花姐独特的人脉关系，有幸拜访伊力特酒厂，了解到酒厂的历史发展轨迹，由几代人共同的心血才铸就而成，心中五味杂陈。品尝了红冰、白冰葡萄酒，酸甜可口，让人垂涎三尺。 了解到了北纬45°生命线，独特的地理气候，最终生长出优质的瓜果粮食。品尝了内部迎宾特供伊力特45°白酒，味道纯正，不辛辣，后劲也不大，超出预期；午饭吃了羊肉包、羊肉，没有疝气，味道鲜美，怒赞！ 在六星街，看到新疆本土大叔悠闲的用手风琴演奏本土轻音乐，音调轻缓优美，让人瞬间放松，忘记一切凡尘琐事，享受生活。 自东向西流的伊犁河，以及晚上九点悬挂半空的大太阳. （以东部地区同学对东八区的时间理解，在这里有些颠覆认知） ","date":"2022-07-22","objectID":"/posts/travel/xinjiang/:3:0","tags":["新疆"],"title":"新疆旅行-北疆","uri":"/posts/travel/xinjiang/"},{"categories":["旅游"],"content":"DAY3 今日安排：紫仙镇薰衣草庄园、果子沟、赛里木湖。 7月中薰衣草已经花谢，薰衣草庄园里并没有看到成片的花海，听当地人说，最好6月中旬来。 果子沟全长4.4千米，大桥长700米。 塔里木湖【强烈推荐去！】 大西洋的最后一滴眼泪，让人沉醉； 围着赛里木湖转了一圈，感受到它的独特，海天一色的蓝，一望无际的湖面，让人内心平静； 坐在长廊中间，眺望眼前的赛里木湖，心无杂念，凡尘种种，皆为过往；远处挺拔的雪山和蓝天白云，造就出了当地人民心中的“净海”。 ","date":"2022-07-22","objectID":"/posts/travel/xinjiang/:4:0","tags":["新疆"],"title":"新疆旅行-北疆","uri":"/posts/travel/xinjiang/"},{"categories":["旅游"],"content":"DAY4 今日安排：油菜花田、入住夏塔旅游风景区； 去夏塔旅游风景区途中，遇到油菜花田，犹豫天气不太好，不好出片，如果天气不错，效果会很棒； 入住夏塔小木屋，晚上是真的冷，好在有电热毯，相对舒服的睡了半宿。 ","date":"2022-07-22","objectID":"/posts/travel/xinjiang/:5:0","tags":["新疆"],"title":"新疆旅行-北疆","uri":"/posts/travel/xinjiang/"},{"categories":["旅游"],"content":"DAY5 今日安排：徒步夏塔古道（20公里左右）、特克斯、八卦城； 早上五点半起床，六点出发徒步，目的地雪山； ","date":"2022-07-22","objectID":"/posts/travel/xinjiang/:6:0","tags":["新疆"],"title":"新疆旅行-北疆","uri":"/posts/travel/xinjiang/"},{"categories":["旅游"],"content":"DAY6 今日安排：喀拉峻草原、阔克苏大峡谷（4h） 喀拉峻草原\u0026\u0026阔克苏大峡谷，高山草原(7月这里的草，有些泛黄)，视野辽阔，山风吹过很冷，不过可以抱只小羊，相当暖和。 ","date":"2022-07-22","objectID":"/posts/travel/xinjiang/:7:0","tags":["新疆"],"title":"新疆旅行-北疆","uri":"/posts/travel/xinjiang/"},{"categories":["旅游"],"content":"DAY7 今日安排：那拉提风景区 ","date":"2022-07-22","objectID":"/posts/travel/xinjiang/:8:0","tags":["新疆"],"title":"新疆旅行-北疆","uri":"/posts/travel/xinjiang/"},{"categories":["旅游"],"content":"DAY8 今日安排：巴音天鹅湖、九曲十八弯（落日） 天鹅湖里有几只天鹅，但湖水味道呛人，过敏者慎入； 九曲十八弯，如果遇到落日，会更美；这里的山风吹得让人由内而外的发冷，山上有个小超市，买了包泡面，店主赠送开水，价钱合理，吃饱取暖，完美； ","date":"2022-07-22","objectID":"/posts/travel/xinjiang/:9:0","tags":["新疆"],"title":"新疆旅行-北疆","uri":"/posts/travel/xinjiang/"},{"categories":["旅游"],"content":"DAY9 今日安排：独库公路+s101国防公路，到乌鲁木齐 路上偶遇彩虹，有点超出预期； 一路上听说会经历春夏秋冬，途中遇到的几个小雪山，和预期中的差距蛮大，不过能近距离看到，也算不错。整条独库路是有些绕，不建议新手自驾； ","date":"2022-07-22","objectID":"/posts/travel/xinjiang/:10:0","tags":["新疆"],"title":"新疆旅行-北疆","uri":"/posts/travel/xinjiang/"},{"categories":["旅游"],"content":"DAY10 因为预定酒店比较找，酒店有赠送整点接送服务，所以早晨6点半起床，7点出门，7点一刻到机场，机场吃了点八宝粥，8:25乌鲁木齐起飞，中途郑州中转1小时，然后14：55到达杭州萧山。 ","date":"2022-07-22","objectID":"/posts/travel/xinjiang/:11:0","tags":["新疆"],"title":"新疆旅行-北疆","uri":"/posts/travel/xinjiang/"},{"categories":["旅游"],"content":"费用 去新机票：2217 返杭机票：2225 酒店+交通：3500 部分景点门票: 132+145+132+115+150+135 上述共计：8751； ","date":"2022-07-22","objectID":"/posts/travel/xinjiang/:12:0","tags":["新疆"],"title":"新疆旅行-北疆","uri":"/posts/travel/xinjiang/"},{"categories":["影视"],"content":"近期发现一部不错的韩国纪录片，关于如何学习，片名《学习的人.Homo.Academics》, 网易公开课、哔哩哔哩或外网均有完整视频。 这部片值得反复观看学习。 网易公开课 纪录片中，通过对韩国、中国、美国、英国、印度等国家进行深入采访，对比不同年龄段、不同民族、不同文化群体的学习方式； 印象很深刻的犹太族的家庭教育和犹太族的图书馆： 犹太的家庭教育，家长会在晚餐时，问孩子\"你今天在学校都问了哪些问题？\" 犹太人的图书馆，不是静悄悄，而是大声的激烈讨论、辩论会场； ","date":"2022-06-26","objectID":"/posts/life/movie/learning/:0:0","tags":["纪录片"],"title":"[纪录片] 学习的人.Homo.Academics","uri":"/posts/life/movie/learning/"},{"categories":null,"content":"ww java ListNode 链表 ","date":"2022-06-19","objectID":"/posts/tech/java/java-node/:0:0","tags":null,"title":"java链表","uri":"/posts/tech/java/java-node/"},{"categories":["part-time"],"content":" 方向 一到两个 方向/赛道，不要多。 知识分享、知识付费 （Java）– 起网名，中文、简单、便于搜索； 资料 自媒体-1 自媒体-2 自媒体-3 ","date":"2022-06-05","objectID":"/posts/life/parttime/wemeida/:0:0","tags":["自媒体"],"title":"自媒体","uri":"/posts/life/parttime/wemeida/"},{"categories":["Thinking"],"content":" 所有的行业-》提供产品，服务消费者，教培行业[知识付费] 每天都在重复、传授、吸收知识。– 如教师行业 知识星球。 知识是掌握路径： 学习 -\u003e 听，学、练习、掌握 -\u003e 遗忘 -》 使用前，在此学习。 如果你像日常三餐、睡觉一样的频率和规律 去反复学习同一拨知识，你的掌握水平会高于其他人。 ","date":"2022-06-03","objectID":"/posts/thinking/mine-thinking/:0:0","tags":["learning"],"title":"mine-thinking","uri":"/posts/thinking/mine-thinking/"},{"categories":["Tech"],"content":" github java Guide-1 java Guide-2 java Guide-git 1、不要沉迷框架，修炼内功 2、提高英语阅读能力【google translate】 3、职场从来不缺普通的程序员 4、工作之外有自己感兴趣的东西 5、学会规划自己的时间，时间管理【be foucused、番茄todo】 6、学会安排自己的任务【Trello】 7、学会使用工具提升工作效率 8、 学会休息，注意健康 对业务和产品比较敏感。 提升技术的深度、技术的广度、对业务和产品敏感的个人。 用最快的方式，提高自己的核心竞争力。 ","date":"2022-06-02","objectID":"/posts/tech/collection-material/:0:0","tags":["learning"],"title":"collection_material","uri":"/posts/tech/collection-material/"},{"categories":["Tech"],"content":"内网-这些年-姐妹篇 Tools Arthas-Java monitor Collection Robin的博客 横云断岭的博客 横云断岭 github 代码随想录 \u0026\u0026 刷题网站 githhub-demo 代码随想录 - github刷题整理- 适合2/3刷 github-刷题集合（含leecode） ","date":"2022-06-02","objectID":"/posts/tech/collection-material/:1:0","tags":["learning"],"title":"collection_material","uri":"/posts/tech/collection-material/"},{"categories":["Tech"],"content":"Mac mac-mysql安装-参考-1 mac-mysql安装-参考-2 mac-python3 安装-参考 mac-Homebrew 安装-参考 ","date":"2022-05-01","objectID":"/posts/tech/setup/install-software-collection/:0:0","tags":["install"],"title":"Mac下开发工具安装","uri":"/posts/tech/setup/install-software-collection/"},{"categories":["github"],"content":"github 自动部署, refer to : Hugo 白话文 | GitHub Action 自动部署 基于 Github Action 自动构建 Hugo 博客 ","date":"2022-03-13","objectID":"/posts/tech/github/githubaction/:0:0","tags":["github","hugo"],"title":"Github Pages Action","uri":"/posts/tech/github/githubaction/"},{"categories":["github"],"content":"document ","date":"2022-03-13","objectID":"/posts/tech/github/githubaction/:1:0","tags":["github","hugo"],"title":"Github Pages Action","uri":"/posts/tech/github/githubaction/"},{"categories":["读书笔记"],"content":" 案例背景 中国正处在一个至关重要的十字路口上。制造廉价产品已使中国有了很大的发展，但上升的劳动力成本、环境问题、收人不平等以及对创新的需求都意味着重要的不是制造更廉价的产品，而是更好地进行产品营销。只有这样，中国才能赚更多的钱，才能在员工收人、环境保护和其他方面进行更大的投人。这意味着中国需要更好地掌握如何在顾客和潜在顾客的心智中建立品牌和认知，如何应对国内及国际上无处不在的竞争. 这也正是我的许多书能够发挥作用的地方。它们都是关于如何通过在众多竞争者中实现差昇化来定位自己的品牌；它们都是关于如何保持简单、如何运用常识以及如何寻求显而易见又强有力的概念。总的来讲，无论你想要销售什么，它们都会告诉你如何成为一个更好的营销者。 我的中国合伙人邓德隆先生正将其中的很多理论在中国加以运用，他甚至为企业家开设了 “定位”培训课程。但是，中国如果要建立自己的品牌，正如你们在日本、韩国和世界其他地方所看到的那些品牌，你们依然有很长的路要走。 但有一件事很明了：继续“制造更廉价的产品”只会死路一条，因为其他国家会想办法把价格压得更低。 新生产工具：定位 在此背景下，为组织准确定义成果的新生产工具一定位(positioning），在1969年被杰克•特芳特发明出来，掀起了第三次生产力革命。在谈到为何选择“定位”一词来命名这一新工具时，特劳特曾说：“《韦氏词典》对战略的定义是针对敌人（竞争对手）确立最具优势的位置 （position)。这正好是定位要做的工作。” 在顾客心智中针对竞争对手确定最具优势的位置，从而使品牌胜出竟争赢得优先选择，这就是企业需全力以赴抵达的成果，也是企业赖以存在的唯一理由。正如德鲁克在评价泰勒“四步工作法”时说：“泰勒的方法听起来没什么了不起有效的方法常常如此。其实这套方法花了泰勒整整20年的时间去试验，才整理发展出来。”这段话用来描述特劳特与定位同样适用。 定位四步工作法 第一步，分析整个外部环境，确定“我们的竞年对手是谁，竞争对手的价值是什么”（这与德鲁克在回答管理第一问“我们的业务是什么，应该是什么”时问的 “我们的顾客是谁，顾客的价值是什么”相反，因过多的选择、 有限的心智，决定了经营方式已从顾客导向转向了竞年导向）。 第二步，避开竞年对手在顾客心智中的强势，或是利用其强势中蕴含的弱点，确立品牌的优势位置-定位。 第三步，为这一定位寻求一个可靠的证明——信任状。 第四步，将这一定位整合进企业内部运营的方方面面，特别是传播上要有足够多的资源，以将这一定位植人顾客的心智 ","date":"2021-09-21","objectID":"/posts/book/life_orientation/:0:0","tags":["规划"],"title":"[读书笔记] 《人生定位》","uri":"/posts/book/life_orientation/"},{"categories":["hugo"],"content":"Hugo如何添加about页 ","date":"2021-08-14","objectID":"/posts/tech/tools/hugo-config/:0:0","tags":["hugo"],"title":"Hugo配置","uri":"/posts/tech/tools/hugo-config/"},{"categories":["hugo"],"content":"创建页面 此处以even模板为例 hugo new post/about.md 文件创建完成后，会生成在 ${根目录}/content/post/目录下； 将about.md上移一层，到${根目录}/content/下, 和post目录同级。 ","date":"2021-08-14","objectID":"/posts/tech/tools/hugo-config/:1:0","tags":["hugo"],"title":"Hugo配置","uri":"/posts/tech/tools/hugo-config/"},{"categories":["hugo"],"content":"修改配置 修改根目录文件config.toml，新增如下配置 [[menu.main]] name = \"关于\" identifier = \"about\" url = \"/about/\" weight = 50 weight 根据menu的顺序自定义数字即可； ","date":"2021-08-14","objectID":"/posts/tech/tools/hugo-config/:2:0","tags":["hugo"],"title":"Hugo配置","uri":"/posts/tech/tools/hugo-config/"},{"categories":["hugo"],"content":"启动服务 hugo server -D 访问：http://localhost:1313 即可查看效果； Hugo添加文章目录toc config.toml中加上toc的显示控制变量. toc = true 访问计数 如下配置 [params] [params.busuanzi] # count web traffic by busuanzi # 是否使用不蒜子统计站点访问量 enable = true siteUV = true sitePV = true pagePV = true 评论 [params.utteranc] # https://utteranc.es/ enable = true repo = \"lovelock/blog-comments\" # The repo to store comments issueTerm = \"pathname\" #表示你选择以那种方式让github issue的评论和你的文章关联。 theme = \"github-light\" # 样式主题，有github-light和github-dark两种 async = true ","date":"2021-08-14","objectID":"/posts/tech/tools/hugo-config/:3:0","tags":["hugo"],"title":"Hugo配置","uri":"/posts/tech/tools/hugo-config/"},{"categories":["旅游"],"content":"海南outing ","date":"2021-07-13","objectID":"/posts/travel/wanning/:0:0","tags":["海南","万宁","三亚"],"title":"万宁Outing","uri":"/posts/travel/wanning/"},{"categories":["运动健身"],"content":"第一次报名参加越野跑，也就是传说中的跑山、跑土路，听上去就蛮刺激的； 真的跑山哈，没路的话，就硬踩出路。 左右边都是茶田，空气蛮好； 总行程10.3km，总耗时98分钟，两步路记录比较准确。 首次参加越野跑，5人小组赛10km越野跑，获得团队第一； 奖品是人手500g 西湖明前龙井茶叶；不错不错； ","date":"2021-04-24","objectID":"/posts/life/sport/westlake2021/:0:0","tags":["马拉松","越野"],"title":"西湖群山越野赛","uri":"/posts/life/sport/westlake2021/"},{"categories":null,"content":"使用 ","date":"2020-09-10","objectID":"/posts/mac-translate-word/:0:0","tags":null,"title":"Mac下文字转换语音","uri":"/posts/mac-translate-word/"},{"categories":null,"content":"简单调用 在mac的命令行下面，执行： say hello world 就可以发出\"hello world\"的声音了，支持中文。 ","date":"2020-09-10","objectID":"/posts/mac-translate-word/:1:0","tags":null,"title":"Mac下文字转换语音","uri":"/posts/mac-translate-word/"},{"categories":null,"content":"文本文件播放语音 新建一个文本文件aa.txt，在终端里在，cd 到该目录，然后执行: say -f aa.txt ","date":"2020-09-10","objectID":"/posts/mac-translate-word/:2:0","tags":null,"title":"Mac下文字转换语音","uri":"/posts/mac-translate-word/"},{"categories":null,"content":"文本文件转为语音文件 新建一个文本文件aa.txt，在终端里在，cd 到该目录，然后执行: say -f aa.txt -o a.m4a 即可生成a.m4a这个语音文件。 -f 后面跟的是需要转换成语音的文件，-o 是 -out 的意思。 ","date":"2020-09-10","objectID":"/posts/mac-translate-word/:3:0","tags":null,"title":"Mac下文字转换语音","uri":"/posts/mac-translate-word/"},{"categories":null,"content":"设置 修改语音声音 打开Mac系统偏好设置-\u003e辅助功能-\u003e语音 对于国人来说，Sin-ji是讲粤语的，而Ting-ting是讲普通话的。当然，所有的演员都认识英文。 可切换语种 可调整语速 参照 https://javascript.net.cn/articles/721 https://newsn.net/say/mac-command-say.html ","date":"2020-09-10","objectID":"/posts/mac-translate-word/:4:0","tags":null,"title":"Mac下文字转换语音","uri":"/posts/mac-translate-word/"},{"categories":["hugo"],"content":" hugo介绍 Hugo Hugo 几年前的影响力是不如 hexo 的，但现在越来越多的人从 hexo 迁移到了 Hugo，Hugo使用人数也多了起来，GitHub 上 Hugo 项目有 56.2k 个 star，已远远超过了 hexo，因此你也不用太担心 Hugo 会不会太小众化的问题，但是 Hugo 上的主题选择会更少一些，其中最受欢迎的是 wowchemy，但也仅有 6.1k 个star，而本站采用的是 LoveIt 主题，它的 star 就更少了，才 1.6k 个。当然，如果你是搞前端开发的，或者乐意自己写主题，那这些就不重要了。 ","date":"2020-08-13","objectID":"/posts/tech/tools/hugo/:0:0","tags":["hugo","博客"],"title":"使用hugo搭建个人博客mac版[How to build a blog quickly?]","uri":"/posts/tech/tools/hugo/"},{"categories":["hugo"],"content":"Hugo优点： 速度快 Hugo 采用 Go 语言编写，它的速度用作者的话来形容就是世界上最快的构建网站工具。并且 Hugo 是即时渲染的，这意味着你可以边写边改样式，直到你满意为止。即使是你写了几百篇文章，它也能在几秒之内全部渲染完成。 The world’s fastest framework for building websites 配置更为简单 你需要安装只是 Hugo，不像 hexo 还得安装 Node.js。并且Hugo 中是不区分站点和主题的配置文件的，Hugo 中只有一个位于站点根目录下的 config.toml 配置文件，你只用在这里面进行修改就可以了。 方便自定义 你可以在不修改主题文件的前提下方便地定制主题。在 Hugo 中，如果你想要定制主题，你只需在站点目录下新建相应的文件即可。这是非常利于主题的维护的，你只需使用 Git 的 submodule 的方式安装 Hugo 的主题，然后更新时只需直接在站点根目录下敲一条命令回车即可，非常方便！ ","date":"2020-08-13","objectID":"/posts/tech/tools/hugo/:1:0","tags":["hugo","博客"],"title":"使用hugo搭建个人博客mac版[How to build a blog quickly?]","uri":"/posts/tech/tools/hugo/"},{"categories":["hugo"],"content":"缺点： 主题比较少，很可能大家都是用的同一个主题，并且主题作者更新会更少一点。 总结：如果你喜欢 DIY，我建议使用 Hugo。如果你是个专业博主，写了很多文章需要渲染，我建议使用 Hugo！ 环境准备 ","date":"2020-08-13","objectID":"/posts/tech/tools/hugo/:2:0","tags":["hugo","博客"],"title":"使用hugo搭建个人博客mac版[How to build a blog quickly?]","uri":"/posts/tech/tools/hugo/"},{"categories":["hugo"],"content":"1.安装 hugo 自动安装（依赖网速，可能会非常慢） 在终端中输入 brew install hugo安装。 安装成功后可输入hugo version查看版本信息。 手工安装 首先，请前往 GitHub 上下载最新版的 Hugo 压缩包，Releases · gohugoio/hugo (github.com)，建议选择 extended 版本，这将更有利于后续的 DIY 操作！ 下载完成后解压到一个你认为合适的位置，然后把 hugo.exe 所在的文件夹添加至环境变量中的 Path 中即可。 ","date":"2020-08-13","objectID":"/posts/tech/tools/hugo/:3:0","tags":["hugo","博客"],"title":"使用hugo搭建个人博客mac版[How to build a blog quickly?]","uri":"/posts/tech/tools/hugo/"},{"categories":["hugo"],"content":"2.创建新网址 hugo new site quickstart 其中quickstart更改为用户名.github.io-creator（用户名为 github 用户名，需要小写） 使用code 用户名.github.io-creator使用 vscode 查看目录 ","date":"2020-08-13","objectID":"/posts/tech/tools/hugo/:4:0","tags":["hugo","博客"],"title":"使用hugo搭建个人博客mac版[How to build a blog quickly?]","uri":"/posts/tech/tools/hugo/"},{"categories":["hugo"],"content":"3.添加一个主题 在 quickstart 目录下打开新的终端，输入 git init git clone https://github.com/olOwOlo/hugo-theme-even themes/even 把 \\themes\\LoveIt\\exampleSite目录下的config.toml复制下来，替换掉站点根目录下的同名文件。 然后对这个文件进行一些自定义修改。 然后进入根目录下的archetypes文件夹中，修改default.md文件为下面的内容（这个文件是模板文件，通过指令创建的文章将以模板为基础内容） title: \"{{ replace .Name \"-\" \" \" | title }}\" date: {{ .Date }} tags: [\"\"] categories: [\"\"] toc: enable: true description: draft: true 其中title表示文章标题，date为生成文章当时的时间，tags为标签，categories为目录，toc enable为启用文章目录（需要自己在文章中生成），description为文章摘要，draft表示是否为草稿（写完了文章把这里改为 false 即可）， 为 LoveIt 主题的摘要标识符，该标识符上方的内容为文章摘要，如果上方为空，则采用 frontmatter 中设置的descriptions为文章摘要。 添加文件 现在开始撰写文章 hugo new posts/my-first-post.md 并将draft：ture更改为draft：false。 注意: 对于even这个主题，应该使用 post 而不是 posts，即 hugo new post/some-content.md 构建页面 写完了文章进行网页的构建 hugo server -D -e production -D表示草稿也要渲染，-serve表示启动一个本地服务器，即时渲染，方便修改。 hugo serve 的默认运行环境是 development, 而 hugo 的默认运行环境是 production。 由于本地 development 环境的限制, 评论系统**, **CDN 和 fingerprint 不会在 development 环境下启用。 你可以使用 hugo serve -e production 命令来开启这些特性。 值得一提的是不论输入的是server还是serve都是一样的。 在浏览器中前往它给出的 http://localhost:1313 就能看到你刚生成的博客了。 当你运行 hugo serve 时, 当文件内容更改时, 页面会随着更改自动刷新. 现在再输入指令 hugo -D 这会生成一个 public 目录, 其中包含你网站的所有静态内容和资源. 现在可以将其部署在任何 Web 服务器上。 确认无误后就要把它发到公网上了，这里采用 GitHub pages 进行部署（当然，也有很多种方法也能达成这一目的） 启动 Hugo 服务器 hugo server -D -D 代表草稿态 ","date":"2020-08-13","objectID":"/posts/tech/tools/hugo/:5:0","tags":["hugo","博客"],"title":"使用hugo搭建个人博客mac版[How to build a blog quickly?]","uri":"/posts/tech/tools/hugo/"},{"categories":["hugo"],"content":"上传至 github Refer 参考 ","date":"2020-08-13","objectID":"/posts/tech/tools/hugo/:6:0","tags":["hugo","博客"],"title":"使用hugo搭建个人博客mac版[How to build a blog quickly?]","uri":"/posts/tech/tools/hugo/"},{"categories":["hugo"],"content":"知识点 用hugo生成的网站包含以下文件和文件夹： archetypes: 储存.md的模板文件，该文件夹的优先级高于themes下的archetypes文件夹 config.toml: 配置文件 content: 储存网站的所有内容 data: 储存数据文件供模板调用 layouts: 储存.html模板，该文件夹的优先级高于主题下的layouts文件夹 static: 储存图片、css、js等静态文件，该目录下的文件会直接拷贝到/public，该文件夹的优先级高于主题下的/static文件夹 themes: 储存主题 public: 执行hugo命令后，储存生成的静态文件 ","date":"2020-08-13","objectID":"/posts/tech/tools/hugo/:7:0","tags":["hugo","博客"],"title":"使用hugo搭建个人博客mac版[How to build a blog quickly?]","uri":"/posts/tech/tools/hugo/"},{"categories":["hugo"],"content":"Hugo置顶文章 Hugo 置顶文章很简单，只需要将以下放在文章头部即可置顶 --- weight: 1 --- ","date":"2020-08-13","objectID":"/posts/tech/tools/hugo/:8:0","tags":["hugo","博客"],"title":"使用hugo搭建个人博客mac版[How to build a blog quickly?]","uri":"/posts/tech/tools/hugo/"},{"categories":["Tech"],"content":"思维导图 ","date":"2020-05-29","objectID":"/posts/tech/tools/tools-paint/:0:0","tags":["作图（paint）"],"title":"常用作图工具(工作\u0026\u0026生活)","uri":"/posts/tech/tools/tools-paint/"},{"categories":["Tech"],"content":"xmind UML ","date":"2020-05-29","objectID":"/posts/tech/tools/tools-paint/:1:0","tags":["作图（paint）"],"title":"常用作图工具(工作\u0026\u0026生活)","uri":"/posts/tech/tools/tools-paint/"},{"categories":["Tech"],"content":"plantUML Official website demo ","date":"2020-05-29","objectID":"/posts/tech/tools/tools-paint/:2:0","tags":["作图（paint）"],"title":"常用作图工具(工作\u0026\u0026生活)","uri":"/posts/tech/tools/tools-paint/"},{"categories":["Tech"],"content":"IDEA plant plugins idea plugin 流程图 ","date":"2020-05-29","objectID":"/posts/tech/tools/tools-paint/:3:0","tags":["作图（paint）"],"title":"常用作图工具(工作\u0026\u0026生活)","uri":"/posts/tech/tools/tools-paint/"},{"categories":["Tech"],"content":"Omni全家桶 OmniGraffle Mac平台的流程图绘制软件，相当于windows平台的visio OmniPlan 工期规划甘特图的工具 ","date":"2020-05-29","objectID":"/posts/tech/tools/tools-paint/:4:0","tags":["作图（paint）"],"title":"常用作图工具(工作\u0026\u0026生活)","uri":"/posts/tech/tools/tools-paint/"},{"categories":["Tech"],"content":"Gliffy diagrams ","date":"2020-05-29","objectID":"/posts/tech/tools/tools-paint/:5:0","tags":["作图（paint）"],"title":"常用作图工具(工作\u0026\u0026生活)","uri":"/posts/tech/tools/tools-paint/"},{"categories":["Tech"],"content":" Chart github: Python3 chart ","date":"2019-12-05","objectID":"/posts/tech/python/python3/:0:0","tags":["python"],"title":"python3","uri":"/posts/tech/python/python3/"},{"categories":["Tech"],"content":"具体的解决方案如下： 苹果-\u003e系统偏好设置-\u003e最下边点mysql 在弹出页面中 关闭mysql服务（点击stop mysql server） 进入终端输入：cd /usr/local/mysql/bin/ 回车后 登录管理员权限 sudo su 输入mac的管理员密码 回车后输入以下命令来禁止mysql验证功能 ./mysqld_safe –skip-grant-tables \u0026 回车后mysql会自动重启（偏好设置中mysql的状态会变成running） 输入命令 ./mysql 输入命令 FLUSH PRIVILEGES; 输入命令 SET PASSWORD FOR ‘root’@’localhost’ = PASSWORD(‘你的新密码’); 至此，密码已经修改成功，可以登录啦！ ","date":"2019-06-16","objectID":"/posts/tech/setup/mac-reset-mysql-pwd/:0:0","tags":["install","mysql"],"title":"Mac下Mysql重置密码","uri":"/posts/tech/setup/mac-reset-mysql-pwd/"},{"categories":null,"content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. ","date":"2019-03-03","objectID":"/posts/tech/tools/tools-hexo/:0:0","tags":null,"title":"hexo demo","uri":"/posts/tech/tools/tools-hexo/"},{"categories":null,"content":"Quick Start ","date":"2019-03-03","objectID":"/posts/tech/tools/tools-hexo/:1:0","tags":null,"title":"hexo demo","uri":"/posts/tech/tools/tools-hexo/"},{"categories":null,"content":"Create a new post $ hexo new \"My New Post\" More info: Writing ","date":"2019-03-03","objectID":"/posts/tech/tools/tools-hexo/:1:1","tags":null,"title":"hexo demo","uri":"/posts/tech/tools/tools-hexo/"},{"categories":null,"content":"Run server $ hexo server More info: Server ","date":"2019-03-03","objectID":"/posts/tech/tools/tools-hexo/:1:2","tags":null,"title":"hexo demo","uri":"/posts/tech/tools/tools-hexo/"},{"categories":null,"content":"Generate static files $ hexo generate More info: Generating ","date":"2019-03-03","objectID":"/posts/tech/tools/tools-hexo/:1:3","tags":null,"title":"hexo demo","uri":"/posts/tech/tools/tools-hexo/"},{"categories":null,"content":"Deploy to remote sites $ hexo deploy More info: Deployment ","date":"2019-03-03","objectID":"/posts/tech/tools/tools-hexo/:1:4","tags":null,"title":"hexo demo","uri":"/posts/tech/tools/tools-hexo/"},{"categories":["Tech"],"content":" markdown-it-demo Refer markdown grammar Markdown，写博客当然要用这个。在线编辑器，所见即所得地编写。 ","date":"2019-03-02","objectID":"/posts/tech/tools/markdown/:0:0","tags":["markdown"],"title":"markdown","uri":"/posts/tech/tools/markdown/"},{"categories":["Tech"],"content":"标题 markdown总支持1~6六级标题，通过在一行之前加上不同数量的井号来表示。 # 这是 H1 # ## 这是 H2 ## ### 这是 H3 ### … ","date":"2019-03-02","objectID":"/posts/tech/tools/markdown/:1:0","tags":["markdown"],"title":"markdown","uri":"/posts/tech/tools/markdown/"},{"categories":["Tech"],"content":"段落 非常自然，一行文字就是一个段落。 w1 ","date":"2019-03-02","objectID":"/posts/tech/tools/markdown/:2:0","tags":["markdown"],"title":"markdown","uri":"/posts/tech/tools/markdown/"},{"categories":["Tech"],"content":"粗体、斜体 可以使用星号*或下划线_指定粗体或者斜体。 这是斜体 这也是斜体 这是粗体 这是粗体+斜体 *这是斜体* _这也是斜体_ **这是粗体** ***这是粗体+斜体*** ","date":"2019-03-02","objectID":"/posts/tech/tools/markdown/:3:0","tags":["markdown"],"title":"markdown","uri":"/posts/tech/tools/markdown/"},{"categories":["Tech"],"content":"删除线 删除线 ~~删除线~~ ","date":"2019-03-02","objectID":"/posts/tech/tools/markdown/:4:0","tags":["markdown"],"title":"markdown","uri":"/posts/tech/tools/markdown/"},{"categories":["Tech"],"content":"引用 通过在行首加上大于号\u003e来添加引用格式。 DD DD 引用可以嵌套： w 引用可以嵌套： \u003ew \u003e \u003e引用可以嵌套： 也可以嵌套其他格式： ","date":"2019-03-02","objectID":"/posts/tech/tools/markdown/:5:0","tags":["markdown"],"title":"markdown","uri":"/posts/tech/tools/markdown/"},{"categories":["Tech"],"content":"列表 无序列表使用星号、加号或是减号作为列表标记： Red Green Blue 等同于 Red Green Blue 和 Red Green Blue - Red - Green - Blue 有序列表则使用数字接着一个英文句点： Bird McHale Parish 数字并不会影响输出的 HTML 结果，也就是说上面的例子等同于： Bird McHale Parish ","date":"2019-03-02","objectID":"/posts/tech/tools/markdown/:6:0","tags":["markdown"],"title":"markdown","uri":"/posts/tech/tools/markdown/"},{"categories":["Tech"],"content":"内联代码 用反引号` 来标记内联代码，它们会解释成标签 \u003ccode\u003e标签\u003c/code\u003e 如果代码的内容中有反引号，请用两个反引号包裹。 代码中的\u0026、\u003c、\u003e符号都会自动转义，请放心使用。 eee 还有一种是github的风格，代码段的前后用三个反引号 ``` 独占一行来标记。 ww ","date":"2019-03-02","objectID":"/posts/tech/tools/markdown/:7:0","tags":["markdown"],"title":"markdown","uri":"/posts/tech/tools/markdown/"},{"categories":["Tech"],"content":"分隔线 你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线： * * * *** ***** - - - --------------------------------------- ","date":"2019-03-02","objectID":"/posts/tech/tools/markdown/:8:0","tags":["markdown"],"title":"markdown","uri":"/posts/tech/tools/markdown/"},{"categories":["Tech"],"content":"超链接 an example an example [an example](http://example.com/) [an example](http://example.com/ \"Optional Title\") 会被解释为 \u003ca href='https://www.google.com/'\u003egoogle\u003c/a\u003e \u003ca href='https://www.google.com/' title=\"Optional Title\"\u003egoogle\u003c/a\u003e ","date":"2019-03-02","objectID":"/posts/tech/tools/markdown/:9:0","tags":["markdown"],"title":"markdown","uri":"/posts/tech/tools/markdown/"},{"categories":["Tech"],"content":"转义 markdown支持在以下字符前面插入反斜杠，插入之后，将不再解析这些字符，而是原样输出。 \\ 反斜线 ` 反引号 * 星号 _ 底线 {} 花括号 [] 方括号 () 括弧 # 井字号 + 加号 - 减号 . 英文句点 ! 惊叹号 ","date":"2019-03-02","objectID":"/posts/tech/tools/markdown/:10:0","tags":["markdown"],"title":"markdown","uri":"/posts/tech/tools/markdown/"},{"categories":["Tech"],"content":"表格 Item Value Qty Computer $1600 5 Phone $12 12 Pipe $1 234 | Item | Value | Qty | | :------- | ----: | :---: | | Computer | $1600 | 5 | | Phone | $12 | 12 | | Pipe | $1 | 234 | title1 title2 v1 v2 要注意第二行的冒号决定了居左居右还是居中，如果你不加冒号，默认是居左的。 另外可以把第一行去掉，做成没有表头的表格，但第二行始终是要有的。 ","date":"2019-03-02","objectID":"/posts/tech/tools/markdown/:11:0","tags":["markdown"],"title":"markdown","uri":"/posts/tech/tools/markdown/"},{"categories":["Tech"],"content":"TOC TOC = Table of content ， 将内容制作成导航 hexo toc 快速生成markdown目录TOC 快速生成markdown目录TOC，页内跳转 ","date":"2019-03-02","objectID":"/posts/tech/tools/markdown/:12:0","tags":["markdown"],"title":"markdown","uri":"/posts/tech/tools/markdown/"},{"categories":["Tech"],"content":"checkbox checkbox - [ ] checkbox 图片 ","date":"2019-03-02","objectID":"/posts/tech/tools/markdown/:13:0","tags":["markdown"],"title":"markdown","uri":"/posts/tech/tools/markdown/"},{"categories":["Tech"],"content":"内联 Optional Title ![Alt text](/path/img.jpg) ![Alt text](/path/img.jpg \"Optional Title\") 会被解释为 \u003cimg src='/path/to/img.jpg' alt='Alt text' /\u003e \u003cimg src='/path/to/img.jpg' alt='Alt text' title='Optional Title' /\u003e ","date":"2019-03-02","objectID":"/posts/tech/tools/markdown/:14:0","tags":["markdown"],"title":"markdown","uri":"/posts/tech/tools/markdown/"},{"categories":["Tech"],"content":"外联 ![图片](https://www.baidu.com/img/PCtm_d9c8750bed0b3c7d089fa7d55720d6cf.png) ","date":"2019-03-02","objectID":"/posts/tech/tools/markdown/:15:0","tags":["markdown"],"title":"markdown","uri":"/posts/tech/tools/markdown/"}]